# Инфо
...

# 24.09.04 - Лекция
Ну короче, есть нити в системах, а есть нити в Java. Они делают дела

# 24.09.11 - Лекция
*"condition - тут как в медицине, то есть если человек лежит в коме, это condition, если у него нет ноги, это тоже condition"*

*ПЕРВОЕ НОВОЕ ПРЕДЛОЖЕНИЕ ПОД КОНЕЦ ВТОРОЙ ЛЕКЦИИ!!!*

Класс `Timer` позволяет назначить выполнение задачи по расписанию, используя лямбда-интерфейс `TimerTask`

# 24.09.18 - Лекция
*Охереть, теперь про `CyclicBarrier` рассказывает...*

`Future` удобно использовать для 

## Событийно ориентированные системы
Java хороша тем, что в объекте класса удобно хранить состояние, с которым будет взаимодействовать обработчик события

# 24.10.24
## Как запустить clojure у себя


# 24.10.31
*Ладно, надо бы хоть немного конспектировать происходящее...*

## генераторы

## Ленивые вычисления
`map` - **ЛЕНИВЫЙ**, равно как и `take`, а ещё много-много чего

`(doall lazy_list)` говорит, что нужно сделать все возможные вычисления в ленивом списке

**Оставить записи после второй лабы о генераторах и ленивых вычислениях**

# 24.11.06
## Сборщик мусора в Clojure
Праллелизм в функциональных языков (до определённой меры) очень естественен и выражается через map-reduce концепцию:
- `pmap` получает коллекцию, которая дробится на части, которые обрабатываются в разных потоках
- `preduce` дожидается получения следующего куска коллекции и проводит над ним аккумулирующую операцию

`pmap` встроен в clojure и может дать большой прирост. `preduce` даёт не такой большой прирост, поэтому не всегда полезен и не реализуется в clojure базово

Собственная реализация `preduce`:
```clj
(defn p-reduce-1
  ([value-f init-val coll]
    (p-reduce-1 value-f value-f init-val coll))
  ([value-f merge-f init-val coll]
    (
      let [chunk-size (int (Math/ceil (Math/sqrt (count coll)))),
          parts (partition-all chunk-size coll)]
      (reduce merge-f init-val
        (pmap (partial reduce value-f init-val) parts)
      )
    )
  )
)
(reduce + 0 (range 1 16)) ;>> 120
(p-reduce-1 + 0 (range 1 16)) ;>> 120
;;will it always be equivalent to reduce?
```

Реализация параллелизма в более общем случае делается при помощи `future` (вместе с трэд пулами, которые при этом неявные):
```clj
(future (expression)) ;; исполняет блок кода
(future-call (fn [] (expression))) ;; исполняет 0-арную функцию
(deref f) ;; ожидание реальтата future f
(@ f) ;; то же самое
```

# 24.11.13 - лекция
## Атомарные типы
*надо будет повторить...*

# 24.11.20 - лекция
## Транзации
Повторять определение с ОСей не буду, а сразу перейдём к основным её принципам - ACID:
- **Atomicity** - атомарность - выполнение целиком либо не выполнение вовсе
- **Consistency** - целостность - транзация переводит систему из одного валидного состояния в другое
- **Isolation** - изоляция - транзации не должны взаимодействовать между собой, то есть при ух паараллельном исполнении они должны быть исполнены так, будто были исполнены последовательно в **некотором** порядке
- **Durability** - *монументальность? (хз, как это лучше перевести)* - завершённая транзация не должна быть никак утеряна

В рамках ХОИ и параллелизма нас в первую очередь интересует **изоляция**, которая решает целый ряд проблем:
- Lost update - тут более-менее понятно
- Dirty read - возникает в случае, если одна транзакция прочитает данные, которые уже изменила другая, а позже эта другая транзация откатилась, из-за чего первая прочитала данные, которых вообще уже нет в природе
- Non-repeatbale read - первый раз долгая транзакция прочитала одно значение, потом быстрая транзакция изменила значение, а следом долгая получила новое значение при чтении, что сломало ожидаемый результат

Решить проблему изоляции предназначен транзакционная память, которая может реализовываться и аппаратно, и программно

Один из примеров - это MVCC (multi-version concurrency control) - создаём копии мастер-состояния для каждого потока, потом пытаемся провести слияния, падаем в случае неудачи. По сути, чуть более комплексные атомики

*Всё API для транзакций в clojure смотри в презентации*

Отличия `commute` от `alter` заключается в том, что commute регистрирует функцию и применяет её к копии master-state, а затем также и к самому master-state. Благодаря такому механизму для простых операций мы не будем получать lost update, однако есть ряд правил:
- Все операции над одним референсом должны быть с `commute`
- Все операции должны быть легковесными
- Транзакция не может полагаться на состояние референса, если используются `commute`

# 24.11.27 и 24.12.04 - Лекция
## XML
**Базовый элемент языка разметки XML** - тэги открывающий и закрывающий (*и ещё что-то*)

**Well-formed XML** - XML-документ, удовлетворяющий базовым требованиям:
- Комплиментарность
- Древовидность
- ...

**Valid XML** - более строгое состояние XML-документа, требующее дополнительной настройки