# Инфо
...

# 24.09.04 - Лекция
Ну короче, есть нити в системах, а есть нити в Java. Они делают дела

# 24.09.11 - Лекция
*"condition - тут как в медицине, то есть если человек лежит в коме, это condition, если у него нет ноги, это тоже condition"*

*ПЕРВОЕ НОВОЕ ПРЕДЛОЖЕНИЕ ПОД КОНЕЦ ВТОРОЙ ЛЕКЦИИ!!!*

Класс `Timer` позволяет назначить выполнение задачи по расписанию, используя лямбда-интерфейс `TimerTask`

# 24.09.18 - Лекция
*Охереть, теперь про `CyclicBarrier` рассказывает...*

`Future` удобно использовать для 

## Событийно ориентированные системы
Java хороша тем, что в объекте класса удобно хранить состояние, с которым будет взаимодействовать обработчик события

# 24.10.24
## Как запустить clojure у себя


# 24.10.31
*Ладно, надо бы хоть немного конспектировать происходящее...*

## генераторы

## Ленивые вычисления
`map` - **ЛЕНИВЫЙ**, равно как и `take`, а ещё много-много чего

`(doall lazy_list)` говорит, что нужно сделать все возможные вычисления в ленивом списке

**Оставить записи после второй лабы о генераторах и ленивых вычислениях**

# 24.11.06
## Сборщик мусора в Clojure
Праллелизм в функциональных языков (до определённой меры) очень естественен и выражается через map-reduce концепцию:
- `pmap` получает коллекцию, которая дробится на части, которые обрабатываются в разных потоках
- `preduce` дожидается получения следующего куска коллекции и проводит над ним аккумулирующую операцию

`pmap` встроен в clojure и может дать большой прирост. `preduce` даёт не такой большой прирост, поэтому не всегда полезен и не реализуется в clojure базово

Собственная реализация `preduce`:
```clj
(defn p-reduce-1
  ([value-f init-val coll]
    (p-reduce-1 value-f value-f init-val coll))
  ([value-f merge-f init-val coll]
    (
      let [chunk-size (int (Math/ceil (Math/sqrt (count coll)))),
          parts (partition-all chunk-size coll)]
      (reduce merge-f init-val
        (pmap (partial reduce value-f init-val) parts)
      )
    )
  )
)
(reduce + 0 (range 1 16)) ;>> 120
(p-reduce-1 + 0 (range 1 16)) ;>> 120
;;will it always be equivalent to reduce?
```

Реализация параллелизма в более общем случае делается при помощи `future` (вместе с трэд пулами, которые при этом неявные):
```clj
(future (expression)) ;; исполняет блок кода
(future-call (fn [] (expression))) ;; исполняет 0-арную функцию
(deref f) ;; ожидание реальтата future f
(@ f) ;; то же самое
```

# 24.11.13 - лекция
## Атомарные типы
*надо будет повторить...*

# 24.11.20 - лекция
## Транзации
Повторять определение с ОСей не буду, а сразу перейдём к основным её принципам - ACID:
- **Atomicity** - атомарность - выполнение целиком либо не выполнение вовсе
- **Consistency** - целостность - транзация переводит систему из одного валидного состояния в другое
- **Isolation** - изоляция - транзации не должны взаимодействовать между собой, то есть при ух паараллельном исполнении они должны быть исполнены так, будто были исполнены последовательно в **некотором** порядке
- **Durability** - *монументальность? (хз, как это лучше перевести)* - завершённая транзация не должна быть никак утеряна

В рамках ХОИ и параллелизма нас в первую очередь интересует **изоляция**, которая решает целый ряд проблем:
- Lost update - тут более-менее понятно
- Dirty read - возникает в случае, если одна транзакция прочитает данные, которые уже изменила другая, а позже эта другая транзация откатилась, из-за чего первая прочитала данные, которых вообще уже нет в природе
- Non-repeatbale read - первый раз долгая транзакция прочитала одно значение, потом быстрая транзакция изменила значение, а следом долгая получила новое значение при чтении, что сломало ожидаемый результат

Решить проблему изоляции предназначен транзакционная память, которая может реализовываться и аппаратно, и программно

Один из примеров - это MVCC (multi-version concurrency control) - создаём копии мастер-состояния для каждого потока, потом пытаемся провести слияния, падаем в случае неудачи. По сути, чуть более комплексные атомики

*Всё API для транзакций в clojure смотри в презентации*

Отличия `commute` от `alter` заключается в том, что commute регистрирует функцию и применяет её к копии master-state, а затем также и к самому master-state. Благодаря такому механизму для простых операций мы не будем получать lost update, однако есть ряд правил:
- Все операции над одним референсом должны быть с `commute`
- Все операции должны быть легковесными
- Транзакция не может полагаться на состояние референса, если используются `commute`

# 24.11.27 и 24.12.04 - Лекция
## XML
**Базовый элемент языка разметки XML** - тэги открывающий и закрывающий (*и ещё что-то*)

**Well-formed XML** - XML-документ, удовлетворяющий базовым требованиям:
- Комплиментарность
- Древовидность
- ...

**Valid XML** - более строгое состояние XML-документа, требующее дополнительной настройки

# 25.02.06 - Лекция
## Интенсивно работающее с данными приложение
Требования:
- Scalability - желательно, чтобы при росте данных сложность работы росла минимум линейно
- Reliability - нужно, чтобы мы работали быстро
- Maintainability - нужно, чтобы мы работали всегда

Есть некоторый порог времени, до которого мы считаем, что система работает нормально

Однако контролировать ситуацию с быстродействием всегда мы не можем, поэтому адекватной целью является быстродействие в определённом проценте запросов (процентиль 90, 95, 99 и т.п.)

Логично, что для собирания этих данных нужны определённые сервисы мониторинга и профилирования, прикрученные к приложению

"Развивайся либо сдоххни" - однако куда развиваться, далеко не всегда понятно. Есть шанс потратить ресурсы под такую абстракцию, которая не пригодится НИКОГДА, но так ли это будет реально, хрен бы ег знал (ну ладно, на самом деле способы есть. Вернее, не совсем способы, а так... методы: сбор разной статистики и т.п.)

"Набирающий популярность - это как недоразвитый, только политкорректно"

## Моделирование данных
### ER-diagrams
Определения:
- ER model - концептуальная модель данных, концентрирующаяся на сущностях и их связях
- Entity - вещь, обладающая способностью к объективному существоваванию и однозначно идентифицируемая каким-либо образом
- Realtionship - ассоциация сущностей
- Attribute - именованный фрагмент информации об объекте или их отношении

Из этих определений мы выделяем такие понятия как:
- Entity type - определяет классификацию сущностей по определённым предикатам
  - Типы сущностей не взаимоисключающие
- Value type - какие-то наборы значений
- Realtionship type - математическое отношение между сщностями определённых типов (*на самом деле, типы сущностей в первую очередь вводятся для того, чтобы возникли типы связей*)
- Role of an entity - функция, которую сущность играет в связи