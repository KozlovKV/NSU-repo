# Инфо
## Практика
В течение года будет 2 проекта. Тут мы рабы требований семинаристов, а защита будет как будто мы перед заказчиком

# 24.09.04 - Лекция
## Этапы разработки архитектуры
1. Анализ предметной области
2. Анализ требований
   - Речь именно о подробной спецификации требований
   - Начинает всё "веселье" с прошлого курса: разделение требований на функциональные и нефункциональные, а для функциональных далее расписываются юз-кейсы (*опять писать ебучий SRS...*)
3. Проектирование архитектуры
   - *Тут вообще было очень много букв, но я пошёл читать описания проектов*
4. *И дальше что-то ещё было, но сейчас не особо важное*

## Кое-какие архитектурные принципы
- Разделение ответственности - делить программу на максимально независимые компоненты
- DRY
- KISS (aka бритва Оккама)

# 24.09.11 - Лекция
## Ещё раз о принципах ООП
- Абстрагирование - выделение ключевого поведения реальной сущности для реализации в программной сущности (в случае ООП - для класса) (*"это надо прочуствовать"*)
- Инкапсуляция - разделение устройства объекта от его поведения (нас интересует, что объект делает, а не как)
- Модульность - ну... надо делить на модули код, делить по-умному
- Полиморфизм - разные объекты могут реализовывать один и тот же контракт либо даже расширить контракт, не нарушив его

## Use-case
**Use-case** - описание возможной последовательности действий между системой и актором, причём актор получит что-то в результате (предполагается, что что-то хорошее)

**Актор** - некоторая сущность, которая заинтересована

Таким образом, обязательно нужны:
- Цель, причём важно, чтобы цель была нужна актору, то есть "снять деньги в банкомате" - хороший юз-кейс, а вот "пройти идентификацию в банкомате" - это абстрактный юз-кейс, так как не имеет ценности для актора сам по себе
- Актор
- Система

Вспомним уровни моря:
- Стратегические ("белые") - дают пользу актору, но очень глобальны и не могут быть быстро решены системой по понятной последовательности действий
- Уровень моря ("голубой") - полезно актору и может быть тут же предоставлено системой по понятному алгоритму
- Технические ("синие") - не несут прямой пользы актору, но используются в других уже полезных юз-кейсах

# 24.09.18 - Лекция
## UML
Диаграммы должны повышать наглядность, а не нести в себе исчерпывающее описание, иначе получится нечто ужасное

## Анализ модели ПО
Приступаем после написания юз-кейсов:
1. Выделение отдельных модулей приложения - мы должны быть уверены, что эти модули обеспечивают реализацию юз-кейсов, надо описать функционал каждого модуля
   - На этом этапе важно учитывать лишь функциональные требования, можно даже не выбирать к этому моменту ещё язык программирования
2. Далее проводим выделение классов по boundary-control-entity pattern (aka MVC):
   1. entity - класс для хранения каких-то полезных данных
   2. control - отвечает за поведение системы (основную логику юз-кейса)
   3. boundary - отвечает за взаимодействие системы с акторами

# 24.09.25 - Лекция
Реализация юз-кейса:
- Выбираем юз-кейс (желательно самый сложный)
- Определяем его классы по BCE-pattern
- Прописываем, как инстансы этих классов будут участвовать в юз-кейсе
- Составляем sequence диаграмму
- Дополнительно можно создать (*ещё дохера диаграмм... Я хз, что тут хотел 2 недели назад написать*)

# 24.10.09 - Лекция
## Design model
Здесь мы уже описываем реализацию куда более подробно, переходя от аналитических классов и определяя особенности их реализации
- Активно применяем разделение ответственности и бритву Оккама

## Design by contract
**API - Application programming interface** - 

**Client** -

**Server** - оборачивает данные (программу) в форму API

**Contract** состоит из:
- Набора операций
- Типов параметров
- Возвращаемого типа
- Описания возможных ошибок
- Предусловия - обязанности клиента
- Постусловия - обязанности сервера
- Инварианта - комбинации всех условий
- Side-effects
- Дополнительные гарантии

### Ещё раз о принципе Лисков
Не буду повторять здесь его формулировку, а вот практический момент запишу: при наследовании классов мы не можем ужесточать предусловие и не можем ослаблять постусловие

# 24.10.30 - Лекция
Продолжаем какие-то паттерны изучать:
- Command Query Separation - мы должны чётко разделять:
  - Комманды - не возвращают значения из предметной области, а только совершает какой-то сайд-эффект, то есть это сеттеры
  - Запросы - возвращает значения из предметной области и не имеет сайд-эффектов (геттеры)

# 24.11.06 - Лекция
*Ещё раз про cohesion*

Если мы чётко можем сказать, чем занимается определённый модуль, мы имеет высокую cohesion, что хорошо.

Однако, чтобы количество модулей не стало монструозным, нам приходится опускаться на более низкие уровни

**Избегайте циклических зависимостей** - иначе во-первых, не понятно, с чего начинать работу, а во-вторых, будет сложно искать ошибки

**Закон Деметры** - придерживаться минимальных знаний ("общайтесь только с друзьями, не общайтесь с незнакомцами") - опять же, позволяет упростить поиск ошибки

Принцип разделения интерфейсов уже достаточно разбирали на ООП

Принцип инверсии зависимостей - реализации должны зависеть только от абстракций, Мигинский его ещё описал как принцип ёжика: тело ёжика интерфейсы, могут как угодно зависеть друг от друга; реализации - штуки на иглах ёжика, должны зависеть только от тела ёжика, а не друг от друга, что логично

Стабильность - мера того, сколько модулей завсят от текущего модуля. Чем больше входящих зависимостей, тем более стаблиьным считается модуль.

Необходимо соблюдать баланс между стабильностью и абстрактностью

## Паттерны проектирования
Основные типы паттернов:
- Структурные - решают проблемы связи модулей
- Поведенческие - решают проблемы взаимодействия модулей
- Порождающие - решают проблемы создания модулей и их жизненного цикла
- Конкурентные - решают проблемы параллельного взаимодействия
- *и ещё один тип, который не успел записать*

# 24.11.13 - Лекция
## некоторые паттерны
**Адаптер** - если у нас есть какой-то интерфейс и класс, который реализует похожую логику, но несколько отличающуюся либо его логика совсем другая, но нам надо, чтобы он подходил под этот интерфейс. В таком случае мы создаём адаптер-класс, который реализует требуемый интерфейс и используется в нашем целевом классе

**Прокси** - выделяем отдельные свойства объекта, не связанные с его главной сутью в отедльные промежуточные классы, которые могут наслаиваться друг на друга

## Проождающие паттерны
Существует целый ряд проблем, связанных с жизненным циклом объектов:
- Конструктор объекта не может быть полиморфным, так как в этот момент мы ТОЧНО должны знать тип объекта
- Масса нарушений единственности ответственности (пример - явная очистка памяти - явно не та ответственность, которую мы закладываем в какой-либо класс)
- Чрезмерное количество объектов либо недостаточное
- Использование до инициализации / после деинициализации

Решить эти проблемы пытаются через ряд паттернов

### RAII
**Resource acquisition is initialization - получение ресурса - это его инициализация**.

Применимо в первую очередь для файловых потоков

### Фабричный метод и фабрика
Тут пояснения считаю излишними

### Singleton
Паттерн создания глобального иммутабельного объекта в единственном экземпляре

### Builder
Паттерн для поэтапного построения сложных объектов.

Ключевое отличие от фабрики и фабричных методов в том, что здесь именно используется много методов класса-билдера для создания одного объекта (*впрочем, разумеется, можно комбинировать билдер с фабриками*)

Удобно во внутренних методах возвращать объект самого билдера, чтобы строить объекты цепочкой методов

### Dependency Injection Library framework
*Для начала определение фрэймворка (примитивное) - активный агент системы*

Суть инверсии зависимостей как паттерна заключается в создании какого-то объекта-бога, который будет выдавать различным объектам необходимые компоненты

# 24.11.20 - Лекция
## Iterator
Паттерн, позволяющий обходить сложные объекты

## Observer
Широко используется в вэбе, полезен для оповещения множества разных объектов об изменениях в других объектах

Вместо подробного объяснения прикреплю скрин диаграммы:
![](./lec/24-11-20%20-%20observer.bmp)

# 24.11.27 - Лекция
## Chain of responsibilities
Разные функции добавляются цепочку и могут быть исполнены в зависимости от исходных данных. Данные движутся по всей цепочке до конца либо до первого исполненного обработчика

## Facade
Ну... Скрываем детали реализации и даже отдельные объекты нашего API за объектом-фасадом

## Mixin
Примеси - паттерн (*довольно странный, имхо*), позволяющий нам собрать разный функционал в один объект, разнеся его реализацию по отдельным модулям и отнаследовавшись в главном объекте ото всех этих примесей

## Strategy и Template Method
Ну... Просто скажу функциональные интерфейсы или наследование от `Thread` в Java идеально описывает этот паттерн

## Парадигмы
**Парадигма** - совокупность из вычислительной модели и набора правил, определяющий стиль написания и структурирования компьютерных программ

Самые популярные парадигмы
Парадигма | Вычислительная модель | Вычислительный механизм | Разделение ответственности
:-: | :-: | :-: | :-: 
Императивная | Машина Тьюринга | Последовательное исполнение, манипуляции с памятью, прыжки по памяти | Нет
Структурная | Почти машина Тьюринг | Последовательное исполнение, манипуляции с памятью, прыжки по памяти (но уже не goto), вызовы процедур | Процедурное и по типам
Функциональная | $\lambda$-исчисления | Функциональные вызовы и рекурсия | Чистые функции и типы
Объектно-ориентированная | Машина Тьюринга (где-то очень глубоко) | Динамический полиморфизм | Классы и полиморфизм

# 24.04.12 - Лекция
## Макроинструкции
Интерпретируемый язык и интерпретатор - *по факту - вообще почти всё что угодно*, потому что требуется лишь исполнение программного кода, возможно, прекомпилируемого

Разберём 3 режима работы clojure:
- Компилируемый - мы отправляем код в коимпилятор, который начинает его **иНтЕрПрЕтИрОвАтЬ**, разделяя инструкции на компилируемые и исполняемые. 
  - Все компилируемые выражения переводятся в байт-код
  - Все исполняемые инструкции будут скомпилированы и тут же исполнены
- Интерпретируемый - всё в плане компиляции произойдёт также, но в конце добавится инструкция для вызова main-функции

## Макрос в clojure
Макрос - строго инструкция компиляции, на место которой на этапе компиляции будет подставлен код этого макроса

# 25.02.05 - Лекция
## Изучим полиморфизм на более крутом уровне
**Полиморфизм** - способность классов реализовывать один и тот же контракт

Базовые типы полиморфизма:
- Ad-hoc - выражается в первую очередь в перегрузке функций (по факту не связано с ООП даже)
- Параметрический - generic'и
- Subtype (dynamic) - тот самый, самый натуральный полиморфизм за счёт общего суперкласса

Расширения динамического полиморфизма:
- Множественное наследование
- Множественная диспетчеризация
- Вспомогательные методы

### Множественное наследование
*Тут был разобран пример на лиспе и... Я хз, чё тут именно об этом написать, но в общем, преза SD_lec10, стр. 6-12 (самое инетересное будто бы на стр. 12)*

### Множественная диспетчеризация
Здесь рассказывают про паттерт bridge, который позволяет

### Вспомогательные методы
Достаточно прикольный механизм, позволяющий разделять бизнес-логику и какие-то дополнительные действия / проверки

## Декларативное метапрограммирование
Достаточно абстрактное понятие, которое включает в себя много всего. Самый яркий пример - автогенерация кода. Для этого могут использоваться, например, декораторы и аннотации

Реализовывать такую дополнительную логику позволяют множество разных механизмов, изученных ранее:
- Паттерн Прокси - можно почти в любом ЯПе, но очень типоспецифично
- Вспомогательные методы полиморфизма - есть не во многих ЯПах и методоспецифично
- Макросы - есть не во многих ЯПах и причиняет боль (прогрерам)

Об остальных механизмах речь пойдёт далее

*"Плюсы - херня лютая во всём, что сложнее базы" - не то чтобы это прям цитата, но проходит эта мысль красной нитью через весь семестр Мигинского*

### Reflection
**Introspection** - возможность изучить свои элементы и использовать их

**Reflection** - introspection + возможность менять свои элементы

Java Reflection API - это скорее интроспеция, потому что самоизменения там очень слабые

### Дианмические языки
Имеют куда более пространство для генерации кода

*А дальше лютые примеры на кложуре*