- [Инфо](#инфо)
  - [Лабы](#лабы)
    - [Общие задачи](#общие-задачи)
    - [Задачи на разработку](#задачи-на-разработку)
- [24.02.12 - семинар](#240212---семинар)
- [24.02.14 - лекция](#240214---лекция)
  - [Подробнее про уровни OSI](#подробнее-про-уровни-osi)
    - [Физический уровень](#физический-уровень)
    - [Уровень физической адресации](#уровень-физической-адресации)
- [24.02.22 - лекция](#240222---лекция)
    - [Уровень сетевой адресации](#уровень-сетевой-адресации)
- [24.02.26 - семинар](#240226---семинар)
- [24.02.28 - лекция](#240228---лекция)
  - [Практика по OSI-2-3](#практика-по-osi-2-3)
- [24.03.06 - лекция](#240306---лекция)
  - [ICMP](#icmp)
- [24.03.11 - семинар](#240311---семинар)
  - [Маршрутизация](#маршрутизация)
    - [NAT](#nat)
  - [Свой роутер](#свой-роутер)
- [24.03.13](#240313)
  - [OSI-4 - транспортный уровень](#osi-4---транспортный-уровень)
    - [Порты](#порты)
    - [TCP](#tcp)
    - [UDP](#udp)
- [24.03.18 - семинар](#240318---семинар)
  - [Снова про `iptables` и маршрутизацию](#снова-про-iptables-и-маршрутизацию)
    - [`iptables-persistent`](#iptables-persistent)
- [24.03.20 - лекция](#240320---лекция)
  - [`nc` - netcat](#nc---netcat)
  - [`netstat`](#netstat)
  - [TCP - продолжение](#tcp---продолжение)
  - [SSH](#ssh)
- [24.03.25 - семинар](#240325---семинар)
  - [Удалённое управление](#удалённое-управление)
    - [SSH](#ssh-1)
    - [BMC (IPMI)](#bmc-ipmi)
    - [Deep-dive into SSH](#deep-dive-into-ssh)
      - [Отдельные команды](#отдельные-команды)
      - [Графические проги (!!!)](#графические-проги-)
      - [SOCKS-proxy](#socks-proxy)
      - [Проброс портов](#проброс-портов)
        - [А теперь время испугаться по настоящему](#а-теперь-время-испугаться-по-настоящему)
      - [Проброс аутентификации](#проброс-аутентификации)
    - [SSHfs](#sshfs)
- [24.03.27 - лекция](#240327---лекция)
  - [NAT](#nat-1)
- [24.04.03 - лекция](#240403---лекция)
  - [DHCP](#dhcp)
- [24.04.08 - семинар](#240408---семинар)
  - [DNS](#dns)
    - [Настройка своего DNS](#настройка-своего-dns)
    - [`nsloolup`](#nsloolup)
      - [`bind9`](#bind9)
- [24.04.10 - лекция](#240410---лекция)
  - [DNS](#dns-1)
- [24.04.15,22 - семинар](#24041522---семинар)
  - [Хостинг](#хостинг)
    - [Apache](#apache)
- [24.04.17 - лекция](#240417---лекция)
  - [Ещё раз практика по DNS](#ещё-раз-практика-по-dns)


# Инфо
Лектор - Гаранин Александр

Семинарист - Валерий Владимирович Павлов - +79139389393

[Наталья и Виктор Олифер, "Компьютерные сети"](https://moodle.iae.nsk.su/int_networks_23/ol6.pdf)

## Лабы
### Общие задачи
1. Перехват и анализ данных при помощи программы Wireshark Перехватить и объяснить принцип работы протоколов arp (генерируем любым другим запросом, например ping), icmp (ping, traceroute), tcp (например скачивание файла по https), udp (ping доменного имени приведет к dns запросу по udp). Объяснить принцип работы traceroute утилиты.

2. Настроить SSH-сервер и SSH port forwarding Установить openssh-server, с одного вируального ПК подключиться к другому по SSH. На одном виртуальном ПК запустить nc(netcat) сервер, далее подключиться к этому ПК по ssh и пробросить по ssh порт этого сервера, на другом виртуальном ПК продемонстрировать работу проброса порта (тоже с помощью nc, но уже клиента, а не сервера).

3. VPN сервер сделать Принцип работы OpenVPN. Создать VPN подключение между двумя линуксами или линуксом и windows. Объясить зачем нужен VPN вообще.

4. Настроить iptables Настройка виртуального ПК, как роутера интернета, с технологией NAT: настроить 2 интерфейса и собственный NAT на базе iptables на одном виртуальном ПК, один интерфейс ПК через NAT (реализован средствами VirtualBox) в подключен в реальный ПК, другой в виртуальный свитч, туда же включен сетевой интерфейс второго виртуального ПК, и второй ПК должен ходить в интернет через первый. В данной задаче допустимо не использовать DNS (ввиду того что до него пока не дошли по темам) а проверять наличие интернета и верную настройку "роутера" по доступности 8.8.8.8 например.

5. Настроить DNS-сервер Поставить bind9 и настроить самому полностью рабочий DNS сервер. Настроить на нем свою зону. Рассказать о назначении утилит nslookup и dig и продемонстрировать с их помощью работу сервера. Дополнительно, вернуться к задаче 4 и указать на втором виртуальном ПК DNS сервер, который находится на первом и проверить работу браузера - открываются ли сайты.

6. Настроить LAMP (или LEMP) Установить Apache (Nginx) PHP MySQL и поставить на это на все популярную CMS например joomla или wordpress, создать и показать сайт на одной из этих CMS (наполнение не важно, достаточно продемонстрировать работу главной страницы и административной панели). В данной задаче допустимо заменить Apache на Nginx.

### Задачи на разработку
7. Простой HTTP сервер Написать простой HTTP сервер поддерживающий метод GET. Получить страницу с файлами из папки, получить ответ в виде html и получить ответ в виде html из определенного заранее подготовленного файла.

8. Простой чат (клиент и сервер) Написать и запустить сервер чата, написать и запустить минимум 2 клиента. Продемонстрировать работу чата. Архитектура чата должна быть P2P (клиент-серверные решения не интересуют). Чат функционирует в пределах локальной сети. Каждый клиент отправляет сообщение либо конкретному пользователю (имя пользователя совпадает с именем машины), либо всем. Всеобщая рассылка должна вестись с помощью бродкаст-адресов.

# 24.02.12 - семинар
Сетевой мост - внешний DHCP сервер будет выделять нам отдельный IP-адрес (в частности, позволит нам с хоста подключаться к виртуальной машине)

NAT - хост будет восприниматься как маршрутизатор (*не уверен, что верно понял суть*)

Для установки дополнительного ПО:
- Подключаем диск от VB
- Запускаем терминал из-под суперпользователя
- Исполняем `.sh` скрипт, который лежит на диске

Серые IP-адреса (немаршрутизируемые) - адреса вида:
- `10.0.0.0/8` (маска `255.0.0.0`)
- `172.16.0.0/16` (маска `255.255.0.0`)
- `192.168.0.0/24` (маска `255.255.255.0`)

*Советует почитать статью про IPv4 на Википедии*

# 24.02.14 - лекция
[Ссылка на актуальную версию лекции](https://docs.google.com/document/d/1mhas-FCinx5firKdvqY3spbkAhwRe0jrDJZBjkPxn4Q/edit)

Модели TCP/IP и OSI - абстракции, которые описывают взаимодействие между машиной компьютерами по сети

TCP/IP устроена несколько проще

*Вместо десятка слов пусть будет картинка:*
![](./materials/osi-and-tcpip.jpg)

## Подробнее про уровни OSI

### Физический уровень
Работа со средой

Витая пара (например, UTP - unshielded twisted pair), могут отличаться по качеству меди. Самый стандартный - cat5e. На концах кабеля присоединяются разъёмы (например, 8p8c - 8 проводов, 8 контактов). Если кабель с двух сторон имеет такие (или похожие) разъёмы, то кабель будет называться **патчкордом**

Радиоэфир - самый популярны протокол Wi-Fi (также называется IEEE 802.11xx, где `xx` - одна или несколько букв)

Оптический кабель - дорогая штука для использования в домах, однако вот уже дома к общим узлам, а тем более передача данных на большие расстояния происходит уже через них

---

Полученные с этого уровня биты на более высоких уровнях интерпретируются в определённые символы, но до высшего уровня дойдут не все из них - на переходе на более высокий уровень будут читаться, а затем убираться заголовки, говорящие о том что делать с этими данными. То есть реализуется механизм **инкапсуляции**


### Уровень физической адресации
Основной протокол ethernet ([IEEE 802.3](https://moodle.iae.nsk.su/int_networks_23/IEEE-802.3-2012.pdf)). Здесь находятся MAC-адреса

![](./materials/24-02-14%20-%20ethernet.png)

В самом простом случае информация тут состоит из MAC-адреса адресата, отправителя и тип следующего уровня OSI

Главная функция - физическая адресация

# 24.02.22 - лекция
### Уровень сетевой адресации
Здесь находятся IP-адреса (IPv4, IPv6) - адреса, необходимые для маршрутизации

**Маска** - позволяет выделить пространство адресов из всего их множества (примеры масок смотри с семинара)

**"Серый" (локальный) IP** - опять же, ничего особо нового не узнал, кроме того, что сети серых адресов бывают вложенные (*ничего удивительного на самом деле, на середине лекции задумался об этом и понял, что иначе было бы адресов слииишком мало*)

Главная функция этого уровня - логическая адресация

# 24.02.26 - семинар
MAC-адреса не выходят за пределы локальной сети

DHCP-сервер - Dynamic host control protocol - ведёт учёт зарегистрированных в сети машин (то есть их локальные адреса)

# 24.02.28 - лекция
## Практика по OSI-2-3
`ip a` - показать доступные сетевые интерфейсы 

На одной сетевой карте можно установить МНОГО IP-адресов с разными (*а точно ли?*) масками подсети (*очевидно, хотя это и не говорилось, кроме настроек через комп для сетевой карты, нужны будут ещё какие-то действия*)
- На Винде заходим для этого в настройки интернет
- В Линуксе ищем конфиги интерфейсов в `/etc/network/interfaces` (*но ни на серваке, ни на WSL я такого не нашёл... А вот на Debian он есть*)
  - `ifup <interface_name>` - запустить интерфейс
  - `ifdown <interface_name>` - выключить интерфейс

В маршрутизаторе есть 2 сетевых интерфейса: один отвечает за связь локальных устройств с маршрутизатором (**LAN**, подписывается в настройках как default gateway), а другой - за связь маршрутизатора с глобальной сетью (**WAN**) (зачастую, с сетью провайдера)

Механизм работы всех маршрутизаторов заключается в том, что при обращении к внешним адресам, наш компьютер будет обращаться к LANу маршрутизатора, тот к LANу провайдера и так может быть много раз, но механизм, начиная с провайдера, сильно сложнее

Зачастую локальные IP-адреса, default gateway и все прочие параметры получаются устройствами в сети автоматически, благодаря DHCP-серверу

ARP - Address resolution protocol - позволяет по IP-адресу узнать MAC-адрес устройства. Для этого посылается запрос по всей локальной сети, в котором говорится, что источник хочет пообщаться с таким-то IP, владелец этого IP шлёт в ответ отправителю свой MAC.
- `arp` - посмотреть ARP-кэш
  - `ip neigh` - то же самое (`arp` у меня не работала ни на одной машине Линуксовой)
- `ip -s neigh flush all` - сброс ARP-кэша

Коммутатор работает только на уровне физической адресации. Позволяет общаться через свои порты разным устройствам, сопоставляя портам разные адреса. Устройство безумно примитивное - просто хранит таблицу, сопоставляющую порты и MAC-адреса

# 24.03.06 - лекция
*Ввиду неосмотрительности и беспечности сделал запись без звука, так что буду писать по большей части основываясь на документе*

Коммутатор обновляет таблицу при поступлении каждого нового фрейма. Если MAC-адрес получателя есть в таблице портов, то запрос направится на конкретный порт, если нет, то на все порты, кроме отправителя.

Широковещательные адреса воспринимаются всеми устройствами как собственные:
- MAC-адрес - `FF.FF.FF.FF.FF.FF`
- Широковещательный адрес IPv4 образуется как побитовое ИЛИ адреса локальной подсети и инверсии маски этой подсети

---

У протокола IPv4 есть поле TTL - Time to Live - которое определяет степень живучести пакета:
- Выставляется системой или приложением в пределах от 1 до 255
- При прохождении одного маршрутизатора уменьшается на единицу
- При достижении нуля, пакет будет отброшен
- Позволяет избежать зацикливания пакетов, а также даёт возможность наблюдать за путём пакета по сети (`tracert` на Винде и `traceroute` на Линуксе)

## ICMP
ICMP - Internet Control Message Protocol - также располагается на третьем уровне OSI и используется для передачи некоторых серверных сообщений. Содержит тип, код и контрольную сумму.

Типы:
- `0` - echo reply - код `0`
- `8` - echo request - код `0`
- `3` - получатель недоступен (destination unreachable message). Популярные коды:
  - `0` - net unreachable
  - `1` - host unreachable
  - `2` - protocol unreachable
  - `3` - port unreachable

# 24.03.11 - семинар
## Маршрутизация
У каждого компьютера может быть один или несколько сетевых интерфейсов, каждому интерфейсу может быть назначено от нуля до множества IP адресов. При этом каждый адрес должен быть уникальным

На самом деле у маршрутизатора может быть больше двух интерфейсов, причём как много LANов, так и много WANов - выбор нужного интерфейса будет определяться таблицей маршрутизации

Прокси-сервер - принимает пакеты и перенаправляет их далее от своего имени

### NAT
NAT - network address translation - необходим для корректной передачи пакетов из локальных серых подсетей. sNAT - замена источника, dNAT - замена назначения, pNAT - замена порта. Заменой адресов по протоколу NAT занимается [**фаерволл**](#снова-про-iptables-и-маршрутизацию) на роутере.

Суть работы достаточно проста:
- Маршрутизатор получил запрос от устройства в локальной сети
- Заменил адрес назначения на свой собственный адрес (WAN)
- Оставил пометку о том, куда он отправил пакет от локальной машины
- Получив ответ, перенаправляет его внутреннему узлу

Проблемой становится то, что достаточно сложно устанавливать связь между пакетами, поэтому для каждого пересланного пакета заключается контракт со своей особой протокол-специфичной структурой.

## Свой роутер
Зная это, мы можем настроить собственную машину как роутер (Linux Debian):

1. Настроить адреса в локальной сети (в частности, назначить наш комп как default gateway)
   1. На внутренней машине сети один интерфейс со статическим адресом:
```sh
auto <interfaceName>  # auto указывает, что интерфейс должен конфигурироваться автоматически при запуске системы
iface <interfaceName> inet static  # хз, что значит inet, Но static используется, если мы задаём адрес вручную
  address <hostIP>/<mask>
  network 255.255.255.0  # Альтернативный вариант указания маски (тогда можно опустить /<mask> у прошлого параметра) 
  gateway <gatewayAddress> # Адрес машины из следующего пункта
```
   2. На машине-роутере 2 интерфейса:
```sh
# Внешний интерфейс
auto <interfaceName1>
iface <interfaceName1> inet dhcp

# Внутренний интерфейс
auto <interfaceName2>
iface <interfaceName2> inet static
  address <gatewayAddress>/<mask>
```
2. Установить `iptables`
3. Внести в NAT-таблицу запись для sNAT (*[подробнее о сути работы `iptables`](#снова-про-iptables-и-маршрутизацию)*)
   1. В рамках одной сессии: `iptables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADE`
4. Включить IP forwarding (пересылать запросы с одного интерфейса на другой)
   1. В рамках одной сессии: `echo 1 > /proc/sys/net/ipv4/ip_forward`
   2. На постоянную основу: раскоментировать в файле `/etc/sysctl.conf` строчку `net.ipv4.ip_forward=1`

# 24.03.13
## OSI-4 - транспортный уровень
Этот уровень отвечает за надёжную доставку данных, которые здесь передаются в виде сегментов, содержимое которых определяется протоколом. Самые популярные из них - TCP и UDP.

### Порты
Адресация в обоих протоколах осуществляется за счёт портов, при этом порты для каждого протокола **СВОИ**

Порт - 16-битное число.
- `0` - служебный порт
- `1`-`65535`
  - `1`-`32767` - статические порты. Среди них берутся порты для сервисов, к которым обращаются извне (выступают в качестве `destination`)
  - `32768`-`65535` - динамически выделяемые. Они обычно используются для обратного общения сервера с клиентом и выделяются для сессий

По общему соглашению некоторые порты среди статических используются в первую очередь для определённых протоколов более высоких уровней. Вот некоторые примеры:
- `21` - ftp
- `22` - ssh
- `23` - telnet (устаревшее управление терминалом)
- `80` - http
- `443` - https
- `25` `110` `143` `465` `993` - почтовые протоколы

Таким образом, соединение в рамках сети и компьютера может быть однозначно определено парой адрес, порт, которая будет называться **сокетом**. Соответственно, у нас есть **UDP-сокеты**, **TCP-сокеты** и т.д.

### TCP
TCP - Transmission control protocol - отвечает за надёжную (почти что гарантированную доставку)

Составляющие хэрэра:
- `src`/`dst` порты по 16 бит
- `sequence number` (`seq`) - номер байта в общем потоке данных
- `acknowledgment number` (`ack`) - количество полученных байт
- Флаги
  - `SYN`
  - `ACK`
  - `PSH`
  - `FIN`

Открытие TCP-соединения **троекратным рукопожатием**:
- Отправляется TCP-пакет с флагом `SYN` и случайным `seq` (`client_init_seq`)
- Сервер отвечает TCP-пакетом с флагами `SYN` и `ACK` и своим собственным случайным `seq` (`server_init_seq`) и `ack` = `client_init_seq + 1`, подтверждая тем самым, что получил `seq` клиента
- Клиент должен также сделать ответ с флагом `ACK`, `seq` = `client_init_seq + 1` и `ack` = `server_init_seq + 1`
- Теперь оба на обоих сторонах приложения могут контролировать и синхронизировать количество переданных данных при помощи синхронизованных `seq` и `ack`

### UDP
Не требует никакого рукопожатия, а сразу отправляет пакет

# 24.03.18 - семинар
## Снова про `iptables` и маршрутизацию
`iptables` - или же **фаерволл** - почти что неотъемлемая часть ОС, которая отвечает в первую очередь за перенаправление адресов. Может работать по двум принципам:
- Чёрного списка - разрешено всё, что не запрещено
- Белого списка - запрещено всё, что не разрешено

Таблицы в этом модуле состоят из цепочек. Суть цепочки в том, что мы идём от её начала к концу до тех пор, пока не найдём правило, которое можно будет применить. Когда такое правило найдено, поиск дальше не ведётся, из чего следует, что порядок цепочек может быть критически важен. При отсутствии подходящего правила в цепочке будет применено правило по умолчанию

Таблица `filter` содержит следующие цепочки:
- `INPUT` - содержит правила для входных соединение. Вид правил следующий
  - Общий вид команды: `-A INPUT -s <source_ip> -p <TCP/UDP/OTHER_PORT> --d-port:<port_number> -j <ACTION>`
  - Пример `-a INPUT -s 192.168.0.179 -p TCP --d-port:22 -j DROP` запретит входящее ssh соединение от машины `192.168.0.179`
  - По умолчанию содержит просто правило `ACCEPT`
- `OUTPUT` - исходящие запросы, порождённые на эту машину. По умолчанию `ACCEPT`
- `FORWARD` - для пересылок с одного интерфейса на другой интерфейс. По умолчанию `ACCEPT`

Цепочки таблицы `mangle` отвечают за обновление TTL (по умолчанию он 64)

Цепочки таблицы `nat` ([инфа про сам NAT](#nat)):
- `INPUT` и `OUTPUT` нам не очень интересны
- `PREROUTING`
  - Проходится перед `filter.FORWARD`
- `POSTROUTING` 
  - Проходится после `filter.FORWARD`
  - Сюда должно вноситься правило для `sNAT`: `MASQUERADE` либо `SNAT --to-sourcer<WAN_Address>`

Описание флагов для `iptables`:
- `-t <table>` - выбрать для работы таблицу `table`
- `-A <CHAIN>` - добавить правило в цепочку `CHAIN`
- `-D <CHAIN>` - удалить правило из цепочки `CHAIN`
- `-o <output_interface>`
- `-i <input_interface>`
- `-s <source_ip>`
- `-p <protocol>` - специфицировать протокол OSI-4 (`tcp`, `udp` и другие, а также `all`; можно перед протоколом поставить `!`)
  - Если мы задали протокол, то можем прописать `--dport <port>` или `--sport <port>`
- `-j RULE` - добавить правило `RULE`
  - Стандартные правила:
    - `ACCEPT`
    - `DROP` - просто отбросить пакет
    - `REJECT` - отклонить пакет и прислать об этом ответ отправителю
    - `RETURN` - прекратить обход текущей цепочки

Примеры команд:
- `iptables -t filter -A INPUT -i enp0s3 -j REJECT` - запретит входящие подключения через интерфейс `enp0s3` (**НЕ ПРИМЕНЯТЬ ПРИ SSH СОЕДИНЕНИИ**)
- `iptables -t filter -A OUTPUT -o enp0s3 -j REJECT` - запретит отправлять данные наружу через интерфейс (**ВПОЛОВИНУ ТАКЖЕ ОПАСНО ПРИМЕНЯТЬ ПО SSH**)
  - Цепочка `OUTPUT` в таблице `filter` **НЕ ВЛИЯЕТ** на цепочку `FORWARD`, то есть мы можем замутить схему, в которой роутер будет пересылать запросы от хостов в своих подсетях, но не сможет сам обращаться ко внешней сети
  - `iptables -t filter -A OUTPUT -p tcp --sport 22 -j ACCEPT` - если это правило установить перед тем, что выше, будет безопасно при использовании SSH

### `iptables-persistent`
При перезагрузке правила, назначенные командами выше, сбрасываются. Для сохранения используется программа `iptables-persistent`

При установке спросит, сохранить ли текущие правила `iptables`. Они будут сохранены в файлы `rules.v4` и `rules.v6` в `/etc/iptables/`, откуда они будут загружаться по умолчанию при запуске системы.

Также будет доступен ряд утилит (почти у всех есть альтернативные версии с первой половиной `ip6tables`):
- `iptables-save` - выводит в stdout все правила (*следовательно, мы можем их просто перенаправить в файлы*)
- `iptables-restore` - восстанавливает таблицы на основании данных из stdin (формат тот же, что и у вывода `iptables-save`)
- `iptables-apply` - безопасная установка правил. В случае ситуации, когда установка правила приведёт к разрыву соединения, откатит этот изменение
  - `-w <path/to/succesful/script>` - по этому пути будет сохранён скрипт в случае, если установка правил прошла успешно
    - Путь по умолчанию - `/etc/network/iptables.up.rules`
  - В качестве источника данных может выступать файл либо команда после флага `-c`
    - Так, если команду для блокировки входящих сигналов выше использовать с этой утилитой: 
      - `echo 'iptables -t filter -A INPUT -i enp0s3 -j REJECT' > cmd.sh`
      - `chmod a+x cmd.sh`
      - `iptables-apply -c cmd.sh`
      - Утилита спросит, можете ли вы сейчас подключиться. В случае проблем с добавленными правилами, мы просто не сможем отправить символ `y`, поэтому через несколько секунд будет принят ответ по умолчанию `N`, который сбросить внесённые изменения
    - *Фан-факт:* если в `cmd.sh` будет команда `iptables -t filter -A OUTPUT -o enp0s3 -j REJECT`, то при нормальной реакции пользователя всё сработает хорошо: сервер не сможет отправить пользователю по `ssh` вывод => пользователь ничего не нажмёт => изменения сбросятся, однако технически нам ничто не мешает отправить `y` с клиента на сервер, после чего изменения сохранятся в таком полуадекватном виде

# 24.03.20 - лекция
## `nc` - netcat
*Про него ничего интересного или нового для меня не было*

## `netstat`
Полезная утилита для просмотра открытых сокеты

Мы из неё использовали только вариант запуска `netstat -pln`
 
## TCP - продолжение
При получении пакета отправитель посылает пакет с флагами `ACK` и `PSH` (и всё также поддерживается синхронизация сдвигов `seq` и `ack`). Получатель в ответ посылает пакет нулевой длины с обновлённым `ack`, чтобы подтвердить, что все данные были получены

Осуществляется методом, очень похожим на тот, что используется при установлении соединения:
- Инициатор разрыва посылает пакет с флагами `ACK` и `FIN`, показывая тем самым, что он закончил отправку данных
- Другая сторона досылает все пакеты с данными, которые ещё не успела отправить (**инициатор разрыва должен их корректно принять**)
- Отправив все данные, другая сторона также посылает пакет с флагми `FIN` и `ACK`, подтверждая, что также готова прервать соединение
- Инициатор разрыва отправляет финальный пакет с флагом `ACK`, подтверждая, что он принял ответную готовность разрыва

## SSH
*Ничего интересного там не было*

# 24.03.25 - семинар
## Удалённое управление
Первым протоколом для удалённого управления через терминал был `telnet`, но по нему данные передавались в открытом виде.

После появления асинхронных RSA-ключей шифрования стал использоваться безопасный протокол шифрованного управления через удалённый терминал - `ssh`

### SSH
Про самую основу асимметричного шифрования писать не буду, отмечу, что работает немного не так, как я предполагал:
- При установке соединения, клиент и сервер обмениваются своими публичными ключами
- Клиент шифрует случайную фразу публичным ключом сервера и отправляет ему
- Сервер дешифрует

### BMC (IPMI)
Так называется модуль или даже компьютер, который следит за состоянием нашего сервера и позволяет нам в критических ситуациях восстановить соединение с самим сервером, если вдруг возникли проблемы

### Deep-dive into SSH
*"SSH открывает путь к таким способностям, которые кое-кто считает неестественными... неестественными"*

Источники: 
- MAN
- [Много-много фишек SSH](https://habr.com/ru/articles/122445/)
- [Чисто про туннели](https://habr.com/ru/companies/flant/articles/691388/)

Здесь и далее подстановка `<host>` будет означать указание пользователя, адреса и порта (при необходимости), то есть полный набор данных для доступа к серверу. Если вдруг где-то вместо `<host>` идут эти элементы по отдельности, значит использовать там конфиги из `~/.ssh/config` нельзя (*либо я ленивый и это не проверил*)
- `man ssh_config` - подробнее про поля конфига

#### Отдельные команды
`ssh <host> <cmd> [<cmd_arg>,...]` - команда с аргументами будет исполнена на хосте, затем управление вернётся на локальную машину. 
- Полезно, когда мы хотим получить данные для какой-то конкретной проги, работающей локально (*есть и более изощрённые штуки с перенаправлением stdin/stdout, но если заходить чуть дальше простых примеров, то они выглядят так, будто нужны лишь выебнуться перед всем миром*)
- `-t` перед командой создаст для её исполнения управляющий терминал

#### Графические проги (!!!)
`ssh -XYC <host>` - позволяет нам подключиться по SSH с пробросом X-сервера для графического вывода
- `-X` - собственно, проброс X-сервера
  - Конфиг-опция `ForwardX11 yes`
- `-Y` - авторизация
  - Конфиг-опция `ForwardX11Trusted yes`
  - *Честно, хз, что это значит. Надо подробнее изучать X11-server. в мане и вовсе пишут, что для дэбиана эта опция эквивалентна `-X`*
- `-C` - дополнительное сжатие для уменьшения задержки
  - Конфиг-опция `Compression yes`

И чудо! Теперь мы можем запускать графические проги на сервере, отображая их окошки на локалке (*при условии, конечно, что у нас, конечно, есть X-server, то есть на Винде это работать из-под капота не будет*)

#### SOCKS-proxy
`ssh -D [<address>:]<port> <host>` - установить соединение с `<host>` и сделает его прокси сервером, к которому мы сможем обращаться через порт `<port>`
- Если не указывать `<address>`, то будет установлен `127.0.0.1`, то есть для работы через прокси мы должны будем обращаться к самому себе (другие адреса имеет смысл указывать, если мы хотим работать с прокси только через определённый интерфейс)
- Конфиг-опция - `DynamicForward [<address>:]<port>`

*Через FireFox смог удостовериться в том, что проксирование работает, но*:
- *Некоторые сайты (вроде бы все HTTPS, а значит - пол-интернета) не работают*
- *Через настройки винды прокси не работает*

#### Проброс портов
`ssh -L [<localAddress>:]<localPort>:<remoteAddress>:<remotePort> <host>` позволит получать нам доступ к адресу `<remoteAddress>:<remotePort>`, доступному с машины `<host>` через локальный адрес `[<localAddress>:]<localPort>`
- Если не указывать `<localAddress>`, то он будет взять за `localhost`, если же мы укажем другой адрес, то сможем специфицировать интерфейсы, по которым можно будет обратиться к проброшенному порту (*в том числе кто-то сможет извне обратиться к этому порту, так что будь осторожен*). Опция `*` разрешит обращение по любому интерфейсу
- Для проброса локальных портов ниже 1024-го необходимо `sudo`
- Конфиг-опция - `LocalForward [<localAddress>:]<localPort> <remoteAddress>:<remotePort>`
- *Пример 1:* `ssh -L 25:192.168.15.10:22 debian` - позволит нам с нашей локальной машины через порт 25 параллельно получать доступ к 22-му порту машины по адресу `192.168.15.10`, доступной на машине `debian`
- *Пример 2:* 3 виртуалки, лишь одна из которых доступна в основной локальной сети через проброс портов. Обращаясь через неё, получаем доступ на других портах основной локальной машины к машинам, находящимся в виртуальной локальной сети:
```sh
ssh -fnNT -L 2025:192.168.15.10:22 debian
ssh -fnNT -L 2026:192.168.20.10:22 debian
```
  - Описание дополнительных флагов из примера:
    - `-f` - запустить соединение в фоне
    - `-n` - не читать `stdin` (если быть более точным, то `stdin` будет читаться из `/dev/null`)
    - `-N` - не исполнять удалённые команды
    - `-T` - не создавать псевдо-терминал

`ssh -R [<hostAddress>:]<hostPort>:<localAddress>:<localPort> <host>` позволяет получать доступ к `<localAddress>:<localPort>`, обращаясь к `[<hostAddress>:]<hostPort>` машины `<host>`
- Если указать `<inputAddress>`, то доступ будет открыт только при обращении извне от этого адреса (*по крайней мере, так везде пишут, на практике разницы на своих машинах не заметил*)
- Для работы этой команды необходимо на сервере в `/etc/ssh/sshd_config` разрешить проброс портов в шлюзовом режиме, добавив `GatewayPorts yes`
- Конфиг-опция - `RemoteForward [<hostAddress>:]<hostPort> <localAddress>:<localPort>`
- *Самый частый пример использования* - прокинуть доступ к локальному порту с каким-то сервисом через доступный из сети сервер. Выглядеть это будет примерно так: `ssh -fnNT -R <serverPort>:127.0.0.1:<localServicePort> <serverHost>`

##### А теперь время испугаться по настоящему
*Маленькая страшилка:* пробросом локальных портов можно открыть себе доступ к компу через несколько сетей:
```sh
ssh -t -L 2000:localhost:2000 debian ssh -t -L 2000:localhost:2000 kiri
ll@192.168.15.10 ssh -L 2000:localhost:22 kirill@192.168.20.10
```
Теперь мы через `localhost` на порту `2000` можем обратиться к `192.168.20.10` порту `22`, используя двойной туннель

**Большая страшилка:** используя SOCKS-прокси и проброс удалённых портов мы можем дать возможность выходить в сеть машине, которой такую возможность никто давать не планировал:
```sh
ssh -D 8080 -R 127.1:8080:127.1:8080 user@8.8.8.8 ssh -R 127.1:8080:127.1:8080 user@10.1.1.2
```
Теперь мышина `10.1.1.2` (локальная сеть) через свой порт `8080` будет обращаться к `8.8.8.8:8080` (сервер), который будет перенаправлять запрос на машину, с которой мы писали команду, где запрос будет проксироваться и отправлять в сеть (*настолько страшно, что проверять этот метод я, пожалуй, не буду*)

#### Проброс аутентификации
В первом страшном примере, если на машине `192.168.20.10` нет публичного ключа `192.168.15.10`, нас попросят ввести пароль даже при условии, но если там есть публичный ключ с нашей локальной машины, можем провести проброс авторизации ключом `-A`: *а как он работает, я толком не разобрался по статье, полез в man - там сказали, что это небезопасно и рекомендовали другой способ, о котором будет ниже*

`ssh -J [<user1>@]<proxyHost1>[:<proxyPort1>][, [<user2>@]<proxyHost2>[:<proxyPort2>], ...] <host>` - подключиться к хосту через цепочку серверов
- Конфиг-опция - `ProxyJump [<user1>@]<proxyHost1>[:<proxyPort1>], <user2>@]<proxyHost2>[:<proxyPort2>], ...]`

Есть ещё вариант с превращением `ssh` в трубу через опцию `-W` и использование конфиг-опции `ProxyCommand`, но он мне показался перегруженным, хотя, теоретически, будет давать большую безопасность (точно безопаснее проброса авторизации и, возможно, безопаснее прокси-хостов)

---

Завершая эту "главу", дополню цитату Палыча заявлением, что практически все флаги и дополнительные фишки, описанные тут, можно объединить вместе. Как с этим дальше жить - ваше дело

### SSHfs
Позволяет нам монтировать папку с удалённой машины прямо на нашу машину в виде псевдо ФС

`sudo apt install sshfs -y` - установит саму sshfs и fuse, который та использует для монтирования этой псевдо-ФС

- `sshfs <user>@<host>:/path/on/server /local/path` - подключить псевдо-ФС
 - **конечная папка в локальному пути должна существовать**
 - Дополнительные опции указываются после флага `-o`:
   - `-o reconnect` - пытаться переподключиться при возникновении ошибок
   - `-o idmap=user` - считать все изменения в ФС изменениями пользователя `user`
- `fusermount -u /local/path` - отмонтировать ФС в нормальной ситуации
  - Если вместо `-u` написать `-z`, то ФС будет отмонтирована лениво
- `sudo unmount -f /local/path` - отмонтировать ФС при сбое (в частности, при разрыве соединения)

# 24.03.27 - лекция
## NAT
**SNAT** (**НЕ ПУТАТЬ С sNAT**) - static NAT - каждому внутреннему IP маршрутизатора сопоставлялся его внешний IP, то есть в NAT-таблице постоянное количество записей

**DNAT** (**НЕ ПУТАТЬ С dNAT**) - dynamic NAT - когда мы отправили пакет с внутреннего IP, в NAT-таблице маршрутизатора он будет сопоставлен внешнему IP. До тех пор, пока маршрутизатор не получит ответ и не отправит его внутреннему IP отправителю, никакой другой внутренний IP не сможет воспользоваться этим внешним IP

**PAT** (**НЕ ПУТАТЬ С pNAT**) - port address translation - теперь в NAT-таблице маршрутизатора производится сопоставление пару из внутреннего IP и порта порту внешнего IP. Именно эта технология используется в современных роутерах и позволяет принимать пакеты сразу от многих локальных машин, отправлять их по разным адресам наружу и однозначно определять, кому надо отправить полученный из внешней сети ответ

# 24.04.03 - лекция
## DHCP
DHCP-сервер отвечает за выдачу устройствам определённых параметров для работы в сети. В первую очередь, это информация об адресе, гэйтвее, маске подсети. Также задержит информацию о времени, на которое эти данные выдаются (lease time)

На линуксе будет включён для интерфейса командой `iface <interface> inet dhcp`

Включая и выключая интерфейс командами `ifup`/`ifdown`, можно будет пронаблюдать команды, отправляемые на DHCP-сервер (**Общение здесь и далее везде происходит на уровне Ethernet протокола, поэтому указываемые IP-адреса не имеют по сути никакого значения (не считая одного места, о котором сами поймёте)**):
- DHCP Discover - посылает запрос на получение настроек
  - Посылается запрос MAC-бродкастом, сурсом указывается мак клиента
  - DHCP-пакет из полезной информации содержит лишь флаг, что это тип запроса `discover`
- DHCP offer - ответ от DHCP-сервера по MAC-адресу нашего клиента. 
  - Здесь уже в DHCP-пакете будут содержаться предлагаемые нам настройки для работы в сети и флаг типа `offer`
- DHCP request - предназначен для того, чтобы клиент мог выбрать предложенные настройки (а предложений может быть несколько). 
  - Запрос будет снова посылаться MAC-бродкастом
  - DHCP-пакет будет содержать настройки, которые хотел бы получить клиент, и флаг типа `request`
  - Идентификация нужного DHCP-сервера будет происходить по полю с его IP-адресом также внутри DHCP-пакета. Это позволит нам как бы и адресоваться к выбранному нами DHCP-серверу, и в то же время сообщить всем остальным, что их офферы нас более не интересуют
- DHCP acknowledge - ответ от DHCP-сервера с подтверждением того, что запрошенные данные доступны клиенту
  - Содержит также все выданные данные DHCP-пакета и флаг типа `ack`
- DCHP realease - говорит DCHP-серверу, что клиенту больше не нужны эти данные
  - Посылается, например, при отключении сетевого интерфейса

После истечения половины lease time, клиент начинает посылать DHCP request в попытках обновить срок аренды

# 24.04.08 - семинар
## DNS
*В древние времена для сайтов печатали свой аналог телефонных книг*

**DNS (domain name system)** - технология, позволяющая обращаться к машинам по сети, используя имена на человеческом языке - **доменные имена**

Доменные имена делятся на 3 уровня:
- Верхний (первый) уровень - определяет какую-то логическую принадлежность домена к региону или организации (`.ru`, `.uk`, `.gov`, `.com`, `.me`)
- Второй уровень - арендуемое имя - за комбинацию имени первого и второго уровня надо платить
- Третий уровень - поставив на свою локальную сеть DNS-сервер, сможем назначить их сколько угодно

Реверс-DNS-сервер позволяет нам на основании адреса узнать доменное имя

### Настройка своего DNS
`/etc/resolv.conf` - содержит DNS-сервера, которые могут быть использованы системой

### `nsloolup`
Полезная тулза для работы с доменными именами

`nslookup <name> [<DNSserver> -type=<TYPE>]`
- `name` - имя, для которого мы хотим узнать адрес
- `DNSserver` - к какому DNS-серверу мы хотим обратиться
- `-type=<TYPE>` - указать тип записи. Подробнее о них смотри ниже

`nslookup <IP>` позволит узнать доменное имя этого адреса

#### `bind9`
Это одна из самых популярных утилит для настройки DNS-серверов

`sudo apt install bind9 bind9utils bind9-doc dnsutils -y`

Файлы `bind9` будут располагаться в папке `/etc/bind`

В файл `named.conf` добавим отдельный файл с нашими зонами:
```
include "/etc/bind/my-zones.conf";
```

В файле `my-zones.conf` делаем записи следующего вида
```
zone "kirill.local" {
        type master; # Если мы владельцы этой зоны. Иначе надо указывать slave
        file "/etc/bind/db.kirill.local" # Путь до файла с базой данных доменных имён
};

# Далее идёт зона для реверс-сервера. Перед .in-addr.arpa пишутся октеты IP-адреса маски в обратном порядке (примеры таких записей можно посмотреть в named.conf.default-zones)
zone "168.192.in-addr.arpa" {
        type master; 
        file "/etc/bind/db.168.192";
};
```

Содержимое файла доменных имён:
```
;
; BIND data file for kirill.local loopback interface
;
$TTL    604800
@       IN      SOA     kirill.local. root.kirill.local. (
                        2024042001      ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
;
@       IN      NS      ns.kirill.local.
@       IN      NS      ns2.afraid.org.
@       IN      A       127.0.0.1
ns      IN      A       127.0.0.1
@       IN      AAAA    ::1
router  IN      A       192.168.15.1
router  IN      A       192.168.20.1
www     IN      CNAME   router
ww2     IN      CNAME   router
client1 IN      A       192.168.15.10
client2 IN      A       192.168.20.10
```
Описание типов записей:
- `SOA`-запись - основные параметры доменной зоны:
  - Serial number - должен быть уникальным. Достаточно удобно записывать её как `YYYYMMDDSN`, где сначала идёт дата, а потом серийный номер в этой дате
  - Refresh time - как часто secondary-серверу стоит обращаться к primary, чтобы проверить, не изменился ли serial. Если изменился, secondary запросить новый ресурсный файл
  - Retry time - как часто следует пытаться повторно обновить данные на secondary-сервере при неудачных попыток
  - Expire time - сколько времени пройдёт до признания данных на secondary-сервере не валидными в случае неудачных обновлений
  - Negative Cache TTL - время до очистки записей с негативными ответами (*Парыгин сказал, что это слишком специфичная штука, которой мы пользоваться не будем сейчас*)
- `NS`-записи выдают имена DNS-серверов, к каким можно обратиться для получения данных
  - Указывать можно **только имена**, не адреса
  - Обязательно нужно 2 нэймсервера
    - Бесплатный второй нэймсервер можно получить на многих сайтах, например, [тут](https://freedns.afraid.org/menu/)
- `A`-записи выдают адреса IPv4
- `AAAA`-записи выдают адреса IPv6
- `MX` запись позволяет описать, куда следует отправлять электронные письма
  - Формат: `some.sub.domain.       IN      MX      <priority> emal.domain.` 
    - `priority` - целое число, указывающее приоритет этого почтового сервера в сравнении с остальными
- `CNAME`-запись позволяет сопоставить одно доменное имя другому

**В конце полного адреса домена надо писать точку. Если точку не написать, то к написанному имени добавится имя зоны**

`db.168.192`:
```
;
; BIND data file for kirill.local loopback interface
;
$TTL    604800
@       IN      SOA     kirill.local. root.kirill.local. (
                        2024041503      ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
;
@       IN      NS      router.kirill.local.
1.15    IN      PTR     router.kirill.local.
1.20    IN      PTR     router.kirill.local.
10.15   IN      PTR     client1.kirill.local.
10.20   IN      PTR     client2.kirill.local.
```
Нюансы и пояснения:
- `PTR`-запись - запись, обратная `A`-записи
- `SOA`-запись идентична по именам
  - Разумеется, серийный номер **должен отличаться**
- Нет полной уверенности, но вроде как тут желательно писать полные доменные имена

# 24.04.10 - лекция
## DNS
Точку в конфигах выше мы писали не просто так: она на самом деле есть всегда - браузеры её просто для красоты убирают

В основе DNS лежит иерархическая структура:
- В самой основе идут корневые сервера (зона нулевого уровня), которые хранят адреса серверов по доменным зонам первого уровня
- На серверах зоны первого уровня, которых уже в разы больше по миру, лежат адреса серверов доменов второго уровня
- И так может быть много-много уровней вложенности

# 24.04.15,22 - семинар
## Хостинг
**LAMP** - Linux - Apache - MySQL -  PHP

### Apache
`sudo apt install apache2 -y` - в папке `/etc/apache2` появятся все конфиг-файлы для апач
- Нас в особенности интересует папка `sites-avilable`, в которой будут располагаться конфиги доступных сайтов
- Чтобы "включить" сайт, мы должны скопировать или создать ссылку на конфиг и расположить её в папке `sites-enabled`

Работу с БД мы разбираем на примере MariaDB (MySQL):
- `sudo apt install mariadb-server mariadb-client`
- `sudo mysql_secure_installation`

Для удобной работы со всеми базами данных мы можем использовать, `phpmyadmin`, который интегрируется с `mysql` и `apache2`:
- `sudo apt install php`
- `sudo apt install phpmyadmin`

# 24.04.17 - лекция
## Ещё раз практика по DNS
*Пожалуй, буду просто дополнять инфу с [этого семинара](#240408---семинар)* 