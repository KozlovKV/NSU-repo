- [Инфо](#инфо)
  - [Лабы](#лабы)
    - [Общие задачи](#общие-задачи)
    - [Задачи на разработку](#задачи-на-разработку)
- [24.02.12 - семинар](#240212---семинар)
- [24.02.14 - лекция](#240214---лекция)
  - [Подробнее про уровни OSI](#подробнее-про-уровни-osi)
    - [Физический уровень](#физический-уровень)
    - [Уровень физической адресации](#уровень-физической-адресации)
- [24.02.22 - лекция](#240222---лекция)
    - [Уровень сетевой адресации](#уровень-сетевой-адресации)
- [24.02.26 - семинар](#240226---семинар)
- [24.02.28 - лекция](#240228---лекция)
  - [Практика по OSI-2-3](#практика-по-osi-2-3)
- [24.03.06 - лекция](#240306---лекция)
  - [ICMP](#icmp)
- [24.03.11 - семинар](#240311---семинар)
  - [Маршрутизация](#маршрутизация)
    - [NAT](#nat)
  - [Свой роутер](#свой-роутер)
- [24.03.13](#240313)
  - [OSI-4 - транспортный уровень](#osi-4---транспортный-уровень)
    - [Порты](#порты)
    - [TCP](#tcp)
    - [UDP](#udp)
- [24.03.18 - семинар](#240318---семинар)
  - [Снова про `iptables` и маршрутизацию](#снова-про-iptables-и-маршрутизацию)
    - [`iptables-persistent`](#iptables-persistent)


# Инфо
Лектор - Гаранин Александр

Семинарист - Валерий Владимирович Павлов - +79139389393

[Наталья и Виктор Олифер, "Компьютерные сети"](https://moodle.iae.nsk.su/int_networks_23/ol6.pdf)

## Лабы
### Общие задачи
1. Перехват и анализ данных при помощи программы Wireshark Перехватить и объяснить принцип работы протоколов arp (генерируем любым другим запросом, например ping), icmp (ping, traceroute), tcp (например скачивание файла по https), udp (ping доменного имени приведет к dns запросу по udp). Объяснить принцип работы traceroute утилиты.

2. Настроить SSH-сервер и SSH port forwarding Установить openssh-server, с одного вируального ПК подключиться к другому по SSH. На одном виртуальном ПК запустить nc(netcat) сервер, далее подключиться к этому ПК по ssh и пробросить по ssh порт этого сервера, на другом виртуальном ПК продемонстрировать работу проброса порта (тоже с помощью nc, но уже клиента, а не сервера).

3. VPN сервер сделать Принцип работы OpenVPN. Создать VPN подключение между двумя линуксами или линуксом и windows. Объясить зачем нужен VPN вообще.

4. Настроить iptables Настройка виртуального ПК, как роутера интернета, с технологией NAT: настроить 2 интерфейса и собственный NAT на базе iptables на одном виртуальном ПК, один интерфейс ПК через NAT (реализован средствами VirtualBox) в подключен в реальный ПК, другой в виртуальный свитч, туда же включен сетевой интерфейс второго виртуального ПК, и второй ПК должен ходить в интернет через первый. В данной задаче допустимо не использовать DNS (ввиду того что до него пока не дошли по темам) а проверять наличие интернета и верную настройку "роутера" по доступности 8.8.8.8 например.

5. Настроить DNS-сервер Поставить bind9 и настроить самому полностью рабочий DNS сервер. Настроить на нем свою зону. Рассказать о назначении утилит nslookup и dig и продемонстрировать с их помощью работу сервера. Дополнительно, вернуться к задаче 4 и указать на втором виртуальном ПК DNS сервер, который находится на первом и проверить работу браузера - открываются ли сайты.

6. Настроить LAMP (или LEMP) Установить Apache (Nginx) PHP MySQL и поставить на это на все популярную CMS например joomla или wordpress, создать и показать сайт на одной из этих CMS (наполнение не важно, достаточно продемонстрировать работу главной страницы и административной панели). В данной задаче допустимо заменить Apache на Nginx.

### Задачи на разработку
7. Простой HTTP сервер Написать простой HTTP сервер поддерживающий метод GET. Получить страницу с файлами из папки, получить ответ в виде html и получить ответ в виде html из определенного заранее подготовленного файла.

8. Простой чат (клиент и сервер) Написать и запустить сервер чата, написать и запустить минимум 2 клиента. Продемонстрировать работу чата. Архитектура чата должна быть P2P (клиент-серверные решения не интересуют). Чат функционирует в пределах локальной сети. Каждый клиент отправляет сообщение либо конкретному пользователю (имя пользователя совпадает с именем машины), либо всем. Всеобщая рассылка должна вестись с помощью бродкаст-адресов.

# 24.02.12 - семинар
Сетевой мост - внешний DHCP сервер будет выделять нам отдельный IP-адрес (в частности, позволит нам с хоста подключаться к виртуальной машине)

NAT - хост будет восприниматься как маршрутизатор (*не уверен, что верно понял суть*)

Для установки дополнительного ПО:
- Подключаем диск от VB
- Запускаем терминал из-под суперпользователя
- Исполняем `.sh` скрипт, который лежит на диске

Серые IP-адреса (немаршрутизируемые) - адреса вида:
- `10.0.0.0/8` (маска `255.0.0.0`)
- `172.16.0.0/16` (маска `255.255.0.0`)
- `192.168.0.0/24` (маска `255.255.255.0`)

*Советует почитать статью про IPv4 на Википедии*

# 24.02.14 - лекция
[Ссылка на актуальную версию лекции](https://docs.google.com/document/d/1mhas-FCinx5firKdvqY3spbkAhwRe0jrDJZBjkPxn4Q/edit)

Модели TCP/IP и OSI - абстракции, которые описывают взаимодействие между машиной компьютерами по сети

TCP/IP устроена несколько проще

*Вместо десятка слов пусть будет картинка:*
![](./materials/osi-and-tcpip.jpg)

## Подробнее про уровни OSI

### Физический уровень
Работа со средой

Витая пара (например, UTP - unshielded twisted pair), могут отличаться по качеству меди. Самый стандартный - cat5e. На концах кабеля присоединяются разъёмы (например, 8p8c - 8 проводов, 8 контактов). Если кабель с двух сторон имеет такие (или похожие) разъёмы, то кабель будет называться **патчкордом**

Радиоэфир - самый популярны протокол Wi-Fi (также называется IEEE 802.11xx, где `xx` - одна или несколько букв)

Оптический кабель - дорогая штука для использования в домах, однако вот уже дома к общим узлам, а тем более передача данных на большие расстояния происходит уже через них

---

Полученные с этого уровня биты на более высоких уровнях интерпретируются в определённые символы, но до высшего уровня дойдут не все из них - на переходе на более высокий уровень будут читаться, а затем убираться заголовки, говорящие о том что делать с этими данными. То есть реализуется механизм **инкапсуляции**


### Уровень физической адресации
Основной протокол ethernet ([IEEE 802.3](https://moodle.iae.nsk.su/int_networks_23/IEEE-802.3-2012.pdf)). Здесь находятся MAC-адреса

![](./materials/24-02-14%20-%20ethernet.png)

В самом простом случае информация тут состоит из MAC-адреса адресата, отправителя и тип следующего уровня OSI

Главная функция - физическая адресация

# 24.02.22 - лекция
### Уровень сетевой адресации
Здесь находятся IP-адреса (IPv4, IPv6) - адреса, необходимые для маршрутизации

**Маска** - позволяет выделить пространство адресов из всего их множества (примеры масок смотри с семинара)

**"Серый" (локальный) IP** - опять же, ничего особо нового не узнал, кроме того, что сети серых адресов бывают вложенные (*ничего удивительного на самом деле, на середине лекции задумался об этом и понял, что иначе было бы адресов слииишком мало*)

Главная функция этого уровня - логическая адресация

# 24.02.26 - семинар
MAC-адреса не выходят за пределы локальной сети

DHCP-сервер - Dynamic host control protocol - ведёт учёт зарегистрированных в сети машин (то есть их локальные адреса)

# 24.02.28 - лекция
## Практика по OSI-2-3
`ip a` - показать доступные сетевые интерфейсы 

На одной сетевой карте можно установить МНОГО IP-адресов с разными (*а точно ли?*) масками подсети (*очевидно, хотя это и не говорилось, кроме настроек через комп для сетевой карты, нужны будут ещё какие-то действия*)
- На Винде заходим для этого в настройки интернет
- В Линуксе ищем конфиги интерфейсов в `/etc/network/interfaces` (*но ни на серваке, ни на WSL я такого не нашёл... А вот на Debian он есть*)
  - `ifup <interface_name>` - запустить интерфейс
  - `ifdown <interface_name>` - выключить интерфейс

В маршрутизаторе есть 2 сетевых интерфейса: один отвечает за связь локальных устройств с маршрутизатором (**LAN**, подписывается в настройках как default gateway), а другой - за связь маршрутизатора с глобальной сетью (**WAN**) (зачастую, с сетью провайдера)

Механизм работы всех маршрутизаторов заключается в том, что при обращении к внешним адресам, наш компьютер будет обращаться к LANу маршрутизатора, тот к LANу провайдера и так может быть много раз, но механизм, начиная с провайдера, сильно сложнее

Зачастую локальные IP-адреса, default gateway и все прочие параметры получаются устройствами в сети автоматически, благодаря DHCP-серверу

ARP - Address resolution protocol - позволяет по IP-адресу узнать MAC-адрес устройства. Для этого посылается запрос по всей локальной сети, в котором говорится, что источник хочет пообщаться с таким-то IP, владелец этого IP шлёт в ответ отправителю свой MAC.
- `arp` - посмотреть ARP-кэш
  - `ip neigh` - то же самое (`arp` у меня не работала ни на одной машине Линуксовой)
- `ip -s neigh flush all` - сброс ARP-кэша

Коммутатор работает только на уровне физической адресации. Позволяет общаться через свои порты разным устройствам, сопоставляя портам разные адреса. Устройство безумно примитивное - просто хранит таблицу, сопоставляющую порты и MAC-адреса

# 24.03.06 - лекция
*Ввиду неосмотрительности и беспечности сделал запись без звука, так что буду писать по большей части основываясь на документе*

Коммутатор обновляет таблицу при поступлении каждого нового фрейма. Если MAC-адрес получателя есть в таблице портов, то запрос направится на конкретный порт, если нет, то на все порты, кроме отправителя.

Широковещательные адреса воспринимаются всеми устройствами как собственные:
- MAC-адрес - `FF.FF.FF.FF.FF.FF`
- Широковещательный адрес IPv4 образуется как побитовое ИЛИ адреса локальной подсети и инверсии маски этой подсети

---

У протокола IPv4 есть поле TTL - Time to Live - которое определяет степень живучести пакета:
- Выставляется системой или приложением в пределах от 1 до 255
- При прохождении одного маршрутизатора уменьшается на единицу
- При достижении нуля, пакет будет отброшен
- Позволяет избежать зацикливания пакетов, а также даёт возможность наблюдать за путём пакета по сети (`tracert` на Винде и `traceroute` на Линуксе)

## ICMP
ICMP - Internet Control Message Protocol - также располагается на третьем уровне OSI и используется для передачи некоторых серверных сообщений. Содержит тип, код и контрольную сумму.

Типы:
- `0` - echo reply - код `0`
- `8` - echo request - код `0`
- `3` - получатель недоступен (destination unreachable message). Популярные коды:
  - `0` - net unreachable
  - `1` - host unreachable
  - `2` - protocol unreachable
  - `3` - port unreachable

# 24.03.11 - семинар
## Маршрутизация
У каждого компьютера может быть один или несколько сетевых интерфейсов, каждому интерфейсу может быть назначено от нуля до множества IP адресов. При этом каждый адрес должен быть уникальным

На самом деле у маршрутизатора может быть больше двух интерфейсов, причём как много LANов, так и много WANов - выбор нужного интерфейса будет определяться таблицей маршрутизации

Прокси-сервер - принимает пакеты и перенаправляет их далее от своего имени

### NAT
NAT - network address translation - необходим для корректной передачи пакетов из локальных серых подсетей. sNAT - замена источника, dNAT - замена назначения, pNAT - замена порта. Заменой адресов по протоколу NAT занимается [**фаерволл**](#снова-про-iptables-и-маршрутизацию) на роутере.

Суть работы достаточно проста:
- Маршрутизатор получил запрос от устройства в локальной сети
- Заменил адрес назначения на свой собственный адрес (WAN)
- Оставил пометку о том, куда он отправил пакет от локальной машины
- Получив ответ, перенаправляет его внутреннему узлу

Проблемой становится то, что достаточно сложно устанавливать связь между пакетами, поэтому для каждого пересланного пакета заключается контракт со своей особой протокол-специфичной структурой.

## Свой роутер
Зная это, мы можем настроить собственную машину как роутер (Linux Debian):

1. Настроить адреса в локальной сети (в частности, назначить наш комп как default gateway)
   1. На внутренней машине сети один интерфейс со статическим адресом:
```
auto <interfaceName>
iface <interfaceName> inet static
  address <hostIP>/<mask>
  gateway <gatewayAddress> # Адрес машины из следующего пункта
```
   2. На машине-роутере 2 интерфейса:
```
# Внешний интерфейс
auto <interfaceName1>
iface <interfaceName1> inet dhcp

# Внутренний интерфейс
auto <interfaceName2>
iface <interfaceName2> inet static
  address <gatewayAddress>/<mask>
```
2. Установить `iptables`
3. Внести в NAT-таблицу запись для sNAT (*[подробнее о сути работы `iptables`](#снова-про-iptables-и-маршрутизацию)*)
   1. В рамках одной сессии: `iptables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADE`
4. Включить IP forwarding (пересылать запросы с одного интерфейса на другой)
   1. В рамках одной сессии: `echo 1 > /proc/sys/net/ipv4/ip_forward`
   2. На постоянную основу: раскоментировать в файле `/etc/sysctl.conf` строчку `net.ipv4.ip_forward=1`

# 24.03.13
## OSI-4 - транспортный уровень
Этот уровень отвечает за надёжную доставку данных, которые здесь передаются в виде сегментов, содержимое которых определяется протоколом. Самые популярные из них - TCP и UDP.

### Порты
Адресация в обоих протоколах осуществляется за счёт портов, при этом порты для каждого протокола **СВОИ**

Порт - 16-битное число.
- `0` - служебный порт
- `1`-`65535`
  - `1`-`32767` - статические порты. Среди них берутся порты для сервисов, к которым обращаются извне (выступают в качестве `destination`)
  - `32768`-`65535` - динамически выделяемые. Они обычно используются для обратного общения сервера с клиентом и выделяются для сессий

По общему соглашению некоторые порты среди статических используются в первую очередь для определённых протоколов более высоких уровней. Вот некоторые примеры:
- `21` - ftp
- `22` - ssh
- `23` - telnet (устаревшее управление терминалом)
- `80` - http
- `443` - https
- `25` `110` `143` `465` `993` - почтовые протоколы

Таким образом, соединение в рамках сети и компьютера может быть однозначно определено парой адрес, порт, которая будет называться **сокетом**. Соответственно, у нас есть **UDP-сокеты**, **TCP-сокеты** и т.д.

### TCP
TCP - Transmission control protocol - отвечает за надёжную (почти что гарантированную доставку)

Составляющие хэрэра:
- `src`/`dst` порты по 16 бит
- `sequence number` (`seq`) - номер байта в общем потоке данных
- `acknowledgment number` (`ack`) - количество полученных байт
- Флаги
  - `SYN`
  - `ACK`

Открытие TCP-соединения **троекратным рукопожатием**:
- Отправляется TCP-пакет с флагом `SYN` и случайным `seq` (`client_init_seq`)
- Сервер отвечает TCP-пакетом с флагами `SYN` и `ACK` и своим собственным случайным `seq` (`server_init_seq`) и `ack` = `client_init_seq + 1`, подтверждая тем самым, что получил `seq` клиента
- Клиент должен также сделать ответ с флагом `ACK`, `seq` = `client_init_seq + 1` и `ack` = `server_init_seq + 1`
- Теперь оба на обоих сторонах приложения могут контролировать и синхронизировать количество переданных данных при помощи синхронизованных `seq` и `ack`

### UDP
Не требует никакого рукопожатия, а сразу отправляет пакет

# 24.03.18 - семинар
## Снова про `iptables` и маршрутизацию
`iptables` - или же **фаерволл** - почти что неотъемлемая часть ОС, которая отвечает в первую очередь за перенаправление адресов. Может работать по двум принципам:
- Чёрного списка - разрешено всё, что не запрещено
- Белого списка - запрещено всё, что не разрешено

Таблицы в этом модуле состоят из цепочек. Суть цепочки в том, что мы идём от её начала к концу до тех пор, пока не найдём правило, которое можно будет применить. Когда такое правило найдено, поиск дальше не ведётся, из чего следует, что порядок цепочек может быть критически важен. При отсутствии подходящего правила в цепочке будет применено правило по умолчанию

Таблица `filter` содержит следующие цепочки:
- `INPUT` - содержит правила для входных соединение. Вид правил следующий
  - Общий вид команды: `-a INPUT -s <source_ip> -p <TCP/UDP/OTHER_PORT> --d-port:<port_number> -j <ACTION>`
  - Пример `-a INPUT -s 192.168.0.179 -p TCP --d-port:22 -j DROP` запретит входящее ssh соединение от машины `192.168.0.179`
  - По умолчанию содержит просто правило `ACCEPT`
- `OUTPUT` - исходящие запросы. По умолчанию `ACCEPT`
- `FORWARD` - для пересылок с одного интерфейса на другой интерфейс. По умолчанию `ACCEPT`

Цепочки таблицы `mangle` отвечают за обновление TTL (по умолчанию он 64)

Цепочка таблицы `nat` ([инфа про сам NAT](#nat)):
- `INPUT` и `OUTPUT` нам не очень интересны
- `PREROUTING`
  - Проходится перед `filter.FORWARD`
- `POSTROUTING` 
  - Проходится после `filter.FORWARD`
  - Сюда должно вноситься правило для `sNAT`: `MASQUERADE` либо `SNAT --to-sourcer<WAN_Address>`

Описание флагов для `iptables`:
- `-t <table>` - выбрать для работы таблицу `table`
- `-A <CHAIN>` - добавить правило в цепочку `CHAIN`
- `-D <CHAIN>` - удалить правило из цепочки `CHAIN`
- `-o <output_interface>`
- `-i <input_interface>`
- `-s <source_ip>`
- `-p <protocol>` - специфицировать протокол OSI-4 (`tcp`, `udp` и другие, а также `all`; можно перед протоколом поставить `!`)
  - Если мы задали протокол, то можем прописать `--dport <port>` или `--sport <port>`
- `-j RULE` - добавить правило `RULE`
  - Стандартные правила:
    - `ACCEPT`
    - `DROP` - просто отбросить пакет
    - `REJECT` - отклонить пакет и прислать об этом ответ отправителю
    - `RETURN` - прекратить обход текущей цепочки

Примеры команд:
- `iptables -t filter -A INPUT -i enp0s3 -j REJECT` - запретит входящие подключения через интерфейс `enp0s3` (**НЕ ПРИМЕНЯТЬ ПРИ SSH СОЕДИНЕНИИ**)
- `iptables -t filter -A OUTPUT -o enp0s3 -j REJECT` - запретит отправлять данные наружу через интерфейс (**ВПОЛОВИНУ ТАКЖЕ ОПАСНО ПРИМЕНЯТЬ ПО SSH**)
  - Цепочка `OUTPUT` в таблице `filter` **НЕ ВЛИЯЕТ** на цепочку `FORWARD`, то есть мы можем замутить схему, в которой роутер будет пересылать запросы от хостов в своих подсетях, но не сможет сам обращаться ко внешней сети
  - `iptables -t filter -A OUTPUT -p tcp --sport 22 -j ACCEPT` - если это правило установить перед тем, что выше, будет безопасно при использовании SSH

### `iptables-persistent`
При перезагрузке правила, назначенные командами выше, сбрасываются. Для сохранения используется программа `iptables-persistent`

При установке спросит, сохранить ли текущие правила `iptables`. Они будут сохранены в файлы `rules.v4` и `rules.v6` в `/etc/iptables/`, откуда они будут загружаться по умолчанию при запуске системы.

Также будет доступен ряд утилит (почти у всех есть альтернативные версии с первой половиной `ip6tables`):
- `iptables-save` - выводит в stdout все правила (*следовательно, мы можем их просто перенаправить в файлы*)
- `iptables-restore` - восстанавливает таблицы на основании данных из stdin (формат тот же, что и у вывода `iptables-save`)
- `iptables-apply` - безопасная установка правил. В случае ситуации, когда установка правила приведёт к разрыву соединения, откатит этот изменение
  - `-w <path/to/succesful/script>` - по этому пути будет сохранён скрипт в случае, если установка правил прошла успешно
    - Путь по умолчанию - `/etc/network/iptables.up.rules`
  - В качестве источника данных может выступать файл либо команда после флага `-c`
    - Так, если команду для блокировки входящих сигналов выше использовать с этой утилитой: 
      - `echo 'iptables -t filter -A INPUT -i enp0s3 -j REJECT' > cmd.sh`
      - `chmod a+x cmd.sh`
      - `iptables-apply -c cmd.sh`
      - Утилита спросить, можете ли вы сейчас подключиться. В случае проблем с добавленными правилами, мы просто не сможем отправить символ `y`, поэтому через несколько секунд будет принят ответ по умолчанию `N`, который сбросить внесённые изменения
    - *Фан-факт:* если в `cmd.sh` будет команда `iptables -t filter -A OUTPUT -o enp0s3 -j REJECT`, то при нормальной реакции пользователя всё сработает хорошо: сервер не сможет отправить пользователю по `ssh` вывод => пользователь ничего не нажмёт => изменения сбросятся, однако технически нам ничто не мешает отправить `y` с клиента на сервер, после чего изменения сохранятся в таком полуадекватном виде