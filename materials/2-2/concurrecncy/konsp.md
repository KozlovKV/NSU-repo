- [Инфо](#инфо)
- [24.02.05 - лекция](#240205---лекция)
- [24.02.02 - семинар](#240202---семинар)
- [24.02.12 - лекция](#240212---лекция)
  - [module checking](#module-checking)
  - [Линейная темпоральная логика (LTL)](#линейная-темпоральная-логика-ltl)
- [24.02.12 - Семинар](#240212---семинар)
- [24.02.19 - лекция](#240219---лекция)
  - [Язык Promela и система верификации SPIN](#язык-promela-и-система-верификации-spin)
- [24.02.19 - семинар](#240219---семинар)
- [24.02.26 - лекция](#240226---лекция)
- [24.02.26 - семинар](#240226---семинар)
- [24.03.04 - лекция](#240304---лекция)
  - [Трейсы](#трейсы)
- [24.03.04 - семинар](#240304---семинар)
- [24.03.11 - лекция](#240311---лекция)
  - [Спецификация корректности событий](#спецификация-корректности-событий)
  - [Параллельные процессы](#параллельные-процессы)
- [24.03.11 - семинар](#240311---семинар)
  - [Маге правило для преобразования параллельных процессов](#маге-правило-для-преобразования-параллельных-процессов)
- [24.03.18 - лекция](#240318---лекция)
  - [Обедающие философы (*голодные, если по Иртегову*)](#обедающие-философы-голодные-если-по-иртегову)
  - [Change symbol](#change-symbol)
- [24.03.18 - семинар](#240318---семинар)
- [24.03.25 - лекция](#240325---лекция)
  - [Недетерминизм](#недетерминизм)
- [24.04.01](#240401)
- [24.04.08](#240408)
  - [Коммуникация процессов](#коммуникация-процессов)
- [24.04.15](#240415)
  - [Трубы](#трубы)
- [24.04.22](#240422)
- [24.04.29](#240429)


# Инфо
Лектор - 

Семинарист -

# 24.02.05 - лекция
Параллелизм = процессы + коммуникация (*взаимодействие между ними?*)

Коммуникация может проходить через сообщения либо разделяемые переменные

Процесс иногда также называют системой дискретных событий

Процесс описывает:
- Окружение системы
  - Действия системы, машины или человека
  - Общее количество событий или действий, выполняемых системой, и порядок их исполнения
  - Сроки и вероятности
- Некоторые аспекты окружения - абстрактная идеальная картина "реального" окружения
- Наблюдение за поведением
  - Выбранное действие
- Дискретные действия - возникают в различные моменты времени и чётко по ним разделены

Алгебра процессов (**process algebra**) предназначена для формализации окружения. Содержит процессы, удовлетворяющие трём аксиомам:
- `a * (b * c) = (a * b) * c`
- `U * a = a * U`
- `a * a^-1 = a^-1 * a = U`

Простейшие пример - функция ввода-вывода. Более сложные пример - конечный автомат

*Дальше начинает что-то совсем невнятное...*

# 24.02.02 - семинар
- Процесс управляющего алгоритма
- Процесс датчиков индикаторов ( датчики - передача инфы от окр среды к управляющему алгоритму) индикатор -  передаёт инфу от объекта как к среде так и к контроллеру
- Процессы актуаторов - объекты управления
- Процесс пользователя

Выделяете процессы и их состояния

1. Представьте что вы пользователь системы и что вы хотите от системы. Состояние - событие или действие

Вагонетка

Кнопка - датчик , актуатор это штука которая что-то делает конкретно

контроллер - логика 

Датчик - инфа от пользователя или среды к контроллеру

Датчики: открыть закрыть дверь, вызвать вагонетку и тп, вперед назад

Индикаторы : на какой остановке пользователь, это индикаторы тк их не пользователь отправляет

Индикаторы относим к объекту управления

ОТ контроллера в объект управления или контроллер

Актуатор - сущность через которую работает контроллер.

Состояния польщователя: cуществует

Действия: кнопка вызова

Контроллеры нужны только события от кнопок для нажатия

Про требования

Что нужно от системы

Требование безопасности

Требование времени

# 24.02.12 - лекция
## module checking
*Ааа! Как быстро говорит...*

Было что-то про верификаторы... Которые должны проверять... Корректность модели?

Модель для формальной верификации должна содержать всё, что нужно, и ничего лишнего (*вот это поворот*)

**Структура Крипки** - система с конечным множеством состояний, где выделяются начальные состояния, выводятся правила перехода между состояниями

*Как это вообще можно успевать осознавать?!*

*Тут скипнул большой кусок...*

Параллельные программы состоят из комбинации последовательных программ

*Теперь говорит про критические секции со спинлоками*

*Я реально не понимаю смысла этих лекций. Ощущение, будто тут тоже идёт просто ознакомление... Хотя, может дело в том, что я не слушал половину времени?..*

## Линейная темпоральная логика (LTL)
В них определены кванторы, булевы переменные и прочие штуки для логики первого порядка + модальные высказывания и *ещё какая-то штука, то ли аксиомы, то ли ещё что-то*.

Описывают пути в дереве состояний...

Так... Видимо для хоть какого-то понимания этого предмета нужно читать книгу Хоара... Возможно, вместо лекций (**наверняка вместо лекций**)

Теперь мы как-то связываем структуру Крипке с... этой темпоральной логикой. И всё это нужно для верификаторов...

Верификация логики LTL на структуре Крипке - плохая задача, потому что сводится к поиску Гамильтоновых путей.

Для +- быстрого решения задачи используется табличный алгоритм Лихтенштейна, который позволяет строить структуру на основании формул (*за последнее утверждение не ручаюсь*)

# 24.02.12 - Семинар
Структура Крипке:
- Состояния
  - Начальные состояния
- Переходы

На практике для построения структуры Крипке мы берём процесс, а потом его процессы-состояния и соединяем их переходами логичным образом, при этом у нас могут быть состояния с одинаковыми именами, если того требуют логика процессов (соответственно)

**Из состояния есть хотя бы один переход**

Темпоральные операторы в логике LTL (определены на бесконечных последовательностях):
- X (next) - выбрасываем первый элемент последовательности, со следующего постфикса
- G (globally) - формула верна для всех постфиксов
- F (future) - когда-нибудь формула будет верна для постфикса

Псевдокод для семинаров:
- `{ a_1 ; a_2 ; ... ; a_n }` - последовательные команды
- `{ a_1 | a_2 | ... | a_n }` - произвольное исполнение
- `{ a_1 || a_2 || ... || a_n }` - параллельное исполнение
- `:=` - присваивание
- `while b do a` - цикл
- `if a then b else c` - ветвление
- `LABEL:` - брэйкпоинты
- `wait(condition)` - пока условие ложно, ждём (эдакий спинлок)

Задача: в комнате 2 комара, хотя бы один зудит всегда
```
{Z1 || Z2}

Z1:
while True do
  if (buzz2)
    {buzz1 := true; | buzz1 := False;}
  else
    buzz1 := true;

Z2:
while True do
  if (buzz1)
    {buzz2 := true; | buzz2 := False;}
  else
    buzz2 := true;
od
```
*Код хреновый с незащищённой критической секцией*

*Дальше была прям жуть про семантическое представление программ*

**Разговор о домашке!!!**

# 24.02.19 - лекция
## Язык Promela и система верификации SPIN
Promela - Process meta language. Основные объекты в нём: процессы, объекты и каналы сообщений

Процесс объявляется словом `prototype`

Запуск будет либо за счёт префикса `active` при объявлении, либо за счёт слова `run` перед именем процесса (aka имя функции). 

Процесс `init` имеет `_pid` 0 и всегда запускается в начале

*Добавить примеры кода из лекции*

Переменные бывают глобальными (объявляются вне процессов) и локальными. Нет понятия области видимости.

Массивы мерностью больше одной можно задать только с помощью `typedef`

*Большой скип*

Есть каналы оператором `chan`. Отправка сообщений через `!`

*Ещё скип*

Есть оператор `atomic {op1; ope2; ...;}`, после которого идёт блок который будет гарантированно выполнен атомарно (все другие процессы, работающие с глобальными переменными, упомянутыми в этом блоке) и засыпают (*а точно ли...*)

*Ну и дальше много чего ещё было, однако всё это есть в презентации, так что буду потом из неё читать по необходимости*

# 24.02.19 - семинар
Цикл until `p U q` работает так: выполнятся `p` до тех пор, пока не наступит `q` 

Слабый until (`W`) отличается от сильного тем, что терм в теле цикла может выполняться вечно, тогда как для `U` мы гарантируем, что цикл однажды закончится

# 24.02.26 - лекция
*Может быть я даже сделаю пару записей...*

Простые процессы описываются атомарными события, длящиеся во времени действия описываются событиями

Процесс - шаблон поведения, состоящий из определённого набора событий

События описываются в алфавите событий, соотносящимся с определёнными событиями. Над этим алфавитом определяются алгебраические операции, для которых нужно нулевое событие (называется `STOP` и обычно является некорректным состоянием системы)

Процессы описываются как цепочки событий из алфавита, которые должны заканчиваться процессами (в том числе и `STOP`). Процессы обозначаются большими буквами, события - маленькими. Фактически, процесс с несколькими стрелочками представляет собой цепочку процессов

**Защищённые процессы ДОЛЖНЫ** содержать по крайней мере одно событие. В основном в вычислениях используются именно они.

Через `|` можно описывать альтернативные процессы: `(a -> A | b -> B | c -> C)` (события слева должны быть РАЗЛИЧНЫМИ). Альтернативная форма записи `x : EVENTS -> P(x)`, здесь берётся событие из некоторого множества, а `P(x)` сопоставляет каждому событию свой процесс

Законы:
1. $(x : A \rarr P(x)) = (y : B \rarr Q(y)) \hArr A = B \wedge \forall x \in A : P(x) = Q(x)$
   - *Дальше банальные доказательства по типу $(a \rarr B) \ne (b \rarr B)$, $STOP \ne (a \rarr A)$, $(a \rarr A) = (a \rarr B) \hArr A = B$ и т.п.*
2. Каждое уравнение вида $Y = F(X)$ имеет единственное решение, если в нём защищённые процессы
3. *Ну и вроде третье какое-то тоже было...*

# 24.02.26 - семинар
*Там просто болтали про материал с лекции*

# 24.03.04 - лекция
## Трейсы
**Трейсы** представляют собой конечную последовательность событий в рамках процесса (*фактически, называть это просто "путём" вполне приемлемо, как мне кажется*)

Записываются к угловых скобках: `<event1, event2>`

Поддерживают операцию **конкатенации**, являющуюся ассоциативной

**Строгая** функция отображает пустое множество в пустое множество

**Дистрибутивная** функция действует на конкатенацию трейсов также, как действовала бы на элементы конкатенации. Таким образом, она будет однозначно определена своим действием на трейс длины 1

Возведение в степень `n` - конкатенация `n` раз (в нулевой степени получим нулевой трейс)

Операция **ограничения** - записывается как стрелочка вверх и применяется для трейса и алфавита. Вынимает из трейса все символы, не содержащиеся в алфавите-аргументе. Дистрибутивная и следовательно, строгая

Указывая у имени трейса нижний индекс, мы обращаемся к его элементу (*считаем по-прогерски, с нуля*)

Запятая в качестве верхнего индекса у имени трейса возвращает нам трейс без первого элемента (*интересно, чем вообще руководствовались при выборе такого обозначения*)

Звёздочка клини позволяет по алфавиту получить все возможные в нём трейсы.

Отношение порядка для двух трейсов $u \le s$ будет истинным, если $u$ - префикс трейса $s$. **Будет отношением частичного порядка**

Монотонные функции - те, что не нарушают отношения порядка своих аргументов

Диадические функции монотонны по некоторым из своих аргументов, когда другие - константы

`#trace` - длина трейса

Стрелка вниз - операция для трейса и события, которая возвращает количество вхождений события в трейс (эквивалентна взятию длины от результата операции ограничения)

Функция `traces(P)` - возвращает нам множество всех трейсов, которые может породить процесс `P`

`P / s` - поведение процесса `P` после происшествия трейса `s`. (*откусываем из начала какого-то трейса процесса `P` часть `s`*). Опасный оператор, который может сделать процессы (особенно рекурсивно определённые) на защищёнными

`f*(s)` - мапает все элементы трейса согласно работе какой-то функции

*Чего-то было про **интерливинг**, но это понял слабо*

**Композиция** двух трейсов возвращает конкатенацию двух трейсов в случае, если в первом пристутствует событие успешного завершения (галочка). При этом все события в первом трейсе после галочки не войдут в конкатенацию

# 24.03.04 - семинар
$$
trace = \{s | s \le \^\{<g>, <g,y,r>\}^*\}
$$

# 24.03.11 - лекция
## Спецификация корректности событий
$tr \downarrow c = \#(tr \uparrow \{c\})$

Через эту и другие операции над трейсами + отношения порядка и логические операции можно задать почти любые условия для корректности процессов (спецификации. Записываются большими буквами)

`P sat S` означает, что процесс `P` удовлетворяет спецификации `S`, то есть любой его трейс ей удовлетворяет

*Дальше было какое-то практическое доказательство корректности, но вникать в него было в лом да и не очень нужно пока что. Если что, посмотрю потом*

## Параллельные процессы
*Чё-то тут про них было, но совсем непонятное...*

# 24.03.11 - семинар
## Маге правило для преобразования параллельных процессов
Если у нас есть параллельные процессы $(x : A \rarr P(x)) || (y : B \rarr Q(y))$, то мы заинтересованы в том, чтобы перенести параллельность на самый глубокий уровень. Сделать это можно многими преобразованиями (см. лекцию от 11 марта) либо же используя это правило:

*которое мне стало впадлу писать тут спустя 2-3 часа*

# 24.03.18 - лекция
## Обедающие философы (*голодные, если по Иртегову*)
Общее положение задачи писать не буду, опишу здесь её в CSP-теминах:

Процессы (*сложение и вычитание везде по модулю 5*):
- $0 \le i \le 4 : PHIL_i$
  - $$\alpha PHIL_i = \{ \\ i.sitsDown, \\ i.getsUp, \\ i.picksFork.i, \\ i.picksFork.(i \oplus 1), \\ i.putsFork.i, \\ i.putsFork.(i \oplus 1) \\ \}$$
- $0 \le i \le 4 : FORK_i$
  - $$\alpha FORK_i = \{ \\ i.picksFork.i, \\ (i \ominus 1).picksFork.i, \\ i.putsFork.i, \\ (i \ominus 1).putsFork.i \\ \}$$

Поведение философов может быть произвольным, в том числе и достаточно странным (вставать и садиться за стол циклически). В самом простом варианте он будет садиться, брать вилки последовательно, затем класть их и вставать (а дальше можем распараллелить взятие и отдавание вилок и что-нибудь ещё)

В самом простом варианте мы можем записать всю параллельную систему так:
$$
SYSTEM = \\
PHILOS \parallel FORKS = \\
PHIL_0 \parallel PHIL_1 \parallel PHIL_2 \parallel PHIL_3 \parallel PHIL_4 \parallel FORK_0 \parallel FORK_1 \parallel FORK_2 \parallel FORK_3 \parallel FORK_4
$$

В такой версии возникает проблема дэдлока: все философы могут взять по одной вилке, и никто не сможет поесть.

Решений было предложено много. Одни из самых популярных: добавить шестую вилку (Дейкстра) или добавить официанта (Хоар).

Официант будет пускать философа за стол только если за столом меньше 4-х философов

При этом такой официант ещё не решит проблему голодания (aka голодание потоков), когда даже севший за стол философ долго не сможет поесть. Решением этой проблемы станет улучшение официанта: теперь он будет садить философов рядом с уже сидящим при условии, что сидящий взял обе вилки

## Change symbol
*Дальше идёт какая-то непонятная инфа про отображение одних процессов в другие с непонятной целью. Попытаюсь понять на семинаре*

# 24.03.18 - семинар
*Что-то там наверное было, но прям хз*

# 24.03.25 - лекция
**Л.** Процессы $P$ и $Q$, исполняясь параллельно, никогда не попадут в дэдлок, если $|\alpha P \cap \alpha Q| \le 1$

## Недетерминизм
В некоторых процессах мы не можем точно определить, какое наступит вслед за другим событием, в таких случаях для спецификации используются 2 операции:
- Сильный недетерминизм - обозначается $\sqcap$ и означает ситуацию, когда мы делаем выбор совершенно неопределённо ($a \rarr (P(a) \sqcap Q(a))$)
- Слабый недетерминизм (general choice) - обозначается $\square$ - используется в тех случаях, когда кроме недетрминированных веток слева и справа есть различные детерминизрованные пути

Оба оператора, идемпотичны, симметричны и ассоциативны, а также:
- дистрибутивны относительно друг друга и операции параллельности
- $traces(P (\sqcap / \square) Q) = traces(P) \cup traces(Q)$

Слабый недетерминизм возможен только в случае наличия проверочных событий:
- $a \rarr A \space\space \square \space\space b \rarr B = a \rarr A \space\space|\space\space b \rarr B$
- $c \rarr C \space\space \square \space\space c \rarr D = c \rarr C \sqcap c \rarr D = c \rarr (C \sqcap D)$
- Объединяя 2 правила выше, получаем общее правило:
$$
(x : A \rarr P(x) \space\space \square \space\space y : B \rarr Q(x)) = \\
a : (A - B) \rarr P(a) \\
| \space\space b : (B - A) \rarr Q(b) \\
| \space\space c : (A \cap B) \rarr P(c) \sqcap Q(c)
$$

# 24.04.01
Интерливинг двух процессов - абсолютно независимое их исполнение

*Вообще, было тут ещё что-то про сокрытие и дивергенцию, но это ооовер душно и, как мне кажется, малополезно*

# 24.04.08
## Коммуникация процессов
Сообщения передаются по каналам и представляют собой события из пары $c.v$, где $c$ - канал, $v$ - сообщение
- $c!v \rarr P$ - процесс отправляет сообщение $v$ по каналу $c$, а затем ведёт себя как $P$
- $c?v \rarr P(v)$ - процесс принимает сообщение $v$ по каналу $c$ и ведёт себя определённым для этого сообщения образом

После получения сообщение из канала "стирается", то есть если у нас будет несколько получателей у одного и того же канала, то получит сообщение и что-то сможет делать только один из них. Из этого же следует, что нельзя сделать один и тот же канал двунаправленным, так как тогда отправитель сам же будет читать своё сообщение (*на самом деле, если отправитель и получатель обрабатывают разные сообщения, это всё же должно работать, но такой метод достаточно ненадёжен*)

Законы преобразования:
- $(c!v \rarr P) \parallel (c?x \rarr Q(x)) = c!v \rarr (P \parallel Q(v))$

# 24.04.15
## Трубы
Труба состоит из двух каналов: `left` - канал приёма, `right` - канал отправления

`P >> Q` означает, что труда процесса `P` каналом `right` подсоединена к каналу `left` процесса `Q`

**Live lock** - ситуация, когда процесс бесконечно выполняется, не делая ничего полезного

**Left-guarded** процесс - такой, для которого $\# right \le f(left)$

**Right-guarded** процесс - такой, для которого $\# left \le f(right)$

Достаточные условия для отсутствия живой блокировки в трубе `P >> Q`:
- `P` - левозащищённый
- `Q` - правозащищённый

**Подчинение** процесса `P` процессу `Q` обозначается как `label : P // Q`, причём:
- $\alpha P \subseteq \alpha Q$
- `label` - локальное имя для каналов процесса `P` внутри процесса `Q`, то есть в процессе `P` мы можем просто обращаться к каналам, скажем `left` и `right`, а вот в процессе `Q` к тем же каналам мы сможем обратиться как `label.left` и `label.right` соответственно
- Логический смысл операции подчинения в упрощении семантики в тех случаях, когда процесс `Q` контролирует действия процесса `Q`

# 24.04.22
Если у процесса есть особое событие - галочка, *то что-то будет*

Треугольником обозначается прерывание. После него может идти другой процесс или в том числе молния, которая означает какое-то критическое событие

# 24.04.29
`(x = e; P)` - переменной `x` присваивается значение выражения `e`, а затем исполняется `P`

- `acc(P)` - всё множество переменных процессах
- `car(P)` - всё множество переменные, которые изменяются в процессе

