# Инфо
Лектор - 

Семинарист -

# 24.02.05 - лекция
Параллелизм = процессы + коммуникация (*взаимодействие между ними?*)

Коммуникация может проходить через сообщения либо разделяемые переменные

Процесс иногда также называют системой дискретных событий

Процесс описывает:
- Окружение системы
  - Действия системы, машины или человека
  - Общее количество событий или действий, выполняемых системой, и порядок их исполнения
  - Сроки и вероятности
- Некоторые аспекты окружения - абстрактная идеальная картина "реального" окружения
- Наблюдение за поведением
  - Выбранное действие
- Дискретные действия - возникают в различные моменты времени и чётко по ним разделены

Алгебра процессов (**process algebra**) предназначена для формализации окружения. Содержит процессы, удовлетворяющие трём аксиомам:
- `a * (b * c) = (a * b) * c`
- `U * a = a * U`
- `a * a^-1 = a^-1 * a = U`

Простейшие пример - функция ввода-вывода. Более сложные пример - конечный автомат

*Дальше начинает что-то совсем невнятное...*

# 24.02.02 - семинар
- Процесс управляющего алгоритма
- Процесс датчиков индикаторов ( датчики - передача инфы от окр среды к управляющему алгоритму) индикатор -  передаёт инфу от объекта как к среде так и к контроллеру
- Процессы актуаторов - объекты управления
- Процесс пользователя

Выделяете процессы и их состояния

1. Представьте что вы пользователь системы и что вы хотите от системы. Состояние - событие или действие

Вагонетка

Кнопка - датчик , актуатор это штука которая что-то делает конкретно

контроллер - логика 

Датчик - инфа от пользователя или среды к контроллеру

Датчики: открыть закрыть дверь, вызвать вагонетку и тп, вперед назад

Индикаторы : на какой остановке пользователь, это индикаторы тк их не пользователь отправляет

Индикаторы относим к объекту управления

ОТ контроллера в объект управления или контроллер

Актуатор - сущность через которую работает контроллер.

Состояния польщователя: cуществует

Действия: кнопка вызова

Контроллеры нужны только события от кнопок для нажатия

Про требования

Что нужно от системы

Требование безопасности

Требование времени

# 24.02.12 - лекция
## module checking
*Ааа! Как быстро говорит...*

Было что-то про верификаторы... Которые должны проверять... Корректность модели?

Модель для формальной верификации должна содержать всё, что нужно, и ничего лишнего (*вот это поворот*)

**Структура Крипки** - система с конечным множеством состояний, где выделяются начальные состояния, выводятся правила перехода между состояниями

*Как это вообще можно успевать осознавать?!*

*Тут скипнул большой кусок...*

Параллельные программы состоят из комбинации последовательных программ

*Теперь говорит про критические секции со спинлоками*

*Я реально не понимаю смысла этих лекций. Ощущение, будто тут тоже идёт просто ознакомление... Хотя, может дело в том, что я не слушал половину времени?..*

## Линейная темпоральная логика (LTL)
В них определены кванторы, булевы переменные и прочие штуки для логики первого порядка + модальные высказывания и *ещё какая-то штука, то ли аксиомы, то ли ещё что-то*.

Описывают пути в дереве состояний...

Так... Видимо для хоть какого-то понимания этого предмета нужно читать книгу Хоара... Возможно, вместо лекций (**наверняка вместо лекций**)

Теперь мы как-то связываем структуру Крипке с... этой темпоральной логикой. И всё это нужно для верификаторов...

Верификация логики LTL на структуре Крипке - плохая задача, потому что сводится к поиску Гамильтоновых путей.

Для +- быстрого решения задачи используется табличный алгоритм Лихтенштейна, который позволяет строить структуру на основании формул (*за последнее утверждение не ручаюсь*)

# 24.02.12 - Семинар
Структура Крипке:
- Состояния
  - Начальные состояния
- Переходы

На практике для построения структуры Крипке мы берём процесс, а потом его процессы-состояния и соединяем их переходами логичным образом, при этом у нас могут быть состояния с одинаковыми именами, если того требуют логика процессов (соответственно)

**Из состояния есть хотя бы один переход**

Темпоральные операторы в логике LTL (определены на бесконечных последовательностях):
- X (next) - выбрасываем первый элемент последовательности, со следующего постфикса
- G (globally) - формула верна для всех постфиксов
- F (future) - когда-нибудь формула будет верна для постфикса

Псевдокод для семинаров:
- `{ a_1 ; a_2 ; ... ; a_n }` - последовательные команды
- `{ a_1 | a_2 | ... | a_n }` - произвольное исполнение
- `{ a_1 || a_2 || ... || a_n }` - параллельное исполнение
- `:=` - присваивание
- `while b do a` - цикл
- `if a then b else c` - ветвление
- `LABEL:` - брэйкпоинты
- `wait(condition)` - пока условие ложно, ждём (эдакий спинлок)

Задача: в комнате 2 комара, хотя бы один зудит всегда
```
{Z1 || Z2}

Z1:
while True do
  if (buzz2)
    {buzz1 := true; | buzz1 := False;}
  else
    buzz1 := true;

Z2:
while True do
  if (buzz1)
    {buzz2 := true; | buzz2 := False;}
  else
    buzz2 := true;
od
```
*Код хреновый с незащищённой критической секцией*

*Дальше была прям жуть про семантическое представление программ*

**Разговор о домашке!!!**

# 24.02.19 - лекция
## Язык Promela и система верификации SPIN
Promela - Process meta language. Основные объекты в нём: процессы, объекты и каналы сообщений

Процесс объявляется словом `prototype`

Запуск будет либо за счёт префикса `active` при объявлении, либо за счёт слова `run` перед именем процесса (aka имя функции). 

Процесс `init` имеет `_pid` 0 и всегда запускается в начале

*Добавить примеры кода из лекции*

Переменные бывают глобальными (объявляются вне процессов) и локальными. Нет понятия области видимости.

Массивы мерностью больше одной можно задать только с помощью `typedef`

*Большой скип*

Есть каналы оператором `chan`. Отправка сообщений через `!`

*Ещё скип*

Есть оператор `atomic {op1; ope2; ...;}`, после которого идёт блок который будет гарантированно выполнен атомарно (все другие процессы, работающие с глобальными переменными, упомянутыми в этом блоке) и засыпают (*а точно ли...*)

*Ну и дальше много чего ещё было, однако всё это есть в презентации, так что буду потом из неё читать по необходимости*

# 24.02.19 - семинар
Цикл until `p U q` работает так: выполнятся `p` до тех пор, пока не наступит `q` 

Слабый until (`W`) отличается от сильного тем, что терм в теле цикла может выполняться вечно, тогда как для `U` мы гарантируем, что цикл однажды закончится