# 23.09.13 - лекция
**Проект** - ограниченная во времени и ресурсах деятельность с целью создания какого-то продукта.

## Итеративный процесс разработки
Быстро делаем новые версии проекта, пусть даже и без внедрения большого количества изменений. Благодаря такой тактике мы можем без больших потерь отловить возникшие ошибки.

## Как сделать проект и не умереть?
- Наладить коммуникацию в команде
- Использовать единый стиль кода
- Используйте git! (*будто бы вообще можно без него*)
- Используйте таскменеджер (основной - Trello)
- Использование CI/CD

## Как готовить первичную презентацию? (vision)
Весь проект необходимо разделить на атомарные действия, которые не будут раскрываться подробно при первичном описании - они будут описаны общими чертами.

**Vision** - документ на 1 лист А4, который должен показать всем участникам проекта и заинтересованным лицам:
- Проблема, с которой поможет ваше решение
- Какую задачу решает проект
- Идея для решения (как именно решать)
- Как будет использоваться продукт (продумать usage cases)
- Конечный результат

## Артефакты
Это сущности, которые так или иначе помогают 

# 23.09.20 - лекция
## Распространённые проблемы при создании проекта
- Чёткое определение проблем и задач - если на этом этапе разработчик и заказчик не могут договориться, лучше завершить всё на этом этапе
- Чаще всего разработчик не разбирается в той предметной области, для которой пишет программу - это решается путём сильного разделения обязанностей на множество ролей, которые распределяются между участниками проекта

# 23.09.27 - лекция
Требования разделяются на функциональные и нефункциональные:
- Функциональные
  - Что наша программа должна делать
- Нефункциональные
  - Что мы можем для этого использовать (окружение)
  - Производительность
  - Расширяемость
  - Безопасность
  - Отказоустойчивость

- Не противоречат ли отдельные функциональные требования друг другу?
- Полны ли требования?
- Выполняют ли функции поставленную задачу

## Use-case
**Use-case** - описание возможной последовательности взаимодействий между обсуждаемой **системой** и **актором**, относящихся к конкретной задаче.

**Актор** - роль внешней сущности, которая как-то себя ведёт и как-то взаимодействует с или под влиянием нашей **системы**

Документирование use-case'ов (обязательные пункты выделены **жирным**):
- **Имя**
- **Актор(ы)**
- **Цель(-и)**
- Триггеры - после чего должен начаться сценарий
- Предусловие/контекст - дополнительные условия для начала сценарий (*пользователь авторизован и т.п.*)
- Расширения - описание точек, в которых может произойти дополнительный сценарий, содержит ссылки на другие use-case'ы
- **Основной сценарий достижения цели**
- Альтернативные сценарии

*Пример:*
- Имя - Снять деньги в банкомате
- Акторы - клиент, банк (*он будет входить в акторы, если мы рассматриваем как систему только банкомат*)
- Цель - Получить деньги
- Условие - у клиента есть карта *банка*
- Основной сценарий:
  - *Тут мы описываем, что и как должно происходить*

Сценарии удобно описываются через UML-диаграммы.

Не все цели подходят для use-case'ов. Для классификации целей подходят уровни моря:
1. Стратегические цели - цели важны для актора, но не могут быть выполнены системой по чёткой последовательности действий (*Мне нужны деньги, чтобы сходить в столовую*). Хорошо подходят для высокоуровневых use-case
2. Цели уровня моря - цели важны для актора и могут быть достигнуты системой. Самый лучший вариант для **главного сценария use-case'а**
3. *Дно (?)* - Какая-то глубинная штука, подцели и дополнительные сценарии

Часто повторяющиеся части сценария можно вынести в один use-case и дальше в сценариях просто указывать на него. Зачастую цель таких use-case непосредственно не даёт чего-то акторам, ну является важной частью сценария use-case-родителя.

## Software requirements specification 
Шаблон документа:
1. Авторы
2. Вступление с описание главной цели
3. Словарь - описание всех неочевидных терминов
4. Описание акторов - чёткое определение, описание ролей
5. Use-cases по тем пунктам, что описаны [выше](#use-case)
6. Дополнительные общефункциональные требования - функционал, используемый во многих use-case'ах. например, авторизация
7. Нефункциональные требования

# 23.10.04 - лекция
## Основы Python (*нахуя я пришёл на пару?..*)
Эмпирический факт: **90% времени тратится на 10% кода**. Из этого следует, что можно 90 процентов кода писать на простом языке вроде Питона.

*Фан факт:* деление нацело (`//`) на дробное число даст корректный ответ, но не интовый, а также дробный

Питон структурный, но не блочный, то есть даже если мы объявили переменную внутри отступа ифа или цикла, то эту переменную можно будет использовать снаружи (что, однако, очень небезопасно)

**"Отравленное Си сознание"** - это когда твой мозг слаб, немощен и не готов полностью отдаться простоте и наглядности Питона. Иначе говоря, не стоит использовать использовать что-то вроде `for i in range(len(arr)):`, стоит брать сами значения либо преобразовывать массив в словарь. `for elem in arr:`

Типы сборки мусора:
1. Подсчёт ссылок
2. Mark and sweep - помечает объекты как живые. Используется в Java
3. Питон использует нечто смежное между первыми двумя методами, за счёт чего потребляет меньше памяти

*Если в списковой сборке поставить вместо `[]` `()`, то мы получим ленивый генератор*

# 23.10.11 - лекция
## Продолжаем про Питон
В Питоне есть 3 сущности ~~в виде гномика~~, которые позволяют ограничивать область видимости: функции, классы и модули.

`import module_name` - сначала ищет `module_name.py` (либо папку с `module_name/__init__.py`) в текущей директории, затем в директориях из списка `PYTHONPATH`.

*Рассказывает про виртуальное окружение (`venv` и т.п.)*

Из Питона можно обращаться к .dll или .so сишным файлам, если дописать для них определённую обёртку

### `NumPy`
Производит сложные вычисления куда быстрее обычного Питона

Массивы в NumPy `array` должны быть фиксированной длины и содержать элементы одного типа.

Что можно делать с массивом (а ещё лучше воспринимать их как матрицы):
- Умножать на скаляр через `arr * num`. А ещё аналогичным образом будут работать почти все другие операторы:
  - также тривиально работают возведение в степени: `1 / arr`, `arr ** 0.5`
  - `arr = num` - весь массив станет `num`ами 
- Поэлементно сложение, умножение, вычитание через `arr + arr`, `arr * arr` и `arr - arr`
- `.ndim` - число размерностей
- `.shape` - кортеж размерностей с длиной каждого измерения
- `.dtype` - тип элементов
- `.astype(nptype)` - возвращает массив с новым типом (*если смог привести, конечно*)
- Преобразование строк в числа (не успел записать функцию)
- `.T` - транспонированная матрица
- `.reshape(newShape)` - выводит массив с новыми размерностями и измерениями (если их кол-во поменялось)
- `.mean([axis])` - номер оси укажет, по какой координате (измерению) мы хотим искать среднее
- `.sum([axis])`
- `.sort()`
- `.any()` / `.all()` - ИЛИ, И для всего массива


Другие методы `numpy` (считаем, что импортировали модуль как `import numpy as np`):
- `np.zeros(10)` / `np.zeros((dim1, dim2, ...))`
- `np.arange(range)` - создаёт массив похожим образом на `range()`
- `np.randn(n)` - массив случайных чисел длины `n`
- `np.array(list)` - пытается создать массив из питоновского листа
- `np.asarray(arr)` - если массив numpy, копирует его, иначе работает как `array`
- `np.zeros()` / `np.zeros_like` (либо теж штуки, но с `ones`) - создаёт массив нулей/единиц указанных размеров либо (версия с `_like`) создаёт массив нулей/единиц таких же размеров, как переданный массив
- `np.dot(arr1, arr2)` - матричное умножение
- `np.where(conditions, fst, snd)` - итерируется по всем трём
- `np.unique(arr)` - возвращает массив уникальных элементов
- `np.inId(arr, finds)` - возвращает массив размера `arr` с буелвыми значениями, где `true` будет на тех местах, где стоит какое-то из значений из `finds`
- `np.save("arr_name", arr [kwargs])` - сохраняет массив `arr` в файл `arr_name.npc`. Можно указать несколько массивов в качестве именованных аргументов
- `np.load(filename)` - возвращает массив из файла. Если через `save` было сохранено несколько массивов, то будет возвращено подобие словаря, в котором ключами выступят имена параметров из `kwargs`

*Фан факт:* в numpy есть тип комплексных чисел (`complex64/128/256`).

Ещё есть типы `string_`, `unicode_`. Остальные достаточно тривиальны.

На массивах numpy также работают слайсы. Для n-мерного массива можно делать слайсы по всем измрения от младшего к старшему (пропускать измерения нельзя). Например, для двумерного массива запись вида `arr[:, i:i+1]` будет возвращать `i`й столбец

# 23.10.18 - лекция
## Задачи
- У задачи есть цель (зачем эта задача выполняется) и результат (что мы хотим получить после выполнения задачи)
- Ограничена по времени/ресурсам (в т.ч. людским)

В больших проектах и компаниях зачастую подбирается исполнитель под задачу, тогда как в маленьких проектах задачи создаются самими исполнителями, исходя из их способностей и ресурсов.

Минимальной должна быть такая задача, которая выполнима максимум за один квант отчётности (неделя, день и т.п.). В идеале мелких задач можно выполнить несколько за день, а саму крупную отдельную задачу - за 2-3 дня.

Особенности IT-задач:
- Интеграция с СКВ
- Различные метрики результатов задач, CI/CD
- Сильное разделение по ролям

# 23.10.25 - лекция
## Time-management
Функции мозга:
- Базовая жизнедеятельность (в т.ч. рефлекторная)
- Обработка информации
- Сложное управление (движение)
- Память
- Планирование и принятие решений - как сделать что-то, чтобы прийти к результату (кошка ловит мышей). Больше всего процесс принятия решений развивался у хищников. Моделирование развития ситуации на основе знаний о мире и поступающей информации (память + обработка информации)
- Сознание - понимание положение себя как внутреннего мира ("я") во внешнем мире и понимание причинно-следственных связей (чем больше мы понимаем устройство мира, тем больше мы осознаём себя в окружающем мире)
- Мышление - возможность синтезировать новые знания (во многом это реверс-инжиниринг)

Цели мозга - выживание и воспроизводство

У человека почти нет поведенческих рефлексов (поведение почти полностью продиктовано социумом)

Потребность - то, что исходит изнутри

Мотивация приходит снаружи и порождает потребность

Мозг отвечает за менеджмент потребностей по их актуальности, однако делает это плохо:
- Выбирает самое комфортное решение, чтобы тратить меньше ресурсов
- Выбирает шаблонное решение
- Отбрасывает слабые потребности (без сильных внешних стимулов)
- Хочет прокрастенировать

Мозг как орган и сознание во многом конфликтуют, так как потребности мозга куда проще и не требуют сильных усилий. Мозг очень сложно победить

Практики - рекомендации по совершению каких-либо действий, которые появились из знаний и опыта других людей, которые имеют осознанную причинно-следственную связь. Практики не нужны мозгу, но нужны сознанию

### Основные практики менеджмента времени
- Сон по расписанию
- Life as projects set - рассматривать жизнь как набор проектов
  - Совершать осознанные действия в рамках какого-либо проекта

#### Списки дел
**Основные моменты:**
- Основная цель - отобрать у мозга функцию желания и хранения плана. Благодаря этому цели становятся осознанными
- Речь о простом списке, не связанном с календарём
- Задача должна быть детерминированной
- Список необходимо ежедневно обновлять, можно менять их в любое время
- Использовать единый список для всего
- Дополнять по мере появления задач

**Проблемы:**
- Коллапс планов - форс-мажоры никто не отменял, к ним надо быть готовым, выкинуть прежний список или переработать его
- Эмоциональное выгорание - надо его пересиливать (*звучит как плохой совет*)
- Перегрузка и лимиты - не обязательно давать делам какие-то лимиты на выполнение (вернее, не обязательно давать их всем). Список нужен, чтобы мы помнили обо всех задачах, а не загонялись себя по максимуму
- Добавление дел в список после выполнения - может быть приносить чувство сатисфакции, но лишено всех разумных резонов, описанных выше

<hr>

# 23.11.13 - встреча с куратором
## SRS
- Вступление - для гуманитариев
- Глоссарий - ВСЕ ТЕРМИНЫ сложнее 2+2
- Акторы - любые действующие лица, так или иначе соприкасающиеся с системой

# 23.11.15 - лекция
## Ближайшие планы по ПАКу
### Презентация проекта
- 7 минут
- На английском
- Рассказать о цели проекта
- Показать прототип
- ПРЕЗЕНТАЦИЯ ИЗ СЛАЙДОВ ОБЯЗАТЕЛЬНА

# 23.11.20 - встреча с куратором
## ЛинАл
Вектор - направленный отрезок, точка в пространстве

Матрица - преобразование в пространстве. При умнонжении матрицы на вектор мы получим новый вектор

Единичная матрица (Identical matrix) - единицы на главной диагонали, остальное - нули. Преобразует пространство в самого себя.

Матрица-скаляр (Scalar matrix) - на главной диагонали какая-то константа ($r \int \R : I*r$). Преобразование - масштабирование.

Матрица off-one - на главной диагонали все единицы, кроме одного значения, остальное - нули. Преобразование - растяжение вдоль оси не равной единице. Если взять отрицательное значение,  пространство будет отражаться относительно НЕ ОТРИЦАТЕЛЬНЫХ ОСЕЙ.

Умножения матриц **НЕ СУЩЕСТВУЕТ**. Когда мы производим "умножение", мы на самом деле производим композицию двух преобразований. 

Просто диагональная матрица - на главной диагонали какие-то числа, остальное - нули.

Нулевая матрица - всё нули. Преобразование схлопывает пространство.

Трансвекция (shearing matrix) - матрица, у которой на главной диагонали единицы, а одно значение вне диагонали равно какому-то скаляру. Преобразование - смещение в разные стороны сверху и снизу от той оси, в строке которой записан скаляр

Ортогональная матрица - матрица NxM, в которой каждый столбец - единичный вектор (длины 1) и все векторы попарно ортогональны (скалярное произведение даёт 0)

Матрица вращения - ортогональная единичная матрица, дающая преобразования вращения

Обратная матрица даёт своим преобразованием отмену исходного преобразования

Матрица проекции даёт преобразование, понижающее мерность пространство. (прямую из плоскости отобразит на одну прямую из этой плоскости)

# 23.11.22
## Системы контроля версий
Очень быстро появились централизованные системы контроля версий, но, как и у локальных, у них была проблема в единой точке отказа - при поломке центральной машины вся история изменений была бы поломана.

Следующей ступенью развития стали децентрализованные системы контроля версий

## Git
**Git** в самой своей основе представляет мапу ключ-файл. Ключ в формате хэша SHA-1 называется ссылкой отсылается к git-объектам:
- blob - binary large object (аналог файла)
- tree - что-то вроде каталога файловой системы
- commit - самая сложная структура, которую рассмотрим отдельно

**Commit** содержит в себе:
- Корневое дерево (snapshot) - описание структуры репозитория с самого его корня, 
- Родителя - ссылка, по которой можно получить другой коммит-объект
- Автора
- Комиттера
- Сообщение 

**Ветка** - человекочитаемое название для ссылки, ссылающейся на конкретный коммит

**Тэг** - переменная, содержащая указатель на указатель (то есть тэг будет указывать на ветку... *Звучит странно, но тэги я всё равно почти не использую, однако, возможно, имеет смысл это погуглить*)

Работа с файлами гита связана с несколькими зонами:
- Working area - в ней находятся файлы нашей файловой системы
- Staged area - сюда изменённые файлы добавляются после вызова `git add`. На этом этапе создаются git-объекты, кроме коммита
- local repo - здесь хранятся коммиты. Сюда будут добавлены изменения из staged area после `git commit`
- remote repo - версия репозитория на выделенном сервере

**Merge-commit** - коммит, у которого 2 слитых родителя, то есть коммит будет отражать общее состояние репозитория после совмещения двух коммитов

## ПРАВИЛА ХОРОШЕГО ТОНА ДЛЯ ГИТА (ЗАПОМНИТЕ ИХ КАК ОТЧЕ НАШ, ИНАЧЕ ВАС ПОКАРАЕТ ШАДРИНА, ИРТЕГОВ, Я И КАРМА)
(c) Майкл Эрнст

1. Сообщение коммита должно описывать изменения в коммите
2. Каждый коммит - атомарная логическая единица, то есть содержит только логически связанные изменения
3. Избегайте сверх больших коммитов - даже в рамках одной логической атомарной единице имеет смысл сохранять изменения по чуть-чуть
4. Синхронизируйтесь как можно чаще (`git pull` каждый день)
5. Делитесь своими изменениями часто (`git push`)
6. Не следует коммитить сгенерированные файлы (в первую очередь речь о билд-файлах)

# 24.02.14 - лекция
## SAD - Software architecture document
Если у нас возникает вопрос о работе какого-то компонента, которая не была специфицирована, значит они будут отнесены к архитектурным. Также к ним всегда будут относиться неверифицируемые требования, например, скорость работы, погрешность, user-friendly интерфейс

Другие примеры архитектурных требований:
- Количество одновременно работающих с продуктом пользователей

**Отличия от нефункциональных требований**: при несоответствии им продукт не сможет работать вовсе. Архитектурные же требования не влияют на работу продукта напрямую, но являются желательными

Для всех проектов должен быть заполнен SAD:
- Авторы
- Цели
- Под. цели и/или ограничения
- Сценарии достижения цели для каждой из них
- Описание модулей системы

# 24.03.20 - лекция
## Системное программирование
"Системные программисты не решает прикладные задачи, оно делает так, чтобы прикладным программам было легче выполнять задачи"