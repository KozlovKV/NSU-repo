# 24.02.17 
Kubernetes можно описать как распределённые операционные системы.

Используется для множества задач, для которых важна параллельная работа множества задач: CI/CD, машинное обучение, бэкэнд большинства серьёзных приложений

Обеспечивает не только более эффективную работу, но и повышенную безопасность, защищая отдельные компоненты друг от друга и давая персистентность

Требования к kubernetes:
- Лёгкость добавления/удаления узлов
- Отказоустойчивость
- Балансировка загрузки
- Персистентные данные
- Мониторинг и диагностика
- Изоляция

## Устройство и терминология
Работающие в кластере машины называются нодами, которые делятся над рабочие и управляющие (мастера или control plane). На нодах даже могут стоять разные ОС и быть выбраны разные архитектуры.

Мастера могут не быть частью кластера

Компоненты kubernetes:
- Etcd - "сердце и желудок" kubernetes. Транзакционная распределённая база данных из одной таблицы. Похожа на хэш-таблицу и хранит состояние кластера на данный момент времени
  - Из распределённости следует, что Etcd есть свой кластер
- API server
  - Все операции над кластером проходят через него
  - Все запросы заключаются в создании/изменении/удалении каких-то объектов либо их просмотре
  - Предоставляют json и другие форматы для взаимодействия с компонентами и пользователями
- Kube-scheduler - занимается планированием задач (подов)
  - Опрашивает ноды на предмет доступных ресурсов, чтобы выбрать нужную
  - Следить за состоянием поды и, при необходимости, перезапускает его
- Kube-controller-manager - содержит множество контроллеров
  - node-controller
  - job controller - управляет заданиями по расписанию
  - endpoint controller - отслеживает сервисы, предоставляемые людям и связывает с ними нужные поды
  - service account & token controller - отвечает за учётные записи
    - *Отсылается на single sign model (SSM) и советует её изучить*
  - cloud-controller-manager - отвечает за общение с облачными сервисами, масштабирование (временное добавление нод определённого типа и т.п.)
  - etc.
- Компоненты для каждой ноды:
  - kublet - запускается на каждой ноде и отвечает за её связь с мастер-нодами
  - kube-proxy и CNI plugin - отвечают за связывание нодов в единую сеть
  - container-runtime

*Добавить картинку всей системы из презентации*

Утилиты для управления kubernetes:
- kubectl - классическая ctl тулза
- kube dashboard - под, живущий прямо в кластере и дающий вэб-интерфейс со статистикой

При этом API kubernetes полностью документирован, поэтому легко можно создать свои тулзы

## Технология виртуализации
Виртуализация используется ещё более широко: уже не только на серверах, но и на персональных компьютерах (*запускаем Windows на Mac и подобные приколы*)

Позволяют более эффективно использовать железо

Предшественником полноценной виртуализации стала концепция виртуальной памяти

В связи с появлением виртуальной памяти возникла необходимость запускать программы, написанные для систем с базовой адресацией. Так появились первые гипервизоры и полноценные технологии виртуализации

*Добавить скрины*

Гипервизоры делятся на 2 типа:
- Тип 1: могут работать напрямую с железом
- Тип 2: располагающиеся в ядре, перехватывающие исключения отправляемые ядром процессу гостевой ОС и симулирующие вместо них результаты корректной работы (trap & emulate)

*Дописать про критерий Попика-Голберга*

### Варианты реализации виртуализации
- Классическая (trap & emulate)
- Покомандная интерпретация (то есть пишем свою систему, начиная с ассемблера)
  - Очень медленный способ, зато через него можно сделать что угодно (в т.ч. эмулировать один процессор на другом)
- Бинарная компиляция (JIT-компиляция)
  - активно используется для прикладных программ
  - с использованием для компиляции ядер, однако, это сомнительный вариант, потому что сложно сохранить контекст прерываний
- Паравиртуализация
  - Специальная сборка ядра гостевой ОС, которая будет знать, что она гостевая. Такой вариант позволит ядру гостевой ОС сразу обращаться не к внешним устройствам и чему-то подобному, а сразу к гипервизору
- Контейнерная - *о них будет отдельно ниже*

*Тут описывал примеры прог для виртуализации и преимущества/особенности каждой из них*

Недостатки большинства методов:
- Производительность ввода-вывода (решается утсновкой гостевых драйверов)
- Производительность операцией по работе с виртуальной памятью
- Промывание кэша, конкуренция за системную шину
- Таймеры TCP/IP - без дополнительных ухищрений рискуем устанавливать соединение с большой задержкой либо не устанавливать его вовсе

### Контейнерная виртуализация
- Остаётся одно ядро (нет никакого гостевого)
- Каждый процесс работает в своём пространстве имён (namespace) и не имеет доступа к другим нэймспэйсам. Для каждого процесса есть несколько нэймспэйсов:
  - PID namespace - тут всё ясно
  - mount namespace - пространство имён монтирования ФС
  - web namespace - определяет, как контейнер с этим пространством имён будет маршрутизироваться

За счёт того, что ядро остаётся одно, мы избегаем большинства проблем, описанных выше

Docker - не вдаваясь в детали и особенности других прог для контейнерной виртуализации, отмечу, что особенность контейнеров докера в том, что они предназначены для запуска в контейнрах отдельных приложений