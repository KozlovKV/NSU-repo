- [Инфо](#инфо)
- [23.09.06 - семинар](#230906---семинар)
  - [Базовые понятия в prolog](#базовые-понятия-в-prolog)
- [23.09.08 - лекция](#230908---лекция)
- [23.090.13 - семинар](#2309013---семинар)
  - [Списки](#списки)
  - [Дополнительный арифметический модуль](#дополнительный-арифметический-модуль)
- [23.09.15 - лекция](#230915---лекция)
  - [Предикаты для управления исполнение программ](#предикаты-для-управления-исполнение-программ)
  - [Рекурсия](#рекурсия)
- [23.09.20 - семинар](#230920---семинар)
  - [Оператор отсечения (cut, `!` - *надеюсь, теперь человечески*)](#оператор-отсечения-cut----надеюсь-теперь-человечески)
- [23.09.22 - лекция](#230922---лекция)
  - [Экспертные системы](#экспертные-системы)
  - [Структура типовой экспертной системы](#структура-типовой-экспертной-системы)
  - [ЭС в Prolog](#эс-в-prolog)
  - [Сетевая модель](#сетевая-модель)
- [23.09.29 - лекция](#230929---лекция)
  - [Продолжаем про сетевые модели и формальные системы](#продолжаем-про-сетевые-модели-и-формальные-системы)
- [23.10.04 - семинар](#231004---семинар)
- [23.10.06 - лекция](#231006---лекция)
  - [Сетевая модель](#сетевая-модель-1)
    - [Типы семантических сетей](#типы-семантических-сетей)
    - [Классификация отношений](#классификация-отношений)
    - [Достоинства и недостатки](#достоинства-и-недостатки)
    - [Функциональная сеть](#функциональная-сеть)
    - [Фреймы](#фреймы)
- [23.10.11 - семинар](#231011---семинар)
  - [Экспертные системы](#экспертные-системы-1)
    - [Goal-driven backward](#goal-driven-backward)
    - [Data-driven forward](#data-driven-forward)
    - [Смешанный вывод](#смешанный-вывод)
- [23.10.13 - лекция](#231013---лекция)
  - [Продукционная модель](#продукционная-модель)
    - [Программные продукционные системы](#программные-продукционные-системы)
    - [Стратегии применения](#стратегии-применения)
    - [Классификация систем продукции](#классификация-систем-продукции)
      - [Простые СП](#простые-сп)
      - [Управляемые СП](#управляемые-сп)
    - [Плюсы / Минусы СП](#плюсы--минусы-сп)
    - [Использование СП](#использование-сп)
- [Что надо на КР](#что-надо-на-кр)
- [23.10.25 - семинар](#231025---семинар)
  - [Пример экспертной системы с юзер-интерфейсом](#пример-экспертной-системы-с-юзер-интерфейсом)
  - [Семантическая сеть на prolog](#семантическая-сеть-на-prolog)
- [23.10.27 - лекция](#231027---лекция)
  - [Нечёткие модели](#нечёткие-модели)
    - [Использование нечёткой логики в ЭС](#использование-нечёткой-логики-в-эс)
- [Ещё раз о КР](#ещё-раз-о-кр)
- [23.11.01 - семинар](#231101---семинар)
  - [Реализация ЭС с гибридным подходом с UI](#реализация-эс-с-гибридным-подходом-с-ui)
- [23.11.03 - лекция](#231103---лекция)
  - [генетические алгоритмы](#генетические-алгоритмы)
- [23.11.08 - семинар](#231108---семинар)
- [23.11.10 - лекция](#231110---лекция)
  - [Искусственные нейронные сети](#искусственные-нейронные-сети)
    - [Обучение нейронки](#обучение-нейронки)
    - [Применение нейронных сетей и их типы](#применение-нейронных-сетей-и-их-типы)
- [23.11.15 - семинар](#231115---семинар)
- [23.11.17 - лекция](#231117---лекция)
  - [Методы поиска](#методы-поиска)
    - [Алгоритмы поиска по графам](#алгоритмы-поиска-по-графам)
    - [Метод редукции](#метод-редукции)
- [23.11.22 - семинар](#231122---семинар)
  - [Алгоритмы поиска](#алгоритмы-поиска)


# Инфо
Лектор - Загорулько Виктор Алексеевич

Семинарист - Серый Алексей Сергеевич

# 23.09.06 - семинар
Логическое программирование - парадигма, являющаяся вариацией декларативного программирования, основанная на логике предикатов (высказывание, *привет, дискретка!*). Программа в этой парадигме обычно работает лишь с заданными данными и не содержит внешней логики (связей с другими кусками кода и т.п.)

Используется для удобного отображения баз знаний, логических выводов, обработки естественных языков и т.п.

Логическое программирование позволяет создавать ИИ, работающий по формальной логике, то есть основанный на чёткий правилах и делающий выводы в их рамках.

Программы в парадигме логического программирования очень сложно масштабировать, так как количество необходимых к прописыванию правил растёт экспоненциально.

## Базовые понятия в prolog
- `Fact` - используются для обозначения безусловной истины
- `Rules` - выражения, которые могут быть правдой
- `Knowledge base` (`database`) - набор правил и фактов. База знаний - это и есть программа на прологе. Взаимодействие с ней происходит через написание запросов (`queries`)
- `Query` - это запрос (*неожиданно*). Пролог проверяет, может ли быть ответом на запрос `true`. Если да, то выводит все значения переменных (`variables`), при которых это так, иначе отвечает `false`

Простейшая `database` выглядит так:
```prolog
kind(fruit, orange).
kind(fruit, apple).
kind(veg, tomato).
kind(veg, carrot).
color(red, apple).
color(red, tomato).
color(orange, orange).
color(orange, carrot).
```
Запросы к ней:
```prolog
?- kind(veg, X).
// X = tomato
// X = carrot

?- color(orange, X).
// X = orange
// X = carrot

?- kind(veg, X), color(Y, X).
// X = tomato,
// Y = red
// X = carrot,
// Y = orange
```

Пример с базовыми логическими операторами:
```prolog
playsGames(kirill).
playsGames(artyom).
playsGames(igor).
donates(kirill).
donates(artyom).
donates(dima).

hardGamer(G) :-  playsGames(G), not(donates(G)).
anyGamer(G) :- playsGames(G) ; donates(G).
```
Запросы:
```prolog
?- hardGamer(kirill).
// false

?- hardGamer(X).
// X = igor

anyGamer(X).
// X = kirill
// X = artyom
// X = igor
// X = kirill
// X = artyom
// X = dima
```

Отсюда можно заметить следующие обозначения:
1. `,` - И
2. `;` - ИЛИ
3. `:-` - $\larr$ (обратная импликация)
4. `!` - **?**

Если правило записать в несколько строк, то оно будет работать как pattern-matching

**Terms** (выражения) в Прологе строятся из атомов, чисел, строк, переменных и других термов:
- Атом - произвольный набор символов без пробела с маленькой буквы либо **абсолютно** произвольный набор символов в **одинарных** кавычках либо спецсимволы
- Числа - целые и вещественные (*через точку, ваш кэп*)
- Переменные - строка без пробела, начинающаяся с большой буквы либо `_`, либо **абсолютно** произвольная строка в **двойных** кавычках

Составные выражения должны называться термом-**атомом**, аргументы должны идти через запятую в скобках и могут быть термом любого типа (да-да, хоть числом)

# 23.09.08 - лекция
*У препода лёг комп из-за флэшки. Скайнет победил*

Все определения ИИ так или иначе сводятся к системе, способной моделировать традиционно считающиеся творческими задачи.

Существует 2 подхода к моделированию мышления:
1. Символьный (логический) - оперирование символами и понятиями, построение формальных моделей и соответствующих им механизмов рассуждений
2. Нейросетевой - строится на идее, что на мышление способен только человеческий мозг, а значит основная цель - построить модель человеческого мозга из нейронов и связей между ними, то есть создать нейронную сеть

Используется ИИ во многих областях: представление знаний, распознавание языка, синтез речи и изображений, анализ данных, экспертные системы.

Машинное обучение - методы ИИ, суть которых заключается не в прямом решении задачи, а в решении подобных задач. Используется для них много разных методов: матстат, графы, тервер и т.п.

Объяснимый ИИ - набор методов, позволяющий понять, почему алгоритмы машинного обучения пришли к определённому выводу.

В правилах можно использовать и простое равенство:
```prolog
likes (beth, X) :–
  likes (mаrу, X),
  X = popcorn. 
```

# 23.090.13 - семинар
## Списки
Элементами терма могут быть атомы, переменные, термы и списки.

`|` отсоединяет голову от хвоста (*да-да, как в Haskell*). При этом можно в качестве головы взять несколько элементов: `f([X, Y, Z | Tail])` - взять 3 первых элемента. При попытке взять больше элементов, чем есть в массиве, возвращается `false`

Предикат `member(x, [...])` возвращает `true` столько раз, сколько в списке встречается атом `x`. Можно проверять как предикат в обе стороны: то есть проверять, входит ли элемент в список, а также в какие списки будет входить элемент.

Собственная реализация `member`:
```pro
mem(X, [H|TAIL]) :- X = H ; mem(X, TAIL).
```
При этом нет необходимости прописывать вариант `mem(X, []) :- fail.`, так как всё не прописанное в прологе считается ложью.

`append(a, b, c)` - истина `<=>` список `c` - конкатенация `a` и `b`. При разных запросах эта операция может не только объединять списки.

Собственная реализация `append`:
```pro
app([], [], []).
app([], [B|BTail], [B|RTail]) :- app([], BTail, RTail).
app([A|ATail], BTail, [A|RTail]) :- app(ATail, BTail, RTail).
```
Здесь ещё несколько фишек Пролога:
- Записи из одного лишь правила **истинны всегда** (*если задуматься, то и логично, ведь так и строятся базы знаний из всех примеров выше*)
- Указав одну и ту же букву в правиле в нескольких местах, мы сразу говорим, что значение на этих местах **должно быть равно**

*А на самом деле можно сделать запись ещё короче и приятнее (хотя последнее немного спорно)*
```pro
appnd([], B, B).
appnd([A|ATail], B, [A|R]) :- appnd(ATail, B, R).
```

Используя конкатенацию, можем добавить много разных предикатов:
```pro
end(E, L) :- appnd(_, [E], L).

leftShift(S, [L|Tail]) :- appnd(Tail, [L], S).
```

## Дополнительный арифметический модуль
Стандартная арифметика пролога обязательно требует определённых чисел, поэтому вместо неё используется библиотека `clpfd`. Для подключения библиотеки в начале кода надо написать `use_module(library(clpfd)).` (*это библиотека для целых чисел, для плавающих используется `clpr`*)

Перед многими символами операций пишется `#`:
```pro
?- X is 3 + 5. // Стандартная математика
// X = 8.
?- X #= 3 + 5. // Вывод будет таким же

?- 8 is X + 5. // Ошибка
?- 8 #= X + 5.
// X = 3.
```

# 23.09.15 - лекция
## Предикаты для управления исполнение программ
Выполнение пролог-программы основывается на дереве решений.

Чтобы сократить количество просматриваемых вариантов, используются предикаты `fail` и cut (`!`)

В прологе используется **отрицание по невыполнимости**, то есть утверждение истинно тогда и только тогда, когда мы можем доказать его на основании имеющихся фактов.

Предикат `!` *до сих пор до конца не понятен*, но вроде как если слева от `!` истина, то поиск в дереве решений будет приостановлен, иначе поиск решений продолжится.

## Рекурсия
Группа правил с одним и тем же именем называется **процедурой**.

По классике в рекурсии содержится базис и шаг.

Как и везде, рекурсия очень жёстко ест стэк, поэтому используется **хвостовая рекурсия**. 

*Краткое напоминание:* хвостовая рекурсия основывается на вычислении при **движении вглубь**, чтобы на обратном пути мы могли просто возвращать итоговое значение на самый верх.

В отличие от операторов строгости в Haskell, здесь для работы хвостовой рекурсии требуется делать рекурсивный вызов в самом конце (*ну и создавать накопительный параметр, ясное дело*).

# 23.09.20 - семинар
## Оператор отсечения (cut, `!` - *надеюсь, теперь человечески*)
Оператор `cut`, если мы дошли до него по дереву решений, фиксирует путь по дереву выше и не проверяет альтернативные пути, лежащие выше. Это позволяет сделать эффективным поиск решений, но лишает предикат полноты, из-за чего мы можем его использовать в одну сторону (*чаще всего*)

```pro
won(bill, tom).
won(bill, jerry).
won(bill, pam).
won(pam, jerry).
won(tom, jerry).

category(X, sportsman) :- won(X, _), won(_, X), !.
category(X, winner) :- won(X, _), !.
category(X, loser) :- won(_, X), !.
```
Здесь мы можем проверять человека `X` на принадлежность к категории, но если мы захотим узнать, кто относится к `sportsman`, то получим некорректный ответ (только `pam`, хотя должно быть 2 варианта).

# 23.09.22 - лекция
## Экспертные системы
**Экспертные системы** - программы, решающие задачи, трудные для профильных экспертов, на сопоставимом с этими экспертами уровне.

Работоспособность ЭС определяется в первую очередь её **наращиваемой базой знаний**

**Экспертные системы предназначены для решения неформализованных задач**. К таким задачам относятся те, которые обладают хотя бы одной из следующих характеристик:
- Не могут быть заданы в числовой форме
- Цель не может быть выражена точной целевой функцией
- Не существует алгоритмического решения задачи, либо оно слишком затратно по ресурсам

ЭС обладает следующими свойствами:
- Алгоритм решения задач не известен заранее, а строится на эвристических методах
- Прозрачность - ЭС может точно объяснить, на основании каких фактов был сделан вывод
- Способность приобретения новых знаний от пользователя-эксперта и изменение своих выводов на основании новых знаний
- User-friendly интерфейс

## Структура типовой экспертной системы
![](./materials/lectures/23-09-22%20-%20структура%20ЭС.jpeg)

- Рабочая память - хранит исходные и промежуточные данные решаемой в данный момент задачи
- База знаний - включает факты и правила, описывающие данную предметную область
- Решатель
- Подсистема приобретения знаний
- Подсистема объяснений
- Интерфейс

В разработке ЭС участвуют:
- Эксперт
- Инженер знаний *
- Программист

Режимы работы ЭС:
- Приобретение знаний
- Решение задачи


## ЭС в Prolog
Существует 2 способа организации логического вывода:
- Прямой - Выдаёт предположения на основании имеющихся факторов и данных
- Обратный - Рассматривает заключения, которые могут быть истинными или ложными (backward-chain)

`asserta(fact).` - добавляет факт в базу знаний пролога

*добавить пример с пояснениями*

## Сетевая модель
**Формальная система** - совокупность абстрактных объектов и правил манипулирования ими. Такая система состоит из:
- конечного алфавита
- определённая процедура построения правильных формул
- выделено множество аксиом
- заданы правила вывода, позволяющие вывести из одних формул другие

# 23.09.29 - лекция
## Продолжаем про сетевые модели и формальные системы
*Как же я "соскучился" по дискретке из первого семестра...*

Чтобы доказать теорему, достаточно доказать, что отрицательный вывод из тех же предпосылок невозможен.

**Резольвента** - дизъюнкция дизъюнктов, из которой вычеркнуты бессмысленные атомы (для дизъюнктов "a OR b", "!a" резольвентом будет "b")

Повторили исчисления предикатов (логика первого порядка):
- аксиомы
- метод резолюций
- замену импликации
- внесение отрицания
- сколемизацию - избавление от кванторов $\exist$
  - Если квантор стоит левее всех $\forall$, то можно просто его заменить на свободную переменную, иначе необходимо выразить переменную после $\exist$ как зависимую от переменных находящихся слева кванторов $\forall$
- переход к ПНФ (*ПРЕНЕКСНОЙ*) - вынесение кванторов влево
- переход к КНФ
- избавление от кванторов всеобщности
- разбиваем на отдельные дизъюнкты и приходим к противоречиям (либо не приходим)

**ВАЖНО:** обычно для доказательства действуют так:
1. Формулируют предпосылку
2. Формулируют заключение
3. Отрицают заключение
4. Упрощают предпосылку и заключение
5. Если приходим к противоречию, значит заключение верно (ведь мы получили противоречие из его отрицания)
   - Для прихода к противоречию удобно выписывать дизъюнкты в столбик и вычислять из них резольвенты, повторять до тех пор, пока мы не получим ложь

*Пример списка вывода резольвентов:*
1. !S(y) + C(y)
2. S(b)
3. V(a, b)
4. !C(z) + !V(a, z)
5. C(b) (резольвента из 1 и 2. *Как можно заметить, буква свободной переменной играет роль только внутри дизъюнкта*)
6. !V(a, z) (резольвента из 4 и 5)
7. NULL (резольвента из 3 и 6) - делаем вывод, что для предпосылка и заключение, которые дали такой список резольвентов при взятии отрицания заключения, доказуемы

Далее рассказываются о плюсах исчисления предикатов (*их нет... Ну почти*), а недостатком является монотонность - если какое-то высказывание уже было вычислено, но должно было измениться вследствие новых фактов, то оно не изменится.

# 23.10.04 - семинар
Предикат `findAll(what, when, where)` - дай все конструкции вида `what`, которые удовлетворяют условию `when` и сложи их в список `where`.

`bagof` с такой же сигнатурой. Работает похоже, но группирует массив результатов по всем допустимым значениям свободных переменных.

`setof` очень похож на `bagof`, но собирает результат в множество, а не список (*т.е. элементы не повторяются*)

Чтобы отключить группировку по свободным переменным, записываем параметр `when` в формате `X^pred(X, ...)` - группировки по `X` производиться не будет

*Разностные списки - это тема!*

# 23.10.06 - лекция
## Сетевая модель
Формально сетевую модель можно задать так: $H = <I, C, \Gamme>$:
- $I$ - информационные единицы
- $C$ - множество типов связей между информационными единицами
- $\Gamme$ - Отображение, задающее связи из $C$ между единицами из $I$

**Семантическая сеть** - ориентированный граф, где в вершинах находятся информационные единицы, а в рёбрах - типы связей.

*Дальше идёт непонятно зачем нужное душнилово о строгом определении семантической сети через теорию реляционных БД*

**Интенсионал** - абстрактное описание

### Типы семантических сетей
По виду вершин
- Простые - вершины не имеют внутренней структуры
- Иерархические - вершина обладает некоторой структурой (в т.ч. сама может быть семантической сетью)

По типу дуг (отношений)
- Однородные - если все дуги одного типа
- Бинарная - если используются только бинарные отношения
  - Сценарии - используют отношение нестрого порядка (причинно-следственное, временное, следование "род-вид")

### Классификация отношений
- Отношения таксономии:
  - класс-подкласс (SUB), множество-подможество - между понятиями
  - элемент-класс (ISA), элемент-множество - между экземплярами понятий и понятиями
- Отношение партономии:
  - часть-целое (Part_of) - отношение включения одного понятия (объекта) в другой
- Атрибутивные отношения или отношение свойство-значение:
  - значение("цвет" / "вес" / ...)
- Логические (и, или, не и т.п.)
- Темпоральные (раньше, позже, одновременно и т.п.)
- Пространственные (далеко от, близко к, под, над и т.п.)
- Глубинно-падежные семантические отношения Филмора - служат для описания глубинных семантический отношений между группой существительного и действием (агент, объект, инструмент, время действия)

По отношениям таксономии и партономии **устанавливается иерархия понятий семантической сети и организуется наследование свойств и понятий**. За счёт этого описание модели становится более компактным

![](./materials/lectures/23-10-06%20-%20семантическая%20сеть.png)

### Достоинства и недостатки
Достоинства:
- Высокая выразительность и гибкость
- Универсальность при выборе нужного набора отношений
- Наглядность представления
- Соответствие современным представлениям об организации долговременной памяти человека

Недостатки:
- При росте числа отношений и вершин сеть быстро становится запутанной
- Поиск решения в семантической сети сводится к поиску фрагмента сети, соответствующего образцу, отражающему наш запрос. Эта задача может выполняться очень долго

### Функциональная сеть
Вид семантической сети, которая представлена двудольным графом. В одной доле вершины-объекты (переменные), в другой - вершины-операторы (функции)

Дуги от переменных к операторам показывает, что вершина-объект - аргумент вершины-функции. Дуга от функции к объекту показывает, что объект - результат выполнения функции.

![](./materials/lectures/23-10-06%20-%20функциональная%20сеть.png)

### Фреймы
**Фрейм** - структура данных, представляющая стереотипную ситуацию. Фрейм является совокупностью знаний о некоторой понятии или явлении.

По своей организации фрейм похож на иерархическую семантическую сеть. Верхние узлы представляют общие понятия, нижние - более конкретные. Понятие в каждом узле определяется набором атрибутов и их значений, атрибуты называются **слотами**. Каждый слот может быть связан с определёнными процедурами, которые будут исполняться при изменении значения слота.

*Добавить картинку с наглядным представлением*

# 23.10.11 - семинар
## Экспертные системы
[Теория про экспертные системы тут](#экспертные-системы)

### Goal-driven backward
Идёт от предположения (гипотезы) к отдельным фактам. Если они истины, значит гипотеза верна.

Хорош, когда много данных, но гипотез много.

Элементарный пример без пользовательского интерфейса, с заданными заранее фактами:
```prolog
:- dynamic bathroom_dry/0.
:- dynamic window_closed/0.
:- dynamic no_rain/0.


hall_wet.

kitchen_dry.

leak_in_bathroom :- hall_wet, kitchen_dry.

problem_in_kitchen :- hall_wet, bathroom_dry.

no_water_from_outside :- window_closed; no_rain.

leak_in_kitchen :- no_water_from_outside, problem_in_kitchen.
```
Теперь мы можем задать вопросы и получить ответы:
```prolog
1 ?- leak_in_kitchen.
false.

2 ?- leak_in_bathroom.
true.
```

Эта ЭС очень плоха: мы задаём факты прямо в коде, а надо использовать UI (или хотя бы шэлл).

Экспертная система должна отвечать на вопросы `HOW?`, `WHY?`

Для начала зарегистрируем несколько по-человечески звучащих предикатов:
```
:- op(800,  fx, if).
:- op(300, xfx, then).
:- op(300, xfy, and).
:- op(200, xfu, or).
```
Этот предикат регистрирует предикат как оператор. 
- Первый аргумент - приоритет (от 0 до 1200). 
- Второй - ассоциативное поведение: 
  - `fx` - унарный оператор
  - `xfx` - обоассоциативен
  - `xfy` - правоасоциативен
  - `yfx` - левоасоциативен
- Третий - имя оператора

*Данная конструкция позволяет объявлять предикаты в коде сразу в инфиксном формате*

Преобразованная ЭС будет выглядеть так:

```prolog
known(hall_wet).
known(kitchen_dry).

% Делаем так, чтобы при Пролог мог обрабатывать выражения с использованием этих операторов, то есть рабабатываем движок ЭС
true(A) :- known(A).
true(A and B) :- true(A), true(B).
true(A or B) :- true(A); true(B).
true(Conclusion) :- 
  if Condition then Conclusion,
  true(Condition).
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         KNOWLEDGE BASE                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if
    hall_wet and kitchen_dry
then
    leak_in_bathroom.


if
    hall_wet and bathroom_dry
then
    problem_in_kitchen.


if
    window_closed or no_rain
then
    no_water_from_outside.


if
    problem_in_kitchen and no_water_from_outside
then
    leak_in_kitchen.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         KNOWLEDGE BASE                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
```

### Data-driven forward
Идёт от фактов к выводам, записывая их по пути. 

Хорош, когда данных мало, а гипотез много

`asserta(pred)` / `assertz(pred)` - добавляет в код Пролога предикат в начало или конец соответственно. Чтобы операции работали, необходимо определить динамически `:- dynamic pred`.

`retract(pred)` удалит из кода первое вхождение предиката. `retract_all(pred)` - удалит все вхождения предиката.

<blockquote><code>\+</code> - операторная форма <code>not()</code></blockquote>

```prolog
:- dynamic derived/1.
% Clear all derived relations on program startup
:- retractall(derived(_)).

% Fact is either something that is already derived or a combination
% of the other derived facts.
fact(F) :- derived(F).
fact(F1 and F2) :- fact(F1), fact(F2).
fact(F1 or F2) :- fact(F1) ; fact(F2).

% Some statement is derivable if it is not derived yet, and
% if there is a rule of a form
% IF Cond THEN Statement where Cond is already a known fact
derivable(Conclusion) :-
  if Condition then Conclusion,
  \+ derived(Conclusion),
  fact(Condition).

% Keep trying to derive facts while there is information
fc :-
  derivable(Statement), !,
  format('Inferred that ~w;\n', [Statement]),
  assertz(derived(Statement)),
  fc ;
  write('---------------------------------').

fc_inference :-
  retractall(derived(_)),
  asserta(derived(S) :- known(S)), % После очистки списка выведенных фактов снова заносим в него известные заранее
  fc.
```

### Смешанный вывод
Получаем часть фактов и выбираем гипотезы, которые, вероятно, подошли бы нам. А затем идёт от гипотезы к фактам.

Смешанная ЭС будет самой оптимальной для большинства предметных областей. Исключениями будут частные случаи, когда между данными и гипотезами есть сильный переход в одну из сторон.

```prolog
% Выбираем заключение, которое ещё не выведено и не отклонено на основании выведенных фактов
suppose(Concl) :-
  derived(F),
  (
    Cond = F ;
    Cond = F and _ ;
    Cond = _ and F ;
    Cond = F or _ ;
    Cond = _ or F
  ),
  if Cond then Concl,
  \+ rejected(Concl),
  \+ derived(Concl).

hc :-
  supposed(Statement),
  !,
  ( true(Statement)
    ->
      format('Inferred that ~w;\n', [Statement]),
      asserta(derived(Statement))
    ; 
      assertz(rejected(Statement))
  ), % Нотация в скобках является ветвление вида (if_preds -> then_preds ; else_preds)
  hc ;
  write('---------------------------------').

hc_inference :-
  retractall(derived(_)),
  retractall(rejected(_)),
  asserta(derived(S) :- known(S)),
  hc.
```

# 23.10.13 - лекция
## Продукционная модель
**Система продукций Поста** определяется алфавитом S и правилами вида `aW -> Wb` - если в слове обнаруживается префикс `a`, то он вычёркивается, а в конец добавляется постфикс `b`.

**Нормальные алгоритмы Маркова** представляют собой правила `a -> b`, которые, в отличие от продукций Поста, применяются последовательно. Финальное правило записывается точкой.

**Формальные грамматики** - `<V, T, P, Z>`: `V` - алфавит, `T <= V` - терминальные символы, `P` - правила перехода, `Z` - начальный символ

### Программные продукционные системы
- База данных - рабочая память, над которой работают правила
- Множество правил-продукция - могут быть и весьма сложными, но суть одна: слева условие, а справа действие
- Интерпретаторы - поисковый процесс, состоящий из выбора продукции и её применения

Выбор продукции сводится к двум задачам:
- Максимально ограничить число проверяемых продукций
- Из полученного множества выбрать не больше одной продукции

**Конфликтные продукции** - множество, для которого условие во всех продукциях будет истинным. Для разрешения конфликтов есть 3 варианта:
- Случайный выбор
- Статический выбор на основании заданных изначально приоритетов
- Динамический выбор - продукциям в ходе исполнения будут записываться определённые параметры, определяющие приоритетность

Управляющие стратегии разрешения конфликтов подразделяют на:
- Безвозвратные - разрешив конфликт, мы уже далее не имеем возможности вернуться к этому моменту и изменить выбор
- Пробный (бэктрекинг) - противоположна безвозвратной

### Стратегии применения
*Описывается прямая и обратная стратегии, который почти в точности повторяют методы с [семинара](#231011---семинар)*

### Классификация систем продукции
СП могут делиться по тому, как они решают проблему активации продукции.

#### Простые СП
Активными считаются все продукции.

Применим к СП с небольшим количеством правил либо к таким, где структуризация и принудительная активация противоречат принципам СП.

Примером просто СП является в том числе и Prolog

#### Управляемые СП
- СП с независимым управляющим языком
  - Содержит "чистые продукции" и стратегию их применения (напоминает полином). Повышают эффективность применения продукций, недостаток - статичность и жёсткость управления.
- Иерархические СП
  - Используют метапродукции, которые могут активировать или деактивировать обычные продукции
- Последовательные СП
  - СП делится на соединённые последовательно продукционные модули, которые соответствуют определённому этапу обработки знаний 
- Параллельно-последовательные СП
  - ТАкже разбивается на продукционные модули, но работают они параллельно и имеют общую память

### Плюсы / Минусы СП
Плюсы:
- Универсальность
- Естественность представления знаний через импликацию
- Высокая модульность

Минусы:
- Низкая эффективность в сравнении с традиционными языками
- Повышенная сложность контроля правильности процесса
- Сложно отслеживать непротиворечивые правила

### Использование СП
- Построение компиляторов
- Автоматическая обработка текстов
- Распознавание и синтез речи
- Экспертные системы

# Что надо на КР
- Метод резолюций
- Нечёткие модели

# 23.10.25 - семинар
`read_string(user_input, "\n", "\r\t", _, Answer)` - читает строку из указанного потока и пишет в `Answer`. Заканчивается чтение на любом символе из второго аргумента. Из `Answer` удаляются символы из третьего аргумента

## Пример экспертной системы с юзер-интерфейсом
```prolog
/*
* Using Prolog's syntax for rules has certain disadvantages, however.
*
* First, this syntax may not be the most suitable for a user unfamiliar
* with Prolog. And second, the knowledge base is not syntacticaly
* distinguishable from the rest of the program; a more explicit
* distinction between the knowledge base and the rest source code
* may be desirable.
*
* It is handy to tailor the syntax of expert rules by using Prolog
* operator notation.
*/

:- op(800, fx, if).     % IF 
:- op(700, xfx, then).  % THEN
:- op(300, xfy, or).    % OR
:- op(200, xfy, and).   % AND
:- op(800, xfy, <==).   % <==

:- dynamic derived/1.  % Хранит выведенные предикаты
:- retractall(derived(_)).

:- dynamic asked/1.  % Хранит факты, которые мы уже спросили
:- retractall(asked(_)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         KNOWLEDGE BASE                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if
    hall_wet and kitchen_dry
then
    leak_in_bathroom.


if
    hall_wet and bathroom_dry
then
    problem_in_kitchen.


if
    window_closed or no_rain
then
    no_water_from_outside.


if
    problem_in_kitchen and no_water_from_outside
then
    leak_in_kitchen.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                     END OF KNOWLEDGE BASE                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Нам необходимо запрашивать у пользователя о начальных фактах - тех, которые не выводятся ни одним из правил

askable(hall_wet).
askable(kitchen_dry).
askable(bathroom_dry).
askable(window_closed).
askable(no_rain).

% Новая версия предиката true будет хранить не только проверяемое выражение, 
% но также ProofTree - дерево выводов до проверяемого факта и путь
% Trace - содержит правила от гипотезы до проверяемого факта
true(S, _, _) :- derived(S).
true(S1 and S2, ProofTree1 and ProofTree2, Trace) :- 
  true(S1, ProofTree1, Trace),
  true(S2, ProofTree2, Trace).
true(S1 or S2, AnyProofTree, Trace) :- 
  true(S1, AnyProofTree, Trace);
  true(S2, AnyProofTree, Trace).
true(Concl, Concl <== ProofTree, Trace) :- 
  if Cond then Concl, 
  true(Cond, ProofTree, [(if Cond then Concl) | Trace]).

% Если это начальный факт, спрашиваем у пользователя
true(S, ProofTree, Trace) :- 
  askable(S),
  \+ derived(S),
  \+ asked(S),
  ask(S, ProofTree, Trace).

% User interface
ask(S, ProofTree, Trace) :- 
  format("\nIs ~w? Answer 'yes', 'no' or 'why': ", [S]),
  read_string(user_input, "\n", "\r\t", _, Answer),
  process_user_answer(Answer, S, ProofTree, Trace).

% Записываем факт как выведенный и спрошенный, сохраняя в дерево, что мы узнали факт от пользователя
process_user_answer("yes", S, S <== was_told, _) :- !,
  asserta(derived(S)), asserta(asked(S)).
% Если ответ нет, просто отмечаем вопрос, как спрошенный и возвращаем ложь
process_user_answer("no", S, _, _) :- !,
  asserta(asked(S)), fail.
% Выводим правила, для которых задавался вопрос, и спрашиваем вопрос снова
process_user_answer("why", S, ProofTree, Trace) :- !,
  show_reasons(Trace), ask(S, ProofTree, Trace).
% cut-оператор в данных предикатах используется как break в конструкции switch-case, чтобы мы не попали в наш вариант default-ветки
process_user_answer(_, S, ProofTree, Trace) :-
  write("\nIncorrect answer\nPlease, answer 'yes', 'no' or 'why': "),
  read_string(user_input, "\n", "\r\t", _, Answer),
  process_user_answer(Answer, S, ProofTree, Trace).

show_reasons([]).
show_reasons([if Cond then Concl|Trace]) :- 
  format("\n'~w' is true when \n\t'~w'\n", [Concl, Cond]),
  show_reasons(Trace).

start_system(S, Proof) :- 
  retractall(asked(_)), retractall(derived(_)),
  true(S, Proof, []).
```

## Семантическая сеть на prolog
Оператор `Pred =.. [PredName, Args...]` - разбирает предикат слева на его имя и аргументы. Если передать `[PredName, Args...] =.. Pred`, то аргументы соберутся в предикат `PredName(Args...)`

```prolog
% Semantic web

isa(bird, animal).
isa(albatrose, bird).
isa(kiwi, bird).
isa('Albert', albatrose).
isa('Rose', albatrose).
isa('Kim', kiwi).

color(kiwi, gray).
color(albatrose, white).

moving(kiwi, walks).
moving(bird, flies).

fact(Pred) :- Pred, !.
fact(Pred) :- Pred =.. [PredName, A, B], 
  isa(A, Seg),
  [PredName, Seg, B] =.. NewPred,
  fact(NewPred).
```
Предикат `fact` в данном случае будет работать в одну сторону. Мы сможем узнать, какого цвета `Kim`, но не сможем узнать всех белых птиц поимённо.

# 23.10.27 - лекция
## Нечёткие модели
Нечёткость связана с отсутствием точных границ области определений и свойственно очень многим понятиям. В итоге мы можем говорить о принадлежности объекта определённому классу лишь с некоторой вероятностью (то есть не скачком от 0 до 1, а плавно)

**Лингвистическая переменная (неформально)** - её значениями могут быть слова из некоторого языка. Например, можем определить ЛП `температура_тела` как `нормальная`, `повышенная`, `высокая` и `очень_высокая`. 

**ЛП (формально)** - пятёрка множеств N, T(N), U, G, M, где:
- N - название ЛП
- T(N) - терм-множество возможных значений ЛП
- U - универсальное множество
- G - синтаксическое правило, порождающее T(N)
- M - семантическое правило, сопоставляющее значению ЛП X некоторый смысл M(X), причём M(X) будет нечётким подмножеством U

*Пример про возраст*

**Нечёткое множество (формально)** - множество из пар, где на первом месте стоит значение из универсального множества, а на втором - значение степени его принадлежности в диапазоне `[0,1]` (иногда это не конкретное значение, а некоторая функция принадлежности (ФП) с той же ОДЗ)

**Универсальное множество** - ООФ функции принадлежности

**Носитель НМ** - множество значений, для которых функция принадлежности > 0

**Высота НМ** - максимальное значение функции принадлежности

**Точка перехода(*почему не область?*)** - значение УМ, в котором значение функции перехода = 0.5

![](./materials/lectures/23-10-27%20-%20НМ%20и%20функция%20принадлежности.png)

Записывается НМ иногда как так: `ФП(x_1)|x_1 + ФП(x_2)|x_2 + ... ФП(x_n)|x_n` (*плюс в данном случае означает объединение*)

Для нечётких множеств также определены операции дополнения (1 минус ФП для всех значений УМ), объединения (максимум ФП для всех значений УМ из обоих нечётких множеств) и пересечения (минимум ФП для значений УМ, представленных обоих НМ) и умножение (умножение значений ФП). Операции возможны только над НМ с одинаковым универсальным множеством. (*на самом деле уточнение про вхождение в оба или хотя бы в одно излишне как тут, так и ранее, потому что, если мы будем брать ФП, у которых нет пары, мы будем умножать на ноль (брать минимум из нуля, максимум из двух нулей, если речь о пересечении и объединении соответственно)*)

![](./materials/lectures/23-10-27%20-%20НМ%20операции.png)

Аналогичным образом определяется и не имеет существенных отличий в подсчётах **нечёткое отношение**, которое определено для n-арного пространства (то есть УМ будет декартово произведение n значений). 

*Пример:* НО "близко к". УМ - положение двух объектов (считаем пространство одномерным) $X_1 \times X_2$, тогда можно описать (*считая тут определённый интеграл как сумму либо, для простоты, считать вдобавок множество $X_1 \times X_2$ дискретными парами*) НО "близко к" 
$$
= \int_{X_1 \times X_2} e^{-a|x_1-x_2|}|(x_1,x_2)
$$

### Использование нечёткой логики в ЭС
Операциями нечёткой логики будут также И, ИЛИ, НЕ, определённые также, как для НМ.

Слабым местом нечёткой логики является выбор функции принадлежности - сложно понять, где именно должна быть точка перехода и как сильно должно меняться значение. Наибольшее распространение получили следующие функции:
- Треугольная
  - <img width="60%" src="./materials/lectures/23-10-27 - ФП треугольная.png">
- Трапецеидальная
  - <img width="60%" src="./materials/lectures/23-10-27 - ФП трапецеидальная.png">
- Гауссова функция
  - <img width="60%" src="./materials/lectures/23-10-27 - ФП гауссова.png">

Другим слабым местом является взвешенность отдельных сведений и их использование в нечётких правилах. Если по двум разным правилам мы получили разные значения одной и той же буквы из УМ, как быть? Решение - **использовать коэффициенты уверенности** `КУ(h : e) = МД(h : e) - МНД(h : e)`:
- `МД(h : e)` - мера доверия гипотезе `h` с учётом свидетельств `e`
- `МНД(h : e)` - мера недоверия гипотезе `h` с учётом свидетельств `e`
- `КУ(h : e)` - уверенность в гипотезе `h` с учётом свидетельств `e`. Может быть в диапазоне `[-1, 1]`: `-1` - абсолютная ложь, `0` - полное незнание и `1` - абсолютная истина

Из этого решения также вытекает ещё одна проблема, когда МД и МНД оба велики (противоречивые свидетельства) или оба малы (недостаток информации), мы будем находиться в состоянии полного незнания. Решается использованием формулы уточнения *конец лекции о НМ* 

# Ещё раз о КР
Будет 3 задачи:
1. [Метод резолюции](#продолжаем-про-сетевые-модели-и-формальные-системы) (деревья вывода?) (2,5 - 3 балла)
   1. Смотри лекцию 5. Может быть как чисто в резольвентах, так и в предикатах (с кванторами, но это уже маловероятно. Энивэй, примеры в пятой лекции)
2. 2 задачи на нечёткие модели
   1. Арифметика над нечёткими множествами
   2. Одна из двух задач:
      1. Дана ЛП. Нужно придумать для неё значения и ФП, нарисовать график для значений ФП
      2. Нечёткое отношение

# 23.11.01 - семинар
## Реализация ЭС с гибридным подходом с UI
*Добавить код из файла*

# 23.11.03 - лекция
## генетические алгоритмы
**Генетические алгоритмы** - поисковые алгоритмы, основанные на принципах селекции и естественного отбора.

**Эволюционный поиск** - последовательное преобразование одного конечного множества решений в другое. Каждое решение кодируется набором символов (битов) и называемых **хромосомой**. Отдельный символ называется **геном**. Множество хромосом (решений) называется **популяцией**.

**Функция приспособленности** (целевая функция, fitness function) - функция, показывающая, насколько хорошо подходит решение поставленной задаче.

А дальше почти как по Дарвину:
- Каждая популяция состоит только из жизнеспособных хромосом
- Каждое новое поколение лучше предыдущего относительно целевой функции
- Каждая популяция зависит только от предыдущей

Крутость эволюционного алгоритма в том, что он позволяет найти удовлетворительное решение для аналитически не решаемых задач.

Работа простого ГА:
1. Случайно генерируем хромосомы
2. Применяем к получившейся популяции простые операции и генерируем новую популяцию
   1. Оператор репродукции - копирует хромосому в новое поколение с вероятностью, зависящей от значения целевой функции (*выживают приспособившиеся*). ОР применяется столько раз, сколько хромосом в исходной популяции
   2. Оператор кроссинговера - берутся 2 разные случайные хромосомы, прошедшие ОР, выбирается случайное число k в диапазоне `[1, L-1]`, где L - длина хромосомы, затем гены на позициях `> k` меняются между хромосомами (*как по мне, куда более крутой и биологически верный вариант - формировать хромосомы-потомки `L/2` случайными перестановками*)
   3. Оператор мутации - в хромосоме после ОК выбираются 2 случайных позиции, затем гены в этих позициях меняются местами. Вероятность мутации, как и в реальном мире, должна быть мала. Это обеспечит стабильность, но при этом позволит нам не попасть в ловушку локального экстремума целевой функции
3. Остановка ГА определяется несколькими возможными путями:
   1. Заранее задаётся количество поколений
   2. Достижение определённого значения целевой функции
   3. Популяция сходится (хромосомы близки по значению ЦФ)
4. После остановки можем взять всю популяцию или только самых приспособленных особей из неё

Применение ГА:
- Оптимизация функций
- Оптимизация запросов к БД
- NP-полные задачи с графами (*например, для задачи коммивояжёра*)(*да и вообще любые NP-задачи*)
- Игровые стратегии
- Аппроксимация функций
- Моделирование эволюции
- Биоинформатика
- Настройка и обучение нейронных сетей

Следующим этапом после ГА стали бионинспирированные алгоритмы, то есть такие, основа которых была также подсмотрена у природы, но используют более сложные механизмы. Например, построенное цепочек роем муравьёв

# 23.11.08 - семинар
*Тут снова работали с графами*

# 23.11.10 - лекция
## Искусственные нейронные сети
**Искусственная нейронная сеть** - формальная сеть, симулирующая реальную сеть нейронов

**Формальный нейрон** - элемент с единственным пороговым двоичным выходом, значение которого зависит от линейной комбинации всех входящих сигналов

Формальный нейрон работает в **дискретном времени**, то есть значение на выходе в момент времени `n + 1` будет зависеть только от значений входов в момент `n`

Самая простая функция для определения значения выхода - это пороговая, однако зачастую в реальной работе применяются сигмоидные функции

### Обучение нейронки
Основное свойство нейронных сетей - способность к обучению.

Для обучения мы берём некоторые признаки и ожидаемый ответ, отправляем входные данные в сеть и считаем ошибку для сравнения полученного и ожидаемого ответа (зачастую считают квадратичную ошибку).

Задача обучения в таком случае сводится к минимизации функции ошибки, переменными для которой являются только веса входов (сами входные данные и ожидаемый результат - константы)

Один из удобных и простых методов - **обратное распространение ошибки (back-propagation)**:
- Считаем градиент функции ошибки по всем весам
- Корректируем исходные веса при помощи линейной комбинации с градиентом, умноженным на некоторый шаг

Плюсы градиентного метода:
- Изменяем сразу все веса сети, то есть расчёты идут параллельно

Минусы:
- Есть риск провалиться в локальный минимум (*хотя на самом деле во многих задачах это вероятность **крайне мала***)
- Переобучение - *сейчас рассматривать не стали*

### Применение нейронных сетей и их типы
- Классификаторы - относят изображение (и не только) к одному из нескольких классов. На последнем слое будет столько нейронов, сколько у нас классов
- Распознаватели - класса всего 2 (*да / нет*)
- Предикторы - предсказание изменения / поведения объектов на основании данных реального времени
- Ассоциативная память - может изменять входные данные с целью достижения определённого результата (восстановление старых фото)

Архитектуры нейронных сетей:
- Глубокая сеть доверия - множество слоёв, в которых нейроны не связаны между собой, но связаны с другими слоями
- Свёрточная нейронная сеть - каждый слой выделяет часть набора данных из всего массива и определённым образом их обрабатывает. Так устроены сети для распознавания изображений

# 23.11.15 - семинар
`select(OldElem, OldList, NewElem, NewList)` - убирает элемент `OldElem` из списка `OldList` и заменяет его на `NewElem`, возвращая новый список в `NewList`

# 23.11.17 - лекция
## Методы поиска
Вспомним 2 основных подхода к моделированию мышления:
- Символический - был доминирующим прежде. Заключается в идее того, что все интеллектуальные действия сводятся к оперированию с символами. То есть подход включает в себя символические структуры и операции для работы с ними
- Нейросетевой и нейрокибернетический подход - моделирование процессов человеческого мозга с точностью до биологических концептов

**Символ** - базовое аксиоматическое понятие. Неделимая сущность символической модели

**Символическая система** - набор символов, образующих символические структуры и набор процессов

**Символическая структура** - набор символов, соотнесённых между собой определённым образом

**Процессы** - могут создавать, разрушать и модифицировать символические структуры

### Алгоритмы поиска по графам
Для системы вида $(S_0, F, S_T)$, где:
- $S_0$ - начальное символьное состояние
- $F$ - переходы, преобразующие одну символьную структуру в другю
- $S_T$ - конечные состояния

Решение для такой системы будет набор преобразований из $F$, если представить систему как граф с вершинами из $S$ и рёбрами из $F$, то вся задача будет сводиться к поиску пути в графе.

*А дальше нам решают рассказать о поиске в глубину и в ширину...*

Более Интересным будет обратный поиск, который вводится за счёт добавления обратных операторов, преобразующих состояние в предшествующее ему. В таком случае мы можем двигаться от целевых состояний к начальным

*Метод равных цен - это недо-Дийкстра*

Модификацией над этими алгоритмами поиска является эвристический алгоритм, который позволяет выбирать в первую очередь те вершины, которые с большей вероятностью приведут к целевой вершине. Можно достигнуть этого модификацией функции перехода либо сортировкой списка доступных для перехода вершин.

Куда более приятной и логичной модификацией является алгоритм A*, для которого определяется оценочная функция `f` каждой вершины как сумма пути до неё от начальной `g` и стоимости оптимального пути от этой вершины до целевой `h`. Функция `h` **НЕ ДОЛЖНА ПЕРЕОЦЕНИВАТЬ ПУТЬ**, но вполне допустима его недооценка (*например, при перемещении по полю мы можем выбирать за `h` евклидово расстояние (или Манхэттэнское, или Чебышева), игнорируя любые препятствия*)

Главной задачей таким образом становится подбор функции `h`, который сможет сделать алгоритм весьма эффективным. (*Пример подбора функции смотри в первой презентации на эту дату, начиная со слайда 40*)

### Метод редукции
**Метод редукции** заключается в поиске общего решения задачи через решение её подзадач

# 23.11.22 - семинар
## Алгоритмы поиска