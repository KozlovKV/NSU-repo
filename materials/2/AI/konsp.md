- [Инфо](#инфо)
- [23.09.06 - семинар](#230906---семинар)
  - [Базовые понятия в prolog](#базовые-понятия-в-prolog)
- [23.09.08 - лекция](#230908---лекция)
- [23.090.13 - семинар](#2309013---семинар)
  - [Списки](#списки)
  - [Дополнительный арифметический модуль](#дополнительный-арифметический-модуль)
- [23.09.15 - лекция](#230915---лекция)
  - [Предикаты для управления исполнение программ](#предикаты-для-управления-исполнение-программ)
  - [Рекурсия](#рекурсия)
- [23.09.20 - семинар](#230920---семинар)
  - [Оператор отсечения (cut, `!` - *надеюсь, теперь человечески*)](#оператор-отсечения-cut----надеюсь-теперь-человечески)
- [23.09.22 - лекция](#230922---лекция)
  - [Экспертные системы](#экспертные-системы)
  - [Структура типовой экспертной системы](#структура-типовой-экспертной-системы)
  - [ЭС в Prolog](#эс-в-prolog)
  - [Сетевая модель](#сетевая-модель)
- [23.09.29 - лекция](#230929---лекция)
  - [Продолжаем про сетевые модели и формальные системы](#продолжаем-про-сетевые-модели-и-формальные-системы)
- [23.10.04 - семинар](#231004---семинар)
- [23.10.06 - лекция](#231006---лекция)
  - [Сетевая модель](#сетевая-модель-1)
    - [Типы семантических сетей](#типы-семантических-сетей)
    - [Классификация отношений](#классификация-отношений)
    - [Достоинства и недостатки](#достоинства-и-недостатки)
    - [Функциональная сеть](#функциональная-сеть)
    - [Фреймы](#фреймы)
- [23.10.11 - семинар](#231011---семинар)
  - [Экспертные системы](#экспертные-системы-1)
    - [Goal-driven backward](#goal-driven-backward)
    - [Data-driven forward](#data-driven-forward)
    - [Смешанный вывод](#смешанный-вывод)
- [23.10.13 - лекция](#231013---лекция)
  - [Продукционная модель](#продукционная-модель)
    - [Программные продукционные системы](#программные-продукционные-системы)
    - [Стратегии применения](#стратегии-применения)
    - [Классификация систем продукции](#классификация-систем-продукции)
      - [Простые СП](#простые-сп)
      - [Управляемые СП](#управляемые-сп)
    - [Плюсы / Минусы СП](#плюсы--минусы-сп)
    - [Использование СП](#использование-сп)
- [Что надо на КР](#что-надо-на-кр)


# Инфо
Лектор - Загорулько Виктор Алексеевич

Семинарист - Серый Алексей Сергеевич

# 23.09.06 - семинар
Логическое программирование - парадигма, являющаяся вариацией декларативного программирования, основанная на логике предикатов (высказывание, *привет, дискретка!*). Программа в этой парадигме обычно работает лишь с заданными данными и не содержит внешней логики (связей с другими кусками кода и т.п.)

Используется для удобного отображения баз знаний, логических выводов, обработки естественных языков и т.п.

Логическое программирование позволяет создавать ИИ, работающий по формальной логике, то есть основанный на чёткий правилах и делающий выводы в их рамках.

Программы в парадигме логического программирования очень сложно масштабировать, так как количество необходимых к прописыванию правил растёт экспоненциально.

## Базовые понятия в prolog
- `Fact` - используются для обозначения безусловной истины
- `Rules` - выражения, которые могут быть правдой
- `Knowledge base` (`database`) - набор правил и фактов. База знаний - это и есть программа на прологе. Взаимодействие с ней происходит через написание запросов (`queries`)
- `Query` - это запрос (*неожиданно*). Пролог проверяет, может ли быть ответом на запрос `true`. Если да, то выводит все значения переменных (`variables`), при которых это так, иначе отвечает `false`

Простейшая `database` выглядит так:
```prolog
kind(fruit, orange).
kind(fruit, apple).
kind(veg, tomato).
kind(veg, carrot).
color(red, apple).
color(red, tomato).
color(orange, orange).
color(orange, carrot).
```
Запросы к ней:
```prolog
?- kind(veg, X).
// X = tomato
// X = carrot

?- color(orange, X).
// X = orange
// X = carrot

?- kind(veg, X), color(Y, X).
// X = tomato,
// Y = red
// X = carrot,
// Y = orange
```

Пример с базовыми логическими операторами:
```prolog
playsGames(kirill).
playsGames(artyom).
playsGames(igor).
donates(kirill).
donates(artyom).
donates(dima).

hardGamer(G) :-  playsGames(G), not(donates(G)).
anyGamer(G) :- playsGames(G) ; donates(G).
```
Запросы:
```prolog
?- hardGamer(kirill).
// false

?- hardGamer(X).
// X = igor

anyGamer(X).
// X = kirill
// X = artyom
// X = igor
// X = kirill
// X = artyom
// X = dima
```

Отсюда можно заметить следующие обозначения:
1. `,` - И
2. `;` - ИЛИ
3. `:-` - $\larr$ (обратная импликация)
4. `!` - **?**

Если правило записать в несколько строк, то оно будет работать как pattern-matching

**Terms** (выражения) в Прологе строятся из атомов, чисел, строк, переменных и других термов:
- Атом - произвольный набор символов без пробела с маленькой буквы либо **абсолютно** произвольный набор символов в **одинарных** кавычках либо спецсимволы
- Числа - целые и вещественные (*через точку, ваш кэп*)
- Переменные - строка без пробела, начинающаяся с большой буквы либо `_`, либо **абсолютно** произвольная строка в **двойных** кавычках

Составные выражения должны называться термом-**атомом**, аргументы должны идти через запятую в скобках и могут быть термом любого типа (да-да, хоть числом)

# 23.09.08 - лекция
*У препода лёг комп из-за флэшки. Скайнет победил*

Все определения ИИ так или иначе сводятся к системе, способной моделировать традиционно считающиеся творческими задачи.

Существует 2 подхода к моделированию мышления:
1. Символьный (логический) - оперирование символами и понятиями, построение формальных моделей и соответствующих им механизмов рассуждений
2. Нейросетевой - строится на идее, что на мышление способен только человеческий мозг, а значит основная цель - построить модель человеческого мозга из нейронов и связей между ними, то есть создать нейронную сеть

Используется ИИ во многих областях: представление знаний, распознавание языка, синтез речи и изображений, анализ данных, экспертные системы.

Машинное обучение - методы ИИ, суть которых заключается не в прямом решении задачи, а в решении подобных задач. Используется для них много разных методов: матстат, графы, тервер и т.п.

Объяснимый ИИ - набор методов, позволяющий понять, почему алгоритмы машинного обучения пришли к определённому выводу.

В правилах можно использовать и простое равенство:
```prolog
likes (beth, X) :–
  likes (mаrу, X),
  X = popcorn. 
```

# 23.090.13 - семинар
## Списки
Элементами терма могут быть атомы, переменные, термы и списки.

`|` отсоединяет голову от хвоста (*да-да, как в Haskell*). При этом можно в качестве головы взять несколько элементов: `f([X, Y, Z | Tail])` - взять 3 первых элемента. При попытке взять больше элементов, чем есть в массиве, возвращается `false`

Предикат `member(x, [...])` возвращает `true` столько раз, сколько в списке встречается атом `x`. Можно проверять как предикат в обе стороны: то есть проверять, входит ли элемент в список, а также в какие списки будет входить элемент.

Собственная реализация `member`:
```pro
mem(X, [H|TAIL]) :- X = H ; mem(X, TAIL).
```
При этом нет необходимости прописывать вариант `mem(X, []) :- fail.`, так как всё не прописанное в прологе считается ложью.

`append(a, b, c)` - истина `<=>` список `c` - конкатенация `a` и `b`. При разных запросах эта операция может не только объединять списки.

Собственная реализация `append`:
```pro
app([], [], []).
app([], [B|BTail], [B|RTail]) :- app([], BTail, RTail).
app([A|ATail], BTail, [A|RTail]) :- app(ATail, BTail, RTail).
```
Здесь ещё несколько фишек Пролога:
- Записи из одного лишь правила **истинны всегда** (*если задуматься, то и логично, ведь так и строятся базы знаний из всех примеров выше*)
- Указав одну и ту же букву в правиле в нескольких местах, мы сразу говорим, что значение на этих местах **должно быть равно**

*А на самом деле можно сделать запись ещё короче и приятнее (хотя последнее немного спорно)*
```pro
appnd([], B, B).
appnd([A|ATail], B, [A|R]) :- appnd(ATail, B, R).
```

Используя конкатенацию, можем добавить много разных предикатов:
```pro
end(E, L) :- appnd(_, [E], L).

leftShift(S, [L|Tail]) :- appnd(Tail, [L], S).
```

## Дополнительный арифметический модуль
Стандартная арифметика пролога обязательно требует определённых чисел, поэтому вместо неё используется библиотека `clpfd`. Для подключения библиотеки в начале кода надо написать `use_module(library(clpfd)).` (*это библиотека для целых чисел, для плавающих используется `clpr`*)

Перед многими символами операций пишется `#`:
```pro
?- X is 3 + 5. // Стандартная математика
// X = 8.
?- X #= 3 + 5. // Вывод будет таким же

?- 8 is X + 5. // Ошибка
?- 8 #= X + 5.
// X = 3.
```

# 23.09.15 - лекция
## Предикаты для управления исполнение программ
Выполнение пролог-программы основывается на дереве решений.

Чтобы сократить количество просматриваемых вариантов, используются предикаты `fail` и cut (`!`)

В прологе используется **отрицание по невыполнимости**, то есть утверждение истинно тогда и только тогда, когда мы можем доказать его на основании имеющихся фактов.

Предикат `!` *до сих пор до конца не понятен*, но вроде как если слева от `!` истина, то поиск в дереве решений будет приостановлен, иначе поиск решений продолжится.

## Рекурсия
Группа правил с одним и тем же именем называется **процедурой**.

По классике в рекурсии содержится базис и шаг.

Как и везде, рекурсия очень жёстко ест стэк, поэтому используется **хвостовая рекурсия**. 

*Краткое напоминание:* хвостовая рекурсия основывается на вычислении при **движении вглубь**, чтобы на обратном пути мы могли просто возвращать итоговое значение на самый верх.

В отличие от операторов строгости в Haskell, здесь для работы хвостовой рекурсии требуется делать рекурсивный вызов в самом конце (*ну и создавать накопительный параметр, ясное дело*).

# 23.09.20 - семинар
## Оператор отсечения (cut, `!` - *надеюсь, теперь человечески*)
Оператор `cut`, если мы дошли до него по дереву решений, фиксирует путь по дереву выше и не проверяет альтернативные пути, лежащие выше. Это позволяет сделать эффективным поиск решений, но лишает предикат полноты, из-за чего мы можем его использовать в одну сторону (*чаще всего*)

```pro
won(bill, tom).
won(bill, jerry).
won(bill, pam).
won(pam, jerry).
won(tom, jerry).

category(X, sportsman) :- won(X, _), won(_, X), !.
category(X, winner) :- won(X, _), !.
category(X, loser) :- won(_, X), !.
```
Здесь мы можем проверять человека `X` на принадлежность к категории, но если мы захотим узнать, кто относится к `sportsman`, то получим некорректный ответ (только `pam`, хотя должно быть 2 варианта).

# 23.09.22 - лекция
## Экспертные системы
**Экспертные системы** - программы, решающие задачи, трудные для профильных экспертов, на сопоставимом с этими экспертами уровне.

Работоспособность ЭС определяется в первую очередь её **наращиваемой базой знаний**

**Экспертные системы предназначены для решения неформализованных задач**. К таким задачам относятся те, которые обладают хотя бы одной из следующих характеристик:
- Не могут быть заданы в числовой форме
- Цель не может быть выражена точной целевой функцией
- Не существует алгоритмического решения задачи, либо оно слишком затратно по ресурсам

ЭС обладает следующими свойствами:
- Алгоритм решения задач не известен заранее, а строится на эвристических методах
- Прозрачность - ЭС может точно объяснить, на основании каких фактов был сделан вывод
- Способность приобретения новых знаний от пользователя-эксперта и изменение своих выводов на основании новых знаний
- User-friendly интерфейс

## Структура типовой экспертной системы
![](./materials/lectures/23-09-22%20-%20структура%20ЭС.jpeg)

- Рабочая память - хранит исходные и промежуточные данные решаемой в данный момент задачи
- База знаний - включает факты и правила, описывающие данную предметную область
- Решатель
- Подсистема приобретения знаний
- Подсистема объяснений
- Интерфейс

В разработке ЭС участвуют:
- Эксперт
- Инженер знаний *
- Программист

Режимы работы ЭС:
- Приобретение знаний
- Решение задачи


## ЭС в Prolog
Существует 2 способа организации логического вывода:
- Прямой - Выдаёт предположения на основании имеющихся факторов и данных
- Обратный - Рассматривает заключения, которые могут быть истинными или ложными (backward-chain)

`asserta(fact).` - добавляет факт в базу знаний пролога

*добавить пример с пояснениями*

## Сетевая модель
**Формальная система** - совокупность абстрактных объектов и правил манипулирования ими. Такая система состоит из:
- конечного алфавита
- определённая процедура построения правильных формул
- выделено множество аксиом
- заданы правила вывода, позволяющие вывести из одних формул другие

# 23.09.29 - лекция
## Продолжаем про сетевые модели и формальные системы
*Как же я "соскучился" по дискретке из первого семестра...*

Повторили исчисления предикатов (логика первого порядка):
- аксиомы
- метод резолюций
- замену импликации
- внесение отрицания
- сколемизацию - избавление от кванторов $\exist$
- переход к ПНФ (*ПРЕНЕКСНОЙ*) - вынесение кванторов влево
- переход к КНФ
- избавление от кванторов всеобщности
- разбиваем на отдельные дизъюнкты и приходим к противоречиям (либо не приходим)

**ВАЖНО:** обычно для доказательства действуют так:
1. Формулируют предпосылку
2. Формулируют заключение
3. Отрицают заключение
4. Упрощают предпосылку и заключение
5. Если приходим к противоречию, значит заключение верно (ведь мы получили противоречие из его отрицания)

Далее рассказываются о плюсах исчисления предикатов (*их нет... Ну почти*), а недостатком является монотонность - если какое-то высказывание уже было вычислено, но должно было измениться вследствие новых фактов, то оно не изменится.

# 23.10.04 - семинар
Предикат `findAll(what, when, where)` - дай все конструкции вида `what`, которые удовлетворяют условию `when` и сложи их в список `where`.

`bagof` с такой же сигнатурой. Работает похоже, но группирует массив результатов по всем допустимым значениям свободных переменных.

`setof` очень похож на `bagof`, но собирает результат в множество, а не список (*т.е. элементы не повторяются*)

Чтобы отключить группировку по свободным переменным, записываем параметр `when` в формате `X^pred(X, ...)` - группировки по `X` производиться не будет

*Разностные списки - это тема!*

# 23.10.06 - лекция
## Сетевая модель
Формально сетевую модель можно задать так: $H = <I, C, \Gamme>$:
- $I$ - информационные единицы
- $C$ - множество типов связей между информационными единицами
- $\Gamme$ - Отображение, задающее связи из $C$ между единицами из $I$

**Семантическая сеть** - ориентированный граф, где в вершинах находятся информационные единицы, а в рёбрах - типы связей.

*Дальше идёт непонятно зачем нужное душнилово о строгом определении семантической сети через теорию реляционных БД*

**Интенсионал** - абстрактное описание

### Типы семантических сетей
По виду вершин
- Простые - вершины не имеют внутренней структуры
- Иерархические - вершина обладает некоторой структурой (в т.ч. сама может быть семантической сетью)

По типу дуг (отношений)
- Однородные - если все дуги одного типа
- Бинарная - если используются только бинарные отношения
  - Сценарии - используют отношение нестрого порядка (причинно-следственное, временное, следование "род-вид")

### Классификация отношений
- Отношения таксономии:
  - класс-подкласс (SUB), множество-подможество - между понятиями
  - элемент-класс (ISA), элемент-множество - между экземплярами понятий и понятиями
- Отношение партономии:
  - часть-целое (Part_of) - отношение включения одного понятия (объекта) в другой
- Атрибутивные отношения или отношение свойство-значение:
  - значение("цвет" / "вес" / ...)
- Логические (и, или, не и т.п.)
- Темпоральные (раньше, позже, одновременно и т.п.)
- Пространственные (далеко от, близко к, под, над и т.п.)
- Глубинно-падежные семантические отношения Филмора - служат для описания глубинных семантический отношений между группой существительного и действием (агент, объект, инструмент, время действия)

По отношениям таксономии и партономии **устанавливается иерархия понятий семантической сети и организуется наследование свойств и понятий**. За счёт этого описание модели становится более компактным

![](./materials/lectures/23-10-06%20-%20семантическая%20сеть.png)

### Достоинства и недостатки
Достоинства:
- Высокая выразительность и гибкость
- Универсальность при выборе нужного набора отношений
- Наглядность представления
- Соответствие современным представлениям об организации долговременной памяти человека

Недостатки:
- При росте числа отношений и вершин сеть быстро становится запутанной
- Поиск решения в семантической сети сводится к поиску фрагмента сети, соответствующего образцу, отражающему наш запрос. Эта задача может выполняться очень долго

### Функциональная сеть
Вид семантической сети, которая представлена двудольным графом. В одной доле вершины-объекты (переменные), в другой - вершины-операторы (функции)

Дуги от переменных к операторам показывает, что вершина-объект - аргумент вершины-функции. Дуга от функции к объекту показывает, что объект - результат выполнения функции.

![](./materials/lectures/23-10-06%20-%20функциональная%20сеть.png)

### Фреймы
**Фрейм** - структура данных, представляющая стереотипную ситуацию. Фрейм является совокупностью знаний о некоторой понятии или явлении.

По своей организации фрейм похож на иерархическую семантическую сеть. Верхние узлы представляют общие понятия, нижние - более конкретные. Понятие в каждом узле определяется набором атрибутов и их значений, атрибуты называются **слотами**. Каждый слот может быть связан с определёнными процедурами, которые будут исполняться при изменении значения слота.

*Добавить картинку с наглядным представлением*

# 23.10.11 - семинар
## Экспертные системы
[Теория про экспертные системы тут](#экспертные-системы)

### Goal-driven backward
Идёт от предположения (гипотезы) к отдельным фактам. Если они истины, значит гипотеза верна.

Хорош, когда много данных, но гипотез много.

Элементарный пример без пользовательского интерфейса, с заданными заранее фактами:
```prolog
:- dynamic bathroom_dry/0.
:- dynamic window_closed/0.
:- dynamic no_rain/0.


hall_wet.

kitchen_dry.

leak_in_bathroom :- hall_wet, kitchen_dry.

problem_in_kitchen :- hall_wet, bathroom_dry.

no_water_from_outside :- window_closed; no_rain.

leak_in_kitchen :- no_water_from_outside, problem_in_kitchen.
```
Теперь мы можем задать вопросы и получить ответы:
```prolog
1 ?- leak_in_kitchen.
false.

2 ?- leak_in_bathroom.
true.
```

Эта ЭС очень плоха: мы задаём факты прямо в коде, а надо использовать UI (или хотя бы шэлл).

Экспертная система должна отвечать на вопросы `HOW?`, `WHY?`

Для начала зарегистрируем несколько по-человечески звучащих предикатов:
```
:- op(800,  fx, if).
:- op(300, xfx, then).
:- op(300, xfy, and).
:- op(200, xfu, or).
```
Этот предикат регистрирует предикат как оператор. 
- Первый аргумент - приоритет (от 0 до 1200). 
- Второй - ассоциативное поведение: 
  - `fx` - унарный оператор
  - `xfx` - обоассоциативен
  - `xfy` - правоасоциативен
  - `yfx` - левоасоциативен
- Третий - имя оператора

Преобразованная ЭС будет выглядеть так:

```prolog
known(hall_wet).
known(kitchen_dry).

% Делаем так, чтобы при Пролог мог обрабатывать выражения с использованием этих операторов, то есть рабабатываем движок ЭС
true(A) :- known(A).
true(A and B) :- true(A), true(B).
true(A or B) :- true(A); true(B).
true(Conclusion) :- 
  if Condition then Conclusion,
  true(Condition).
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         KNOWLEDGE BASE                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if
    hall_wet and kitchen_dry
then
    leak_in_bathroom.


if
    hall_wet and bathroom_dry
then
    problem_in_kitchen.


if
    window_closed or no_rain
then
    no_water_from_outside.


if
    problem_in_kitchen and no_water_from_outside
then
    leak_in_kitchen.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         KNOWLEDGE BASE                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
```

### Data-driven forward
Идёт от фактов к выводам, записывая их по пути. 

Хорош, когда данных мало, а гипотез много

`asserta(pred)` / `assertz(pred)` - добавляет в код Пролога предикат в начало или конец соответственно. Чтобы операции работали, необходимо определить динамически `:- dynamic pred`.

`retract(pred)` удалит из кода первое вхождение предиката. `retract_all(pred)` - удалит все вхождения предиката.

<blockquote><code>\+</code> - операторная форма <code>not()</code></blockquote>

```prolog
:- dynamic derived/1.
% Clear all derived relations on program startup
:- retractall(derived(_)).

% Fact is either something that is already derived or a combination
% of the other derived facts.
fact(F) :- derived(F).
fact(F1 and F2) :- fact(F1), fact(F2).
fact(F1 or F2) :- fact(F1) ; fact(F2).

% Some statement is derivable if it is not derived yet, and
% if there is a rule of a form
% IF Cond THEN Statement where Cond is already a known fact
derivable(Conclusion) :-
  if Condition then Conclusion,
  \+ derived(Conclusion),
  fact(Condition).

% Keep trying to derive facts while there is information
fc :-
  derivable(Statement), !,
  format('Inferred that ~w;\n', [Statement]),
  assertz(derived(Statement)),
  fc ;
  write('---------------------------------').

fc_inference :-
  retractall(derived(_)),
  asserta(derived(S) :- known(S)), % После очистки списка выведенных фактов снова заносим в него известные заранее
  fc.
```

### Смешанный вывод
Получаем часть фактов и выбираем гипотезы, которые, вероятно, подошли бы нам. А затем идёт от гипотезы к фактам.

Смешанная ЭС будет самой оптимальной для большинства предметных областей. Исключениями будут частные случаи, когда между данными и гипотезами есть сильный переход в одну из сторон.

```prolog
% Выбираем заключение, которое ещё не выведено и не отклонено на основании выведенных фактов
suppose(Concl) :-
  derived(F),
  (
    Cond = F ;
    Cond = F and _ ;
    Cond = _ and F ;
    Cond = F or _ ;
    Cond = _ or F
  ),
  if Cond then Concl,
  \+ rejected(Concl),
  \+ derived(Concl).

hc :-
  supposed(Statement),
  !,
  ( true(Statement)
    ->
      format('Inferred that ~w;\n', [Statement]),
      asserta(derived(Statement))
    ; 
      assertz(rejected(Statement))
  ), % Нотация в скобках является ветвление вида (if_preds -> then_preds ; else_preds)
  hc ;
  write('---------------------------------').

hc_inference :-
  retractall(derived(_)),
  retractall(rejected(_)),
  asserta(derived(S) :- known(S)),
  hc.
```

# 23.10.13 - лекция
## Продукционная модель
**Система продукций Поста** определяется алфавитом S и правилами вида `aW -> Wb` - если в слове обнаруживается префикс `a`, то он вычёркивается, а в конец добавляется постфикс `b`.

**Нормальные алгоритмы Маркова** представляют собой правила `a -> b`, которые, в отличие от продукций Поста, применяются последовательно. Финальное правило записывается точкой.

**Формальные грамматики** - `<V, T, P, Z>`: `V` - алфавит, `T <= V` - терминальные символы, `P` - правила перехода, `Z` - начальный символ

### Программные продукционные системы
- База данных - рабочая память, над которой работают правила
- Множество правил-продукция - могут быть и весьма сложными, но суть одна: слева условие, а справа действие
- Интерпретаторы - поисковый процесс, состоящий из выбора продукции и её применения

Выбор продукции сводится к двум задачам:
- Максимально ограничить число проверяемых продукций
- Из полученного множества выбрать не больше одной продукции

**Конфликтные продукции** - множество, для которого условие во всех продукциях будет истинным. Для разрешения конфликтов есть 3 варианта:
- Случайный выбор
- Статический выбор на основании заданных изначально приоритетов
- Динамический выбор - продукциям в ходе исполнения будут записываться определённые параметры, определяющие приоритетность

Управляющие стратегии разрешения конфликтов подразделяют на:
- Безвозвратные - разрешив конфликт, мы уже далее не имеем возможности вернуться к этому моменту и изменить выбор
- Пробный (бэктрекинг) - противоположна безвозвратной

### Стратегии применения
*Описывается прямая и обратная стратегии, который почти в точности повторяют методы с [семинара](#231011---семинар)*

### Классификация систем продукции
СП могут делиться по тому, как они решают проблему активации продукции.

#### Простые СП
Активными считаются все продукции.

Применим к СП с небольшим количеством правил либо к таким, где структуризация и принудительная активация противоречат принципам СП.

Примером просто СП является в том числе и Prolog

#### Управляемые СП
- СП с независимым управляющим языком
  - Содержит "чистые продукции" и стратегию их применения (напоминает полином). Повышают эффективность применения продукций, недостаток - статичность и жёсткость управления.
- Иерархические СП
  - Используют метапродукции, которые могут активировать или деактивировать обычные продукции
- Последовательные СП
  - СП делится на соединённые последовательно продукционные модули, которые соответствуют определённому этапу обработки знаний 
- Параллельно-последовательные СП
  - ТАкже разбивается на продукционные модули, но работают они параллельно и имеют общую память

### Плюсы / Минусы СП
Плюсы:
- Универсальность
- Естественность представления знаний через импликацию
- Высокая модульность

Минусы:
- Низкая эффективность в сравнении с традиционными языками
- Повышенная сложность контроля правильности процесса
- Сложно отслеживать непротиворечивые правила

### Использование СП
- Построение компиляторов
- Автоматическая обработка текстов
- Распознавание и синтез речи
- Экспертные системы

# Что надо на КР
- Метод резолюций
- Нечёткие модели