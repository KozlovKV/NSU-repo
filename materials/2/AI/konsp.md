- [Инфо](#инфо)
- [23.09.06 - семинар](#230906---семинар)
  - [Базовые понятия в prolog](#базовые-понятия-в-prolog)
- [23.09.08 - лекция](#230908---лекция)
- [23.090.13 - семинар](#2309013---семинар)
  - [Списки](#списки)
  - [Дополнительный арифметический модуль](#дополнительный-арифметический-модуль)
- [23.09.15 - лекция](#230915---лекция)
  - [Предикаты для управления исполнение программ](#предикаты-для-управления-исполнение-программ)
  - [Рекурсия](#рекурсия)
  - [Списки](#списки-1)


# Инфо
Лектор - Загорулько Виктор Алексеевич

Семинарист - Серый Алексей Сергеевич

# 23.09.06 - семинар
Логическое программирование - парадигма, являющаяся вариацией декларативного программирования, основанная на логике предикатов (высказывание, *привет, дискретка!*). Программа в этой парадигме обычно работает лишь с заданными данными и не содержит внешней логики (связей с другими кусками кода и т.п.)

Используется для удобного отображения баз знаний, логических выводов, обработки естественных языков и т.п.

Логическое программирование позволяет создавать ИИ, работающий по формальной логике, то есть основанный на чёткий правилах и делающий выводы в их рамках.

Программы в парадигме логического программирования очень сложно масштабировать, так как количество необходимых к прописыванию правил растёт экспоненциально.

## Базовые понятия в prolog
- `Fact` - используются для обозначения безусловной истины
- `Rules` - выражения, которые могут быть правдой
- `Knowledge base` (`database`) - набор правил и фактов. База знаний - это и есть программа на прологе. Взаимодействие с ней происходит через написание запросов (`queries`)
- `Query` - это запрос (*неожиданно*). Пролог проверяет, может ли быть ответом на запрос `true`. Если да, то выводит все значения переменных (`variables`), при которых это так, иначе отвечает `false`

Простейшая `database` выглядит так:
```prolog
kind(fruit, orange).
kind(fruit, apple).
kind(veg, tomato).
kind(veg, carrot).
color(red, apple).
color(red, tomato).
color(orange, orange).
color(orange, carrot).
```
Запросы к ней:
```prolog
?- kind(veg, X).
// X = tomato
// X = carrot

?- color(orange, X).
// X = orange
// X = carrot

?- kind(veg, X), color(Y, X).
// X = tomato,
// Y = red
// X = carrot,
// Y = orange
```

Пример с базовыми логическими операторами:
```prolog
playsGames(kirill).
playsGames(artyom).
playsGames(igor).
donates(kirill).
donates(artyom).
donates(dima).

hardGamer(G) :-  playsGames(G), not(donates(G)).
anyGamer(G) :- playsGames(G) ; donates(G).
```
Запросы:
```prolog
?- hardGamer(kirill).
// false

?- hardGamer(X).
// X = igor

anyGamer(X).
// X = kirill
// X = artyom
// X = igor
// X = kirill
// X = artyom
// X = dima
```

Отсюда можно заметить следующие обозначения:
1. `,` - И
2. `;` - ИЛИ
3. `:-` - $\larr$ (обратная импликация)
4. `!` - **?**

Если правило записать в несколько строк, то оно будет работать как pattern-matching

**Terms** (выражения) в Прологе строятся из атомов, чисел, строк, переменных и других термов:
- Атом - произвольный набор символов без пробела с маленькой буквы либо **абсолютно** произвольный набор символов в **одинарных** кавычках либо спецсимволы
- Числа - целые и вещественные (*через точку, ваш кэп*)
- Переменные - строка без пробела, начинающаяся с большой буквы либо `_`, либо **абсолютно** произвольная строка в **двойных** кавычках

Составные выражения должны называться термом-**атомом**, аргументы должны идти через запятую в скобках и могут быть термом любого типа (да-да, хоть числом)

# 23.09.08 - лекция
*У препода лёг комп из-за флэшки. Скайнет победил*

Все определения ИИ так или иначе сводятся к системе, способной моделировать традиционно считающиеся творческими задачи.

Существует 2 подхода к моделированию мышления:
1. Символьный (логический) - оперирование символами и понятиями, построение формальных моделей и соответствующих им механизмов рассуждений
2. Нейросетевой - строится на идее, что на мышление способен только человеческий мозг, а значит основная цель - построить модель человеческого мозга из нейронов и связей между ними, то есть создать нейронную сеть

Используется ИИ во многих областях: представление знаний, распознавание языка, синтез речи и изображений, анализ данных, экспертные системы.

Машинное обучение - методы ИИ, суть которых заключается не в прямом решении задачи, а в решении подобных задач. Используется для них много разных методов: матстат, графы, тервер и т.п.

Объяснимый ИИ - набор методов, позволяющий понять, почему алгоритмы машинного обучения пришли к определённому выводу.

В правилах можно использовать и простое равенство:
```prolog
likes (beth, X) :–
  likes (mаrу, X),
  X = popcorn. 
```

# 23.090.13 - семинар
## Списки
Элементами терма могут быть атомы, переменные, термы и списки.

`|` отсоединяет голову от хвоста (*да-да, как в Haskell*). При этом можно в качестве головы взять несколько элементов: `f([X, Y, Z | Tail])` - взять 3 первых элемента. При попытке взять больше элементов, чем есть в массиве, возвращается `false`

Предикат `member(x, [...])` возвращает `true` столько раз, сколько в списке встречается атом `x`. Можно проверять как предикат в обе стороны: то есть проверять, входит ли элемент в список, а также в какие списки будет входить элемент.

Собственная реализация `member`:
```pro
mem(X, [H|TAIL]) :- X = H ; mem(X, TAIL).
```
При этом нет необходимости прописывать вариант `mem(X, []) :- fail.`, так как всё не прописанное в прологе считается ложью.

`append(a, b, c)` - истина `<=>` список `c` - конкатенация `a` и `b`. При разных запросах эта операция может не только объединять списки.

Собственная реализация `append`:
```pro
app([], [], []).
app([], [B|BTail], [B|RTail]) :- app([], BTail, RTail).
app([A|ATail], BTail, [A|RTail]) :- app(ATail, BTail, RTail).
```
Здесь ещё несколько фишек Пролога:
- Записи из одного лишь правила **истинны всегда** (*если задуматься, то и логично, ведь так и строятся базы знаний из всех примеров выше*)
- Указав одну и ту же букву в правиле в нескольких местах, мы сразу говорим, что значение на этих местах **должно быть равно**

*А на самом деле можно сделать запись ещё короче и приятнее (хотя последнее немного спорно)*
```pro
appnd([], B, B).
appnd([A|ATail], B, [A|R]) :- appnd(ATail, B, R).
```

Используя конкатенацию, можем добавить много разных предикатов:
```pro
end(E, L) :- appnd(_, [E], L).

leftShift(S, [L|Tail]) :- appnd(Tail, [L], S).
```

## Дополнительный арифметический модуль
Стандартная арифметика пролога обязательно требует определённых чисел, поэтому вместо неё используется библиотека `clpfd`. Для подключения библиотеки в начале кода надо написать `use_module(library(clpfd)).` (*это библиотека для целых чисел, для плавающих используется `clpr`*)

Перед многими символами операций пишется `#`:
```pro
?- X is 3 + 5. // Стандартная математика
// X = 8.
?- X #= 3 + 5. // Вывод будет таким же

?- 8 is X + 5. // Ошибка
?- 8 #= X + 5.
// X = 3.
```

# 23.09.15 - лекция
## Предикаты для управления исполнение программ
Выполнение пролог-программы основывается на дереве решений.

Чтобы сократить количество просматриваемых вариантов, используются предикаты `fail` и cut (`!`)

В прологе используется **отрицание по невыполнимости**, то есть утверждение истинно тогда и только тогда, когда мы можем доказать его на основании имеющихся фактов.

Предикат `!` *до сих пор до конца не понятен*, но вроде как если слева от `!` истина, то поиск в дереве решений будет приостановлен, иначе поиск решений продолжится.

## Рекурсия
Группа правил с одним и тем же именем называется **процедурой**.

По классике в рекурсии содержится базис и шаг.

Как и везде, рекурсия очень жёстко ест стэк, поэтому используется **хвостовая рекурсия**. 

*Краткое напоминание:* хвостовая рекурсия основывается на вычислении при **движении вглубь**, чтобы на обратном пути мы могли просто возвращать итоговое значение на самый верх.

В отличие от операторов строгости в Haskell, здесь для работы хвостовой рекурсии требуется делать рекурсивный вызов в самом конце (*ну и создавать накопительный параметр, ясное дело*).

## Списки
