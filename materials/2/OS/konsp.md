- [Инфо](#инфо)
- [Доп. инфо](#доп-инфо)
  - [Надо понять](#надо-понять)
  - [Вахалия - "Unix изнутри", глава 8 - Базовые элементы и интерфейс файловой системы](#вахалия---unix-изнутри-глава-8---базовые-элементы-и-интерфейс-файловой-системы)
    - [Механизм работы с символьными устройствами](#механизм-работы-с-символьными-устройствами)
    - [vnode/vfs](#vnodevfs)
    - [*пауза, стр. 366.* Монтирование ФС](#пауза-стр-366-монтирование-фс)
  - [Вахалия - "Unix изнутри", глава 16 - Ввод-вывод и драйверы устройств](#вахалия---unix-изнутри-глава-16---ввод-вывод-и-драйверы-устройств)
  - [Некоторые функции и системные вызовы](#некоторые-функции-и-системные-вызовы)
  - [Распределение памяти, работа API malloc/free](#распределение-памяти-работа-api-mallocfree)
  - [`fork`, `exec`, `wait` - комментарии к 9-й лабе](#fork-exec-wait---комментарии-к-9-й-лабе)
- [23.09.04 - лекция (Введение. Системы семейства Unix)](#230904---лекция-введение-системы-семейства-unix)
  - [Как работать, что читать, *КАК ВЫЖИТЬ*???](#как-работать-что-читать-как-выжить)
    - [Номера секций для `man`](#номера-секций-для-man)
- [23.09.11 - лекция](#230911---лекция)
  - [Среда исполнения](#среда-исполнения)
    - [Ядро](#ядро)
    - [Наконец, определение процесса](#наконец-определение-процесса)
    - [Терминальная сессия](#терминальная-сессия)
    - [Атрибуты процесса](#атрибуты-процесса)
  - [Эффективные идентификаторы](#эффективные-идентификаторы)
- [23.09.18 - лекция](#230918---лекция)
  - [Атрибуты процесса (продолжение)](#атрибуты-процесса-продолжение)
    - [Пользователь](#пользователь)
    - [Пользовательский стэк](#пользовательский-стэк)
  - [Доступ к системным переменным (атрибутам системы)](#доступ-к-системным-переменным-атрибутам-системы)
  - [Пользовательский стэк (стэк процесса)](#пользовательский-стэк-стэк-процесса)
  - [Доступ к переменным среды](#доступ-к-переменным-среды)
    - [Конкретные переменные среды](#конкретные-переменные-среды)
    - [`TZ`](#tz)
    - [Изменение переменных среды](#изменение-переменных-среды)
  - [`setuid`](#setuid)
  - [Системные вызовы ввода/вывода](#системные-вызовы-вводавывода)
    - [Что такое файл?](#что-такое-файл)
- [23.09.25 - Лекция](#230925---лекция)
  - [Файловая система и где хранятся файлы](#файловая-система-и-где-хранятся-файлы)
    - [Основные папки в корне Линукс](#основные-папки-в-корне-линукс)
  - [Продолжаем про определение и основные свойства файла](#продолжаем-про-определение-и-основные-свойства-файла)
  - [Системный вызов `open(2)`, дескрипторы файлов, `file_t` и `vnode`](#системный-вызов-open2-дескрипторы-файлов-file_t-и-vnode)
    - [Как работает `open(2)`](#как-работает-open2)
  - [`close(2)`](#close2)
  - [`tmpfile`](#tmpfile)
  - [`read(2)`](#read2)
  - [`write(2)`](#write2)
  - [Стандартные потоки и их связь с дескрипторами](#стандартные-потоки-и-их-связь-с-дескрипторами)
- [23.10.02 - лекция](#231002---лекция)
  - [`fsync(2)`](#fsync2)
  - [`lseek(2)`](#lseek2)
  - [`dup(2)`](#dup2)
  - [`fcntl(2)`](#fcntl2)
    - [`struct flock`](#struct-flock)
  - [*Хуяк!* И тут у нас управление памятью](#хуяк-и-тут-у-нас-управление-памятью)
    - [Веселуха с динамической памятью и попытки её решить](#веселуха-с-динамической-памятью-и-попытки-её-решить)
- [23.10.09 - лекция](#231009---лекция)
  - [Продолжение про выделение памяти](#продолжение-про-выделение-памяти)
    - [Слабовые аллокаторы](#слабовые-аллокаторы)
    - [Сборка мусора](#сборка-мусора)
      - [Генерационная сборка мусора](#генерационная-сборка-мусора)
  - [Виртуальная память](#виртуальная-память)
    - [Ещё раз про сравнение пользовательского и системного режима](#ещё-раз-про-сравнение-пользовательского-и-системного-режима)
    - [Чем плоха базовая адресация](#чем-плоха-базовая-адресация)
      - [КРИТ ПРО СЕЛЕКТОР И ДЕСКРИПТОР](#крит-про-селектор-и-дескриптор)
- [23.10.16 - лекция](#231016---лекция)
  - [Продолжаем про виртуальную память](#продолжаем-про-виртуальную-память)
    - [Дополнительные возможности MMU](#дополнительные-возможности-mmu)
      - [ЧЕМ ОТЛИЧАЮТСЯ ИСКЛЮЧЕНИЯ ОТ ПРЕРЫВАНИЙ](#чем-отличаются-исключения-от-прерываний)
    - [Дескриптор страницы `80386`](#дескриптор-страницы-80386)
    - [Многоуровневая трансляция в `x32` у Intel](#многоуровневая-трансляция-в-x32-у-intel)
    - [Многоуровневая трансляция в `x64` Intel](#многоуровневая-трансляция-в-x64-intel)
    - [ARM](#arm)
    - [Как проходит переключение процессов](#как-проходит-переключение-процессов)
    - [Page swapping - страничная подкачка](#page-swapping---страничная-подкачка)
      - [Поиск жертвы для новых страниц](#поиск-жертвы-для-новых-страниц)
  - [Возвращаемся к практической части](#возвращаемся-к-практической-части)
    - [`mmap`](#mmap)
    - [`munmap`](#munmap)
    - [`msync`](#msync)
- [23.10.23 - лекция](#231023---лекция)
  - [Параллелизм](#параллелизм)
    - [Практические проблемы параллельного программирования](#практические-проблемы-параллельного-программирования)
      - [КРИТ ПО КРИТИЧЕСКОЙ СЕКЦИИ](#крит-по-критической-секции)
        - [Подходы к решению проблемы критических секций](#подходы-к-решению-проблемы-критических-секций)
    - [Решение проблемы критических секций через блокировки](#решение-проблемы-критических-секций-через-блокировки)
      - [Проблемы методов блокировки](#проблемы-методов-блокировки)
    - [Блоикровка через гармоническое взаимодействие](#блоикровка-через-гармоническое-взаимодействие)
      - [Проблемы гармонического взаимодействия](#проблемы-гармонического-взаимодействия)
  - [Параллелизм на практике](#параллелизм-на-практике)
  - [КРИТ ПРО КОНТЕКСТ ПРОЦЕССА](#крит-про-контекст-процесса)

# Инфо
Лектор - Иртегов Дмитрий Валентинович

Семинарист - Куталев Андрей Витальевич ([bitgrandmaster@yandex.ru](mailto:bitgrandmaster@yandex.ru))

[Более-менее актуальные лекции](http://parallels.nsu.ru/~fat/unixsvr4-new/trunk/)

[Как сдавать задачи](https://classroom.google.com/u/3/c/NTg5NDgxNTc4ODA4/m/NjIwNjE0NDU3ODY4/details)
- [Задачи](https://docs.google.com/document/d/1242C_65gJ_8HscvJ4RolW09KGS-jieYWwomrRTK_bn0/edit#heading=h.v7414bii3pa)

# Доп. инфо
Вакхалия - "Unix изнутри"

## Надо понять
*Тут собраны вопросы, которые по той или иной причине не были отвечены при сдаче лаб, но, на мой взгляд, играют большую роль*

- Вахалия - Файлы (стр. 331)
- Вахалия - ввод-вывод и драйвера (стр. 731)
- Иртегов - драйверы (стр. 563)
- Иртегов - файлы (стр. 631)
- Что такое процесс? Какими атрибутами он обладает и где они хранятся?
- Как детально работает `mmap`? Где хранится листинг памяти? (*В ядре?*)
- Как блокируется исполнение процесса, когда запущен `wait`? (возможно не только в этом случае)

## Вахалия - "Unix изнутри", глава 8 - Базовые элементы и интерфейс файловой системы
### Механизм работы с символьными устройствами
![](./materials/additional/symbolic_device.png)

### vnode/vfs
`vnode` расшифровывается как Virtual node и не является тем же самым, что и `inode` (index node). Виртуальная нода - абстрактный "класс" (в той степени, в какой это понятие вообще применимо к языку C), который определяет базовые поля и функции, которые должны быть в какой-либо форме у элементов любой файловой системы. Индексная нода - уже конкретная реализация для регулярных файлов в файловых системах `s5fs` и `ufs` - в других системах структура может быть иной (`rnodes` у NFS).

В `vnode` и `vfs` есть 2 основных закрытых поля: ссылки на данные (`*_data`) и функции (`*_ops`) - их конкретная реализация зависит от файловой системы

В `vnode` зачастую `v_data` напрямую встраивается в структуру `vnode` (*то есть абстрактную часть структуры переписывают для каждой ФС*)

<img src="./materials/additional/vnode.png" width="40%">
<img src="./materials/additional/vnodes_ops_data.png" width="55%">

*Код структуры `vnode` смотри [ниже](#системный-вызов-open2-дескрипторы-файлов-file_t-и-vnode)*

`vfs` - virtual file system - также абстракция, стандартизирующая различные файловые системы и позволяющая монтировать их в единое дерево и использовать бесшовно

<img src="./materials/additional/vfs.png" width="60%">

Не буду приводить здесь весь список парадигм `vfs`, отмечу лишь, что они должны быть stateless (не хранить результат работы в глобальных переменных, а записывать его по конкретным указателям или возвращать через `return`), уметь пользоваться в мягком режиме (не отбирая) ресурсами ОС и поддерживать серверную реализацию

![](./materials/additional/vfs_list.png)

В отличие от `vnode` в реализации `vfs` редко хардкодится `vfs_data`:

<img src="./materials/additional/vfs_ops.png" width="80%">

### *пауза, стр. 366.* Монтирование ФС

## Вахалия - "Unix изнутри", глава 16 - Ввод-вывод и драйверы устройств

## Некоторые функции и системные вызовы
После функции будет стоять `2`, если это системный вызов, и `3C`, если это C-библиотека
- `perror()` - `3C` - будет часто использоваться, и очень удобна для вывода ошибок в `stderr`
- `time()` - `2` - возвращает время в секундах с начала **ЭПОХИ (1 января 1970, 00:00:00 UTC)**

## Распределение памяти, работа API malloc/free
[Статья с базовыми принципами](https://habr.com/ru/companies/ruvds/articles/740466/):
- `malloc` выделяет указанное количество байт в виртуальной памяти и возвращает указатель на начало выделенной области либо `NULL`, если память не была выделена
- Чтобы `free` мог очищать отдельные блоки памяти, он должен знать их стртовый адрес и размер блока
- Если освобождаются несколько лежащих рядом блоков, они объединяются в одной общее свободное пространство. Этот метод называется `coalescing`
- Возникает проблема фрагментации памяти: если мы выделяем маленькие куски памяти, а потом избавляемся лишь от части из них, мы получим область памяти, в которой возможно много свободных ячеек, но идут они не последовательно, а значит не могут быть использованы
  - **Решение: избыточное выделение памяти** - выделять память блоками, допустим, по 4 байта. Тогда при очистке у нас будет куда больше свободной памяти. **Проблема:** если мы много раз выделяем малые объёмы памяти, то с точки зрения программы занятой будут считаться многие ячейки, которые на самом деле свободны
    - **Решение:** использовать разные участки памяти для выделения памяти разного размера. Например, выделить 25% для малых участков (меньше 4 байт), а остальную - для больших
- `boundary tag allocator` - для каждого участка памяти используются дополнительные ячейке:
  - `address` - здесь записан размер блока памяти (`size`)
  - `status` - флаг, указывающий, занят этот блок или нет
  - `address + 2 + size` - конец блока памяти, также хранит `size`. Это необходимо для реализации `coalescing`

## `fork`, `exec`, `wait` - комментарии к 9-й лабе
*Переписать в человеческий вид*
```
fork(2)
  pid_t fork(void) - создаёт процесс-потомок копированием текущего процесса. 
    Наследует открытые дескрипторы и некоторые другие ограничения (uid, sid, pgid, gid)
    Наследуется всё адресное пространство. При этом используется парадигма copy-on-write, 
      то есть копирование памяти производится только перед первой попыткой записи (кроме сегментов, выделенных с флагом MAP_SHARED)
    В процессе-родителе возвращает PID созданного потомка, в потомке - 0

exec(3) - функции этого вида заменяют образ процесса на новый (переписывает TEXT, DATA, BSS и STACK), запуская тем самым какую-то другую программу.
  Из такого механизма запуска также следует то, что исполнение кода исходного процесса не продолжится после завершения вызванного exec
  все функции записываются как `exec(l/lp/le/v/vp/vpe)`. Первым аргументом всегда идёт путь до исполняемого файла, далее идут различия в зависимости от суффиксов
    - за аргументы, передаваемые вызываемому файлу, отвечают флаги:
      - l - аргументы идут через запятую (первый аргумент - имя исполняемого файла, последний - (char*)NULL)
      - v - аргументы передаются как указатель на char** (принцип тот же, что при передаче аргументов в main)
      - e - после аргументов передаются переменные окружения через char** envp (execve(char* path, char** args, char** envp))
    - p - вместо пути до исполняемого файла можно указывать его имя. Тогда файл будет искаться в директориях из PATH. Если имя начинается с "/", значит указывается путь и PATH будет игнорироваться
  
  Все описанные выше функции являются обёрткой над системным вызовом execve(2):
  int execve(char* filename, char** args, char** envp) - из описанных суффиксов значение аргументов должно быть ясно

wait(2) - системные вызовы из этой группы используются для того, чтобы в процессе-родителе дождаться изменения состояния процесса-потомка
  Возможные изменения: ребёнок прекратился, был остановлен или продолжен сигналом
  pid_t waitpid(pid_t pid, int* status, int options) - останавливает исполнения до момента изменения состояния потомка с ID pid.
    Возвращает pid_t процесса-потомка, который изменил своё состояние
    Значения pid:
      < -1 - любой процесс-потомок из PGID = |pid|
      -1 - любой потомок
      0 - любой потомок с таким же PGID, что и у текущего процесса
      > 0 - процесс с PID = pid
    options - побитовый набор флагов (то есть собираются через побитовое ИЛИ):
      WNOHANG - продолжится исполнение, если ни один процесс не завершился. При успешном исполнении вернёт 0
      WUNTRACED - ребёнок остановился (но не отслеживается через ptrace(2))
      WCONTINUED - ребёнок продолжил исполнение (получил сигнал SIGCONT)
    В аргумент int* status, если он не равен NULL, записывается состояние ребёнка, которое можно проверить макросами из wstat(2)

  pid_t wait(int* status) - останавливает исполнение до момента, пока любой из потомков процесса не завершится.
    Эквивалентное waitpid(-1, &status, 0)

  waitid() - более новый системный вызов, дающий больше контроля. Не очень актуален для наших задач.

  Выполнять wait в какой-либо из форм КРАЙНЕ ЖЕЛАТЕЛЬНО, так как иначе будут возникать процессы-зомби (см. блок про exit(2))

wstat(2) - (сейчас находится в разделе wait(2)) - набор макросов для проверки статуса, записанного в int status функций wait(2):
  WIFEXITED(status) - true, если процесс завершился нормально (через exit() либо return в main())
    WEXITSTATUS(status) - ТОЛЬКО ЕСЛИ WIFEXITED(status) - возвращает статус возврата, который хранится в 8 младших битах status
  WIFSIGNALED(status) - true, если процесс прекратился сигналом
    WIFSIGNALED(status) - ТОЛЬКО ЕСЛИ WIFSIGNALED(status)-  возвращает номер сигнала
    WCOREDUMP(status) - ТОЛЬКО ЕСЛИ WIFSIGNALED(status) - true, если ребёнок создал core-файл
  WIFSTOPPED(status) - true, если процесс был остановлен сигналом (возможно при опции WUNTRACED или ребёнок отслеживается через ptrace)
    WSTOPSIG(status) - ТОЛЬКО ЕСЛИ WIFSTOPPED(status), возвращает номер сигнала
  WIFCONTINUED(status) - true, если ребёнок продолжил исполнение после получения сигнала SIGCONT

ptrace(2) - *не очень относится к делу, но есть её упоминания

exit(3) 
void exit(int status) - вызывает завершение программы и возвращает код завершения status & 0377 родителю
  Все потоки ввода-вывода флашатся, все временные файлы удаляются.
  После завершения процесса, некоторая информация о нём остаётся в ядре (PID, статус заврешения, информация об использованных ресурсах), чтобы её мог получить родитель через wait(2).
  До момента вызова wait в родителе процесс будет в статусе зомби
    Если родитель сам завершился, то ребёнок будет прикреплён к процессу init, который вызовет wait для УбИйСтВа ЗоМбИ!!!

  atexit(3) - ...

  on_exit(3) - ...

_exit(2)

Сигналы
  Сигнал - число, сообщающее о внешнем событии или ошибке. Посылаются от процесса к процессу или от ядра к процессу.
  Получающий процесс обрабатывает сигнал по одному из сценариев:
  - SIG_DFL - реакция по умолчанию
  - SIG_IGN - игнорирует сигнал
  - адрес функции - указанная функция перехватит сигнал
```

# 23.09.04 - лекция (Введение. Системы семейства Unix)
Unix не доминирующий, но пережил уже 2,5 поколения.

Различные системы семейства Unix:
- Android
- Linux
- WinDriver / Intel VxWorks - система реального времени для интернета вещей
- IBM AIX
- HP UX
- MacOS, IOS
- Sun microsystems / Oracle Solaris

Unix-системы различаются: 
- по лицензированию (free & open source / commerce)
- методам применения (серверы, рабочие станции, мобильные устройства и устройства умного дома)
- Аппаратная архитектура (x86/x64, ARM, MIPS, PowerPC, PA/RISC)
- Архитектура ядра (монолитное ядро, потоки, микроядро Unix SVR4, Multiple personality microkernel)

К общим особенностям семейства Unix относят:
- API - общий стандарт интерфейса ядра и системных библиотек, код совместим с точностью до перекомпиляции
- Стандартный командный язык
  - Командные процессоры sh (bash, ksh) и утилиты
  - Часть стандарта POSIX
  - Может быть недоступен (на Андроид, IOS и др.)
- Стандартный API, сетевой интерфейс и интерфейс графической оболочки

Стандарт POSIX сделает вас гига-чадом в мире программирования, включает в себя множество API, которые будут рассмотрены позже

*Кулстори: Linux появился, когда компания-владелец Unix сделала его платным, при этом Линукс не заимствовал никакого кода из Unix (а точнее, `AT&T Unics`), но повторял многий его функционал*

Unix система включает в себя:
1. Ядро
   1. Само ядро (планировщик, диспетчер системных вызовов, менеджер памяти)
   2. Драйверы устройств
   3. Дополнительные модули (например, драйверы файловых систем и интернет-протоколов)
2. Вторичный загрузчик для дополнительных системных процессов
3. Userland (код, исполняющийся с пользовательскими привилегиями)
4. Инсталлятор и система управления пакетами

## Как работать, что читать, *КАК ВЫЖИТЬ*???
Одна из лучший книг - **Хевилэнд, Грей, Салам. "Системное программирование в UNIX"**

**Читайте доки!!!** Есть они в трёх видах:
- команда `man <имя>` - выводить справку прямо в терминал
- Документация от oracle

### Номера секций для `man`
- `1` - команда shell
- `1M` - команда shell, доступная администратору
- `2` - системные вызовы
- `3C` - стандартная библиотека C

# 23.09.11 - лекция
## Среда исполнения
Процессу можно дать несколько определений:
- Функциональное определение - песочница для запуска программ с ограниченными привилегиями

Каждый процесс имеет своё виртуальное адресное пространство.

Unix-системы используют защиту памяти, что почти похоже на виртуальную память.

Защита памяти реализована следующим образом:

![](./materials/23-09-11_mem-def.png)

Единственный способ попасть вовне среды исполнения - использование системных вызовов - типы прерывания, которые передают управление фрагменту кода с системными правами доступа.

**Не любая среда может пользоваться системными вызовами**

`malloc` может содержать в себе системный вызов, если на куче кончится память и понадобится её увеличить.

Код стандартной библиотеки исполняется из образа в памяти процесса. Также в памяти процесса лежат и другие используемые процессом библиотеки

**Библиотека** - кусок кода, привязываемый к программе статически (при компиляции, привязка называется **линкова**) или динамически (при исполнении. `dlopen`).

Функция в языке в Си, в отличие от простого куска кода, следует соглашению о вызове функций Си.

**`ABI`** - application binary interface - соглашение о вызовах.

### Ядро
Ядро - **все компоненты, работающие в системном режиме (определение Иртегова).** Код в привилегированной области памяти, исполняемый с повышенными привилегиями.

Выполняется командой `syscall`/`sysenter` (что и является системным вызовах), но в Unix имеют особые обёртки, которые выглядят как обычные функции.

Ядро управляет виртуальной памятью, внешними устройствами и всеми процессами.

Таким образом полная схема защиты памяти будет выглядеть так:

![](./materials/23-09-11_mem-def-2.png)

Благодаря этому мы можем добавлять различные атрибуты процессам и не сильно беспокоиться о безопасности.

### Наконец, определение процесса
Процесс - объект операционной системы, т.е. структура данных в ядре, с которой связаны некоторые атрибуты, часть из них видна процессу, часть могут быть изменены только ядром, а часть неизменны на протяжение всего времени жизни процесса.

Процесс - исполняющаяся программа вместе с необходимым окружением (сегменты данных и стэка, user area и др.)

Образ процесса - виртуальное адресное пространство процесса во время исполнения.

Когда мы запускаем программу, на самом деле мы сначала создаём процесс, а уже в рамках него запускаем программу.

Каждый процесс имеет свой уникальный (в один момент времени) `pid`.

Основные структуры процесса (отображённые на память файлы):
- `TEXT` - код программы
- `DATA` - инициализированные статические данные
- `BSS` - неинициализированные статические данные - район памяти, забитый нулями, его нет в бинарнике, там только указан его размер. Смысл этого раздела в наше время почти полностью утрачен.
- `STACK` - хранит нестатические локальные переменные
- `HEAP` - здесь обитаем `malloc`
- Динамические сегменты - из них состоят динамические библиотеки
- User Area (дескриптор процесса в ядре) - фактически, отображение процесса в ядро. Был в старых Unix-системах, сейчас в основном отсутствует из-за многопоточности.
  - Стэк процесса в ядре
  - Дескрипторы открытых файлов
  - Атрибуты процесса

Виртуальная память процесса в архитектуре `Intel x86`:
![](./materials/23-09-11_process-x86.png)

Виртуальная память процессах на `Intel x64`:
![](./materials/23-09-11_process-x64.png)

*Разрыв в середине пространства вызван тем, что на текущий момент для адресации используется только `48` бит из 64-х*

Все процессы кроме `init` имеют родителя. `init` имеет `pid = 1`, запускается при старте системы ядром и запускает все остальные процессы.

### Терминальная сессия
Физически терминалы обслуживаются демоном `ttymon` (раньше был `getty`)

Виртуальные терминалы (сессии) создаются динамически различными сервисами. Например, для сессий терминала `ssh` создателем будет демон `sshd` 

При входе пользователя создаёт сессия с ID, который равен ID процесса-создателя, проводится авторизация, устанавливается ID пользователя и запускается шелл, шелл берётся из учётной записи пользователя (обычно хранится в `/etc/passwd`)

Шеллы с управлением заданиями создают на каждую команду группу процессов.

### Атрибуты процесса
Атрибуты процесса хранятся в пользовательской области в ядре и в пользовательском стэке.

В ядре:
- Процесс
  - ID
  - родитель
  - группа
  - терминал (его может не быть)
  - сессия
  - ограничения (открытые файлы, время процессора, то есть `rlimit`ы)
- Пользователь
  - Идентификатор (реальный/эффективный)
  - Группа (реальный/эффективны)
- Файловая система
  - Открытые файлы
  - Текущая директория
  - Корневая директория (`setroot`)
  - Ограничения (`umask`, `ulimit`)
- Обработка сигналов

В пользовательском стэке хранятся параметры командной строки и переменные среды.

Переменные среды процесса хранятся в памяти процесса 

## Эффективные идентификаторы
Эффективные идентификаторы позволяют пользователю или группе быть представителями других пользователей и групп.

# 23.09.18 - лекция
## Атрибуты процесса (продолжение)
Часть атрибутов процесса находится в ядре. Их можно изменять системными вызовами.

Можно поменять группу процесса, но нельзя поменять ID процесса.

Если процесс потерял родителя (тот завершился раньше самого процесса), то родителем станет процесс `init`

Терминал меняется вместе с сессией.

Ограничения можно только понизить.

### Пользователь
Пользователь - это число.

**НЕ ПУТАТЬ ГРУППЫ ПОЛЬЗОВАТЕЛЕЙ И ГРУППЫ ПРОЦЕССОВ!** По умолчанию процесс принадлежит к тем же группам, что и пользователь.

### Пользовательский стэк
В Си-функцию `main` передаются 3 аргумента: `int argc`, `char** argv`, `char** envp`.

`argc` - вспомогательный и содержит количество аргументов командной строки

`argv` - массив строк, представляющих собой аргументы, передаваемые в команду при её вызове

`envp` - `environment` - переменные среды = аргумент процесса. Хранит массив строк формата `name=value`. Заканчивается `NULL`

## Доступ к системным переменным (атрибутам системы)
Относится к библиотеке `unistd.h`

`sysconf` - смотрит значение системных переменных
- `LINE_MAX` - максимальная длина строки ввода

`pathconf` - посмотреть параметры файловой системы (например, длину имени файла,)

**ЛУЧШЕ ИСПОЛЬЗОВАТЬ ИМЕННО ЭТИХ ФУНКЦИИ ВМЕСТО ЛИМИТОВ ИЗ `limits.h`**

## Пользовательский стэк (стэк процесса)
Кроме переменных среды и позиционных аргументов в пользовательском стэке хранится также стэковый кадр и ограничен защитной областью, которая препятствует бесконечному разрастанию стэка.

**Стэковый кадр** - область памяти в пользовательском стэке, куда сохраняются параметры функции (хотя и не всегда и не все), адрес возврата, сохранённые регистры, локальные переменные, а также дополнительно в C указатели на обработчики исключений и деструкторы локальных переменных.

## Доступ к переменным среды
Можно получить третьим аргументов (говорилось выше), через внешнюю переменную `extern char** environ` (в начальный момент времени совпадает с переменными среды родителя), либо через функции `getenv`, `putenv`.

### Конкретные переменные среды
`PATH` - переменная среды, хранящая каталоги через `,`. В этих каталогах будут искаться исполняемые файлы (*фан-факт - в Винде пути разделяются `:`*).

`TERM` - тип терминала, используется экранными редакторами и другими программами

`HOME` - домашний каталог

`USER` - имя пользователя (**НЕ ПУТАТЬ С `UID`!**)

`SHELL`

`LOGIN`

### `TZ`
**Ядро живёт по Гринвичу**

Если переменная среды `TZ` не установлена, то часовой пояс берётся из файла `/etc/localtime`.

Существует несколько форматов часового пояса:
- `Asia/Novisibirsk` - указывает на файл в `/usr/share/zoneinfo` - бинарнике, в котором хранится вся информация о часовом поясе. 
- В Solaris:
  - `/etc/TIMEZONE` - имя часового пояса
  - `/etc/LOCALTIME` - смещение часового пояса
- Стандартные названия имён (например, `PST8PDT`)
- `<Любые 3 буквы>-<сдвиг>`

Если мы хотим не менять переменную среды, у родителя, а только у нового процесса, то можно написать значение переменной среды, а после в той же строке вызвать команду.

### Изменение переменных среды
Для изменения переменных среды можно просто обратиться к неё через `$`, также для работы с переменной рекомендуется её экспортировать

Если при изменении переменных среды в C-программе через `putenv`, `setenv` нам начинает не хватать места на стэке, будет автоматически вызван `malloc`, а переменная переменные среды переместятся на стэк. Именно поэтому рекомендуется использовать эти функции, а не `char** envp`.

Если вдруг мы хотим поменять переменную среды для нашего терминала, можно использовать функцию `source`, если мы хотим поменять переменную среды для каждой нашей терминальной сессии, то мы можем отредактировать `.bashrc`

## `setuid`
Доступ к ресурсам основывается на эффективных ID пользователя и группы (по ним проверяются права доступа)

Реальный ID ставится при входе пользователя в систему. В этот момент чаще всего эффективный ID приравнивается реальному.

При запуске программы с битом `setuid` её эффективный идентификатор приравнивается к реальному идентификатору хозяина файла.

Пароли в Linux хранятся в `/etc/shadow`. При этом возникает вопрос, как защитить этот файл от произвольного доступа, но дать доступ пользователю через утилиту `passwd`. **Ответ:** `passwd` запускается с битом `setuid`. *Фан-факт:* если рут запустит `passwd`, то он сможет поменять любой пароль.

У `sudo` под капотом тоже содержится `setuid` бит.

**НЕ ПУТАТЬ `setuid`-бит с системным вызовом `setuid` - он позволяет менять эффективный ID процесса, устанавливая его идентичным реальному ID**

Также есть системный вызов `setgid` - работает аналогично `setuid`, но для группы

## Системные вызовы ввода/вывода
### Что такое файл?
**Файл** - последовательность байтов с адресацией с точностью до байта

**Файл** - именованная совокупность данных (*из книги Иртегова*)(*на самом деле это в первую очередь справедливо для регулярных файлов*)

Метка конца файла не входит в данные файла.

Файл - это универсальный интерфейс с внешними устройствами. Таким образом, даже устройства для ввода-вывода звука будут иметь своё представление в виде файла.

**Определение из словаря POSIX:** файл - объект, который можно читать и писать.

**Всё есть файл (*ну... кроме процессов, хотя... см. дальше*)**

**Папка `proc`** содержит информацию о процессах, в частности, там можно увидеть всё адресное пространство процесса.

# 23.09.25 - Лекция
## Файловая система и где хранятся файлы
Доступ к постоянной памяти производится по секторам. Обычно они составляют 512 байт.

**Файловая система** - структура данных на внешнем носителе. На самом деле этим определением могут называться 3 разных, пусть и связанных сущности:
- **Формат данных**, описывающие размещение данных
- **Программа - модуль ядра**, позволяющий работать с файловой системой
- **Экземпляр файловой системы** на конкретном носителе

Файловая система сравнима с архивом. Ключевое различие в возможности изменения размера файлов.

### Основные папки в корне Линукс
- `/bin` - бинарные файлы
- `/boot` - файлы при загрузке
- `/dev` - файлы устройств и псевдоустройств (в т.ч. диски)
- `/etc` - общесистемные конфиги
  - `/opt` - 
- `/home` - каталоги пользователей
- `/lib` - основные библиотеки, необходимые для работы программ из `/bin`, `/sbin` (**либы - неисполняемые системные файлы**)
- `/media` - временные носители (флэшки, диски и т.п.)
- `/mnt` - временно монтируемые файловые системы
- `/opt` - дополнительное ПО
- `/proc` - виртуальная файловая система, представляющая состояние ядра ОС и запущенных процессов в виде файлов
- `/root` - домашний каталог рута
- `/run` - информация о системе с момента запуска, pidы, сокеты и т.п.
- `/sbin` - бинарники для администрирования
- `/srv` - данные для предоставляемой системой сервисов
- `/sys` - информация о драйверах, устройствах и некоторых свойствах ядра
- `/tmp` - временные файлы
- `/usr`
- `/var` - хранит изменяемые файлы (файлы регистрации, временные почтовые файлы)

## Продолжаем про определение и основные свойства файла
Формат файлов системе по большей части безразличен, исключение - бинарные исполняемые файлы

С точки зрения приложений существует 2 типа файлов: текстовые и бинарные.

Файлы хранятся в ядре и реализуют интерфейс чтения/записи.

**Файл-каталог** - файл, содержащий информацию о своих файлах и каталогах потомках

На самом деле в один и тот же каталог можно прийти от нескольких родителей

## Системный вызов `open(2)`, дескрипторы файлов, `file_t` и `vnode`
`open(char* pathname, int flags, [mode_t mode])` - `2` - Открывает файл по указанному пути и с указанными флагами, в случае успеха возвращает индекс, указывающий на элемент массива в user area - указатель на дескриптор файла.

`char* pathname` - путевое имя, содержащее имена каталогов через прямой слэш. Могут быть относительными и абсолютными. Абсолютный путь начинается с `/`, относительный путь - с другого символа, относительные пути строятся от текущей директории - переменной среды `PWD`, которая есть у каждого процесса

**Дескриптор** - число, относящееся к описанию файла, хранящемуся в ядре (в user area). Описание содержит отступ и флаги:
- `O_RDONLY`
- `O_WRONLY`
- `O_RDWR`
- `O_APPEND` - как `O_WRONLY`, но указатель помещается в конец файла
- `O_CREAT` - создаёт файл, если он не существует (**может создать только регулярный файл**). При этом флаге необходимо указывать права доступа (`mode_t mode`)
- `O_TRUNC` - стирает содержимое файла
- `O_EXCL` - используется вместе с `O_CREAT` и вернёт ошибку, если файл уже существует
- `O_SYNC` - заставляет `write(2)` ожидать окончания физической записи на диск (по-умолчанию данные записываются сначала в оперативную память)
- `O_NDELAY`, `O_NONBLOACK` - открытие специального байт-ориентированного файла или именованного программного канала часто вызывает блокировку. Любой из этих флагов предотвратит блокировку `open(2)`

*За каждый флаг отвечают определённые биты в аргументе `int flags`, поэтому для их комбинации надо использовать побитовое ИЛИ (`|`)*

Опциональный параметр `mode_t mode` указывает права доступа к создаваемому файлу.

**В случае неудачи** `open(2)` вернёт `-1`

### Как работает `open(2)`
1. Файл ищется в иерархии директорий для получения `inode` (**файловая запись**, она у файла одна)
2. Проверяются права доступа
3. В таблице дескрипторов размещается новый дескриптор
4. Проверяется системная структура файлов и, если необходимо, размещается новое поле
5. Если необходимо, размещается новая структура информации о файле `file_t`
6. Соединяется с подходящим драйвером устройства:
   - Создать структуру `vnode` (в Линукс - `inode`)
   - Записать в поля этой структуры указатели на функции драйвера
7. Возвращается дескриптор

Структура информации о файле (`file_t`) хранится в ядре и создаётся каждый раз при вызове `open(2)`, тогда как `vnode` будет один на все структуры `file_t` одного файла

Структура `file_t`:
```c
typedef struct file {
  kmutex_t f_tlock; /* short term lock */
  ushort_t f_flag;
  ushort_t f_flag2; /* extra flags (FSEARCH, FEXEC) */
  struct vnode *f_vnode; /* pointer to vnode structure */
  offset_t f_offset; /* read/write character pointer */
  struct cred *f_cred; /* credentials of user who opened it */
  struct f_audit_data *f_audit_data; /* file audit data */
  int f_count; /* reference count */
  struct filock *f_filock; /* ptr to single lock_descriptor_t */
} file_t;
```

[Структура `vnode`](https://github.com/illumos/illumos-gate/blob/master/usr/src/uts/common/sys/vnode.h):
```c
typedef struct vnode {
	kmutex_t	v_lock;		/* protects vnode fields */
	uint_t		v_flag;		/* vnode flags (see below) */
	uint_t		v_count;	/* reference count */
	void		*v_data;	/* private data for fs */
	struct vfs	*v_vfsp;	/* ptr to containing VFS */
	struct stdata	*v_stream;	/* associated stream */
	enum vtype	v_type;		/* vnode type */
	dev_t		v_rdev;		/* device (VCHR, VBLK) */

	/* PRIVATE FIELDS BELOW - DO NOT USE */

	struct vfs	*v_vfsmountedhere; /* ptr to vfs mounted here */
	struct vnodeops	*v_op;		/* vnode operations */
	struct page	*v_pages;	/* vnode pages list */
	struct filock	*v_filocks;	/* ptr to filock list */
	struct shrlocklist *v_shrlocks;	/* ptr to shrlock list */
	krwlock_t	v_nbllock;	/* sync for NBMAND locks */
	kcondvar_t	v_cv;		/* synchronize locking */
	void		*v_locality;	/* hook for locality info */
	struct fem_head	*v_femhead;	/* fs monitoring */
	char		*v_path;	/* cached path */
	hrtime_t	v_path_stamp;	/* timestamp for cached path */
	uint_t		v_rdcnt;	/* open for read count  (VREG only) */
	uint_t		v_wrcnt;	/* open for write count (VREG only) */
	u_longlong_t	v_mmap_read;	/* mmap read count */
	u_longlong_t	v_mmap_write;	/* mmap write count */
	void		*v_mpssdata;	/* info for large page mappings */
	void		*v_fopdata;	/* list of file ops event watches */
	kmutex_t	v_vsd_lock;	/* protects v_vsd field */
	struct vsd_node *v_vsd;		/* vnode specific data */
	struct vnode	*v_xattrdir;	/* unnamed extended attr dir (GFS) */
	uint_t		v_count_dnlc;	/* dnlc reference count */
} vnode_t;
```

![](./materials/additional/file_pipeline.png)

**На самом деле дескриптором корректнее называть структуру `file_t`, а не индекс в user_area, его называют "ручкой"** (*А на самом деле херня полная такой нэйминг: число **дескриптор**, `file_t` - **объект открытого файла**, `vnode` - **абстракция для описания файла как объекта ОС***)

Подробнее про файловые системы, `vnode` и прочее читай [ТУТ](#вахалия---unix-изнутри-глава-8---базовые-элементы-и-интерфейс-файловой-системы).

*Фан-факт:* права доступа проверяются только в момент открытия файла

## `close(2)`
`close(int fd)` - освобождает индекс, указывающий на дескриптор `file_t`. Если это последний дескриптор на `file_t`, то эта структура также удаляется. Если удалена последняя структура `file_t`, то будет удалена структура `vnode`, но лишь через некоторое время. Именно удаление (*а чаще даже очистка и назначение другому объекту*) структуры `vnode` **является удалением файла**. Даже если мы удалим файл из каталога, он может продолжить существовать, пока счётчик ссылок на него в `vnode` > 0, пусть доступа из каталога к нему уже не будет.

## `tmpfile`
Механизм подсчёта ссылок также позволяет создавать временные файлы. После создания на них будет всего одна ссылка, которая пропадёт после закрытия, а значит файл не появится в рабочем каталоге и не будет доступен никому более.

## `read(2)`
`ssize_t read(int fd, void* buf, size_t count)` - пытается прочитать из дескриптора файла до `count` байтов и записать их в буфер по адресу `void* buf`. Возвращает количество считанных байтов либо `-1` при ошибке (**запись нуля байт не является ошибкой**)

## `write(2)`
`ssize_t write(int fd, void* buf, size_t count)` - записывает в файл по дескриптору `fd` `count` байт из буфера по адресу `void* buf`. Возвращает количество записанных байт либо `-1` при ошибке

## Стандартные потоки и их связь с дескрипторами
- `0` - `stdin`
- `1` - `stdout`
- `2` - `stderr`

# 23.10.02 - лекция
## `fsync(2)`
Любая программа может писать данные гораздо быстрее, чем это происходит на внешних накопителях, поэтому зачастую данные пишутся в системный буфер, а далее, параллельно дальнейшим операциям производится запись в память

```c
#include <unistd.h>

int fsync(int fd);
```

Ожидает записи данных из буфера в постоянную память. Удобнее, чем использовать флаг `O_SYNC` в `open(2)`, так как мы можем отдельно решать, в какие моменты нам важно, что данные были записаны, а в какие мы оставляем запись из буфера в постоянную память на усмотрение системы.

Возвращает `0` в случае успеха и `-1` с записью кода ошибки в `errno` при неудаче

## `lseek(2)`
```c
#include <sys/types.h>
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
```
Сдвигает указатель в файле по заданному дескриптору. В случае успеха возвращает расстояние в байтах от начала файла и `-1` с записью кода ошибки в `errno` при неудаче.

`whence` определяет, откуда будет происходить сдвиг курсора:
- `SEEK_CUR` - от текущей позиции курсора
- `SEEK_SET` - от начала файла
- `SEKK_END` - от конца файла

При сдвиге назад от начала будет оставаться нулевая позиция.

При сдвиге дальше конца мы можем читать данные и будем получать `\0`. Если же мы попытаемся записать данные туда, то получим разреженный файл - между блоками с данными будет пространство с нулями, под которое не выделяется память на диске.

Интересный пример применения разреженных файлов есть в некоторы торрент трекеров, которые сразу создают файл нужной длину и потом, скачивая отдельные куски, складывают их сразу в нужные места (*другие наращивают файл постепенно*)

Обычно разреженные файлы НЕ ТЕКСТОВЫЕ

## `dup(2)`
```c
#include <unistd.h>

int dup(int fd);
```
Возвращает новый дескриптор, относящийся к тому же `file_t`. Ищет свободную ручку с нуля. `dup2()` ищет с указанного индекса

## `fcntl(2)`
```c
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>

int fcntl(int fd, int cmd, /* arg */);
```
Представляет собой сборник из команд, которым не захотели выделять отдельные системные вызовы. Возвращаемое значение в случае успеха зависит от `cmd`, как и следующие за `cmd` аргументы

Флаги без `args`:
- `F_GETFD` - получить состояние флага закрытия-по-`exec`
- `F_GETFL` - Получить флаги `NDELAY`, `NONBLOCK`, `SYNCH`, `APPEND`

Флаги с `int arg`:
- `F_DUPFD`
- `F_SETFD`
- `F_SETFL`

### `struct flock`
```c
typedef struct flock
{
  short l_type;
  short l_whence;
  /* SEEK_SET, SEEK_CUR, SEEK_END */
  off_t l_start;
  off_t l_len;
  /* len == 0 means until end of file */
  long l_sysid;
  pid_t l_pid;
  long pad[4]; /* reserve area */
} flock_t; 
```
Флаги с для `fcntl` с `struct flock *arg`:
- `F_FREESP` - освободить физический носитель.
  - Если идём от конца файла, то укоротит место для файла
  - Если указать пространство внутри файла, то мы создадим в нём дырку
- *добавить*

## *Хуяк!* И тут у нас управление памятью
**Статическое управление памятью**
- Требуемое количество памяти известно в момент сборки программы
- Достаточно проверить, есть ли требуемая память в момент загрузки
- Размечается процессором
- Достаточно помнить границу между занятой и свободной памятью

**Динамическое управление памятью**
- Память может запрашиваться и освбождаться во время исполнения программы
- Необходимо поддерживать список свободных областей памяти (называется **пул** либо **куча**)
- Стэковые кадры в C/C++ являются простейшим примером динамической памяти (*так как пременные существют лишь до тех пор, пока исполняется функция*)
- Стэковое (**LIFO**) управление памятью при загрузке программ

### Веселуха с динамической памятью и попытки её решить
В связи с выделением непрерывного блока памяти с началом по строго указанному указателю мы получаем проблему **внешней фрагментации** - между выделенными блоками будут пустые пространства произвольного размера, которых по отдельности будет не хватать для выделения нового блока, хотя в сумме памяти хватило бы.

Одно из решений - выделять кусок памяти кратной какому-то конкретному числу длины под любой запрос памяти. Проблема - **внутренняя фрагментация** - даже под небольшой объём данных мы выделим большой блок, из-за чего много пространства будет простаивать.

Зачастую создаётся определённая структура с информацией о свободных блоках.

Стратегии поиска свободных блоков:
- Best fit - требует просмотра всего пула либо сортировки, увеличивает фрагментацию и уменьшает средний размер отбрасываемого "хвоста"
- First fit - находим первый подходящий блок (*используется чаще всего, для реализации часто используется кольцевой список*)
- Worst fit - требует сортировки блоков, заключается в отрезании от самого большого блока нужное количество памяти (*реазлиуется вместе с maxHeap - именно поэтому кучу называют кучей, хотя сам по себе worst fit в чистом виде уже и не используется*)

Про склеивание свободных блоков и алгоритм парных меток можно прочитать [выше](#распределение-памяти-работа-api-mallocfree)

Существует множество и других стратегий `malloc`, которые оптимизированы под конкретные и в разной степени специфичные задачи:
- Для компьютеров, предназначенных для сложных математических расчётов
- Для компьютеров разделённого времени (выполняющих множество задач параллельно, принимающих пользовательские сигналы)
- Для систем реального времени (автопилот машины и т.п.)

**Алгоритм близнецов (best fit)** подходит как раз для систем реального времени, так как выделяет память за фиксированное время. Заключается в создании блоков размером в степени двойки. Деление памяти делается по принципу бинарного дерева. Проходим вниз дерева до тех пор, пока не будет найден минимально подходящий блок. Объединиться свободные блоки могут только если они относятся к одному и тому же родителю.

# 23.10.09 - лекция
## Продолжение про выделение памяти
### Слабовые аллокаторы
Slab - плита, лист, пластина

Испльзуется, если нам нужно много блоков одинакового размера (особенно, если они не кратны степеням двойки)

В ядре создаётся объект кэша, в котором указывается, какого размера блоки мы хотим выделять. Затем берётся большой кусок памяти и режется на фрагменты указанного нами размера.

Кэши связываются списком.

В кэше хранятся указатели на занятые слабы, частично свободные и полностью свободные.

Слабы не лишены проблемы дефрагментации, но её нельзя назвать ни внешней, ни внутренней.

*Дальшей идёт допматериал про попытки решения проблемы этой дефрагментации*

### Сборка мусора
Чтобы не было проблем с каскадной порчей данных и утечек памяти, необходимо эту память корректно освобождать за счёт одной из стратегий сборки мусора.

Существует 2 основных стратегии:
- Подсчёт ссылок (уходящий последним гасит свет)
- Рекурсивный просмотр ссылок (mark and sweep).
  - В момент работыы стратегии необходимо остановить всю деятельность, которая может привести к уничтожению или созданию ссылок и объектов
  - Рекурсивно движемся по все указателям, помечая объекты, как живые
  - Все непомеченные объекты будут удалены. Перед следующим запуском сборщика необходимо снять метки
  - Достаточно прожорлива по производительности и потребляемой памяти.

Стратегия mark and sweep обладает рядом недостаков, для которых предложены различные решения:
- Высокое потрбления памяти
- Блокирование исполнения программ
  - Решается неблокирующим сборщиком

**Копирующий сборщик**. Создаём 2 области в помечченные живыми объектами перемещаем в новый объект. Ведущие из области мусора ссылки *игнорируются (?)*.

#### Генерационная сборка мусора
Улучшенной версией будет **генерационная сборка мусора**. Делается в 2 прохода через большую и малую сборку мусора *по не самым пока что понятным мне правилам*:
![](./materials/23-10-09%20-%20generation%20garbage%20collector.png)

Генерационный сборщик основан на предположении, что старые объекты редко ссылаются на новые, поэтому при малых сборках старые объекты вообще не трогаются, однако так бывает не всегда. **Remembering set** - набор ссылок из старых объектов на новые.

**Garbage First (G1)** - вместо поколений разбивает кучу на области одинакового размера и использует remembering set для отслеживания ссылок между областями и оценивания количества живых объектов в каждой из областей. Выбрав регион с максимальным количеством мусора и без ведущих туда ссылок, проводит неблокирующую сборку

*Остановился на 35-м слайде презентации про память и сказал, что дальше идти смысла нет сейчас*

## Виртуальная память
Linux и Windows используют **аппаратную защиту памяти** или, что похоже, но не совсем то же самое, **виртуальную память**.

**MMU** - Memory management Unit - стоит на пути от процессора к памяти и "что-то делает с адресами запрашиваемых ичеек". В отличие от, например, переключателя банок памяти для CdM-8, MMU не обязательно отобразит отправленный процессором адрес в какой-то адрес в памяти - вместо этого он может выкинуть исключение.

Процесс не знает, где он лежит в реальной памяти, а лишь может обращаться к ячейкам в рамках определённого лимита.

Если процесс запросит доступ к ячейке выше лимита, то MMU выбросит исключение, если ячейка будет меньше лимита, то MMU добавит к запрашиваемому адресу начало его области в реальной памяти (`BASE`). `BASE` и `LIMIT` передаются процессором в регистры MMU

**Запомните!!!** Системный вызов переводит исполнение кода в режим ядра.

В том числе, в режиме ядра можно осуществлять ввод-вывод и менять регистры MMU. А значит, ядро может перемещать реальное расположение процесса в памяти.

### Ещё раз про сравнение пользовательского и системного режима
Система:
- Может делать ввод-вывод
- Может менять регистры MMU
- Иногда может вообще выключить MMU
- Имеет доступ к пользовательской памяти
- Может произвольно переходить в пользовательский режим

Пользователь:
- Первые 3 пункта с отрицанием
- Не имеет доступ к памяти ядра
- Может перейти в системный режим только командной `syscall`

### Чем плоха базовая адресация
Главная проблема базовой адресации (записанного ранее алгоритма работы MMU) - необходимость выдавать процессу непрерывную область памяти. Это приводит к всё той же проблеме фрагментации.

Решением проблемы стало разделение области памяти на отдельные фрагменты => в MMU хранится множество пар `BASE`-`LIMIT`. (*Всопминаем разделение памяти процесса и преисполняемся*). Сегментация определяется архитектурой процессора.

#### КРИТ ПРО СЕЛЕКТОР И ДЕСКРИПТОР
Соответственное, теперь запрос от процессора делится на 2 части: селектор и смещение. Селектор определяет регистр в MMU. Кодируются одни числом, что логично.

Также к описанию каждого сегмента добавились права: чтение, запись или и то, и то.

Чтобы не ограничиваться количеством регистров MMU, выделили в памяти область под таблицы трансляции. В них также хранятся селекторы, права доступа, базовый адрес и размер области. Теперь MMU Достаточно хранить адрес таблицы трансляции - всё это в целом называется дескриптором

<hr>

Наиболеее часто используемый сейчас вариант: страничные таблицы трансляции без указания размера блоков с фиксированной небольшой длиной (на 32-битных системах это около 4 КБ. Такой вариант позволяет разметить 2^20, что примерно миллион областей).

# 23.10.16 - лекция
## Продолжаем про виртуальную память
![](./materials/23-10-16%20-%20TLB.png)

TLB - кэш таблицы трансляции. Если мы обращаемся к близко лежащим слекторам из таблицы трансляции, итоговое получение реального адреса будет работать значительно быстрее быстрее. Проблема в том, что при обращении к далеко лежащим областям либо при вызове нового процесса (Intel), кэщ сбрасывается.

### Дополнительные возможности MMU
- Защита чтения/записи
- Защита от исполнения
- Бит супервизора
- Бит присутствия
- Исключения
  - Ошибка защиты памяти
  - Страничный отказ

#### ЧЕМ ОТЛИЧАЮТСЯ ИСКЛЮЧЕНИЯ ОТ ПРЕРЫВАНИЙ
Аппаратные прерывания обрабатываются между исполнением команд, исключения возникают прямо внутри команды, то есть при получении исключения будет откат до исполнения этой команды

<hr>

### Дескриптор страницы `80386`
![](./materials/23-10-16%20-%20descriptor_80386.png)

- Грязная - сюда когда-то писали
- Использовалась - использовалась в любом режиме после последнего сброса (`accessed`)
- Бит присутствия - если бит нулевой, то при обращении к странице будет сгенерировано исключение страничного отказа

### Многоуровневая трансляция в `x32` у Intel
![](./materials/23-10-16%20-%20x32_translation.png)

Каждая запись каталога - 4 Мб. Если каталог полностью пуст, то он весь целиком маркируется битом отсутствия - и всё.

Если хотя бы часть страниц каталога используется, этот метод ускорения работы не сработает.

С какого-то Пентиума появилась возможность выделения гигантских страниц - таблица катологов ведёт сразу к страницам, а не к каталогам, то есть мы отключаем последний этап трансляции

### Многоуровневая трансляция в `x64` Intel
![]()

### ARM
ARM-архитектура позволяет кроме страниц выделять также и сегменты, то есть указывать им конкретный размер

<hr>

Существуют также диспетчеры памяти без таблицы трансляции. Они используют просто очень большой TLB

### Как проходит переключение процессов
Одна таблица трансляции (x86, x64, VAX):
- Сбрасываем регистр процесса в `MMU` `CR3` и сбрасываем `TLB`
- В адресном пространстве каждого процесса должна быть хотя бы часть кода ядра с битом супервизора

Переключение таблицы трансляции (SPARC, PowerPC):
- Достаточно переключить котекст (номер таблицы)
- Записи TLB должны помнить номер таблицы, зато TLB при этом не надо сбрасывать
- Ядро может находиться в отдельном адресном пространстве

Пример переключения таблиц трансляции (PowerPC 601)

![](./materials/23-10-16%20-%20trastables_switching.png)

### Page swapping - страничная подкачка
За счёт механики исключений со сбрасыванием команды, вызвавшей исключение, мы можем найти страницу памяти, предоставить её процессу и, бросив исключение, уже без проблем выполнить команду, вызвавшую это самое исключение ранее.

На самом деле при запуске исполняемого файла мы не загружаем его целиком в память, а лишь маркируем файл. Части файла загружаются на страницы лишь при необходимости, хотя в своей работе все процессы думают, что исполняемый файл бал записан в память целиком.

Идеально эта схема работает, когда исходные данные не изменялись => мы можем загрузить данные на страницу из того же файла. Если мы изменили загруженные на страницу данные, она становится грязной => её необходимо где-то временно хранить.

#### Поиск жертвы для новых страниц
Система пытается отобрать страницы редко исльзуемых процессов.

Редкость определяется грубым эвристическим алгоритмом, например clock algorithm.
- Страницы объединяются в кольцевую очередь.
- При необходимости берётся берётся страница и проверятеся её бит `accessed` (либо же `clock`-бит)
- Если бита нет, значит мы нашли жертву, если есть, то мы его снимаем и идём к следующей странице

Если страница грязная, она сохранится в своп-файл. Разделяемые модфицированные страницы сохранятся в тот файл, из которого отображены.

## Возвращаемся к практической части
### `mmap`
`mmap(caddr_t addr, size_t len, int prot, int flags, int fd, off_t off)`:
- `addr` - желаемый адрес начала области. Самое страшное, что при наложении на уже отображённую страницу, всё сработает корректно
- `len` - сколько байт файла отобразить на страницу
- `prot` - флаги прав выделенных страниц памяти
  - `PROT_READ`
  - `PROT_WRITE`
  - `PROT_EXEC`
- flags - в отличие от битовых флагов, эти флаги являются взаимоисключающими:
  - `MAP_SHARED` - данные на странице могут быть изменены и попадут в файл, но незивестно, когда. Отображённый на память файл с этим флагом может быть использован как общая память для нескольких процессов.
  - `MAP_PRIVATE` - изменения файла будут оставаться в памяти либо попадать в swap-раздел, но не попадут в файл
  - `MAP_ANON` - не надо указывать дескриптор и сдвиг. Выделяет область памяти, заполненную нулями. На самом деле, под капотом, мы по сути открываем `/dev/null` с флагом `MAP_PRIVATE`
  - `MAP_STACK` - точно не специфицирован, но в целом заключается в том, что система сможет понять, что выделенная область будет расти вниз

После исполнения `mmap` в ядре будет создан **сегмент**, хранящий адрес в виртуальной памяти и связанный с ним источник подкачки. При попытке прочитать файл, ядро найдёт подходящий сегмент и закачает его в память. (*уточнить про разницу понятия как страктуры ядра и как части в виртуальной памяти*)

На самом деле все сегменты в памяти процесса выделяются `mmap`.

Посмотреть сегменты процесса можно командой `pmap <pid>`

### `munmap`
`munmap(caddr_t addr, size_t len)` - убирает отображение, причём делает это влоб: может убрать лишь конец отображение, может лишь начало, может конец одного и начало другого, может кусочек изнутри сегмента.

После отображения файла на память рекомендуется также убрать это отображение, иначе файл не сможет считаться по-настоящему закрытым.

### `msync`
`msync(caddr_t addr, int, int fd, int flags)` - синхронизирует данные между файлом и сегментом
Флаги (также несовместные):
- `MS_ASYNC` - немедленно вернуться, как только были слпанированы операции (попросить систему работать побыстрее)
- `MS_SYNC` - вернутся только когда завершатся все операции записи
- `MS_INVALIDATE` - помечает страницы памяти как недействительные. После этого любое обращение к их адресам вызвает чтение с диска.

# 23.10.23 - лекция
## Параллелизм
С параллелизмом мы сталкиваемся в первую очередь в сетевом взаимодействии, в распределённых системах (СКВ, базы данных, бизнес-приложения), многомашинные кластеры, многоядерные процессоры, ориентированные на ввод-вывод приложения (которые будут часто "ждать")

Последовательную программу можно представить конечным автоматом.

Параллельную программу так представить нельзя, равно как и комбинацию нескольких конечных автоматов с разной тактовой частотой.

### Практические проблемы параллельного программирования
**Race conditions (ошибки соревнования, "гонки")**:
- Разные наложения параллельно работающих сопрограмм будут давать разный результат
- Если некоторые из результатов получились ошибочными, то мы и получили ошибку соревнования (важно, что именно некоторые результаты, потому что при ошибке при всех вариантов наложения жто будет уже не race condition)
- Очень болезненно отлавливать такую ошибку тестированием

*Пример - покупка одного и того же билета несколькими пользователями*

Источником такой ошибки зачастую являются совместные данные, используемые в параллельно работающих участках кода.

**Целостность** или **согласованность** данных - неформализуемое понятие, которое включает в себя требования предметной области (сходится дебит и кредит, общая сила действия равняется сумме приложенных сил) и требования алгоритмов обработки:
- Записи должны иметь уникальный ID
- Строки должны заканчиваться нулями
- Массив должен быть отсортирован
- Дерево должно быть сбалансировано

**Нить** - то, что выполняется параллельно, но для чего создаётся иллюзия последовательного управления.

#### КРИТ ПО КРИТИЧЕСКОЙ СЕКЦИИ
**Критическая секция** - кусок кода либо время выполнения куска кода, который нарушает целостность разделяемых данных либо полагается на их целостность (при том, что эта структура может быть измнена где-то ещё).

Критические секции - шаг к решению race condition - так как расположение критических секций, мы выделяем и безопасные

Если вы не думаете о критических секциях, ваша программа вся будет одной критической секцией (хотя бы часть данных всё время не целостна)

##### Подходы к решению проблемы критических секций
- Выделение критических секций и блокировки
  - Используется в Java и самый популярный
- Отказ от изменяемых разделяемых данных
  - Использование иммутабельных данных (Функциональные языки (Haskell!!!), Java Streams, Python tuples)
  - Гармонической взаимодействие (трубы, сокеты)
- Copy-modify-merge - делает копию разделяемых структур по методу copy-on-write, а потом пытался провести слияние
  - Заставить человека решить конфликт вручную (системы контроля версий)
  - Транзакции - откат при конфликте (БД)
- Lockless-программирование - писать программы так, чтобы либо не полагаться на целостность разделяемых данных, либо не нарушать её. Очень странный метод, сложный для понимания и поддержания

<hr>

Внедрение многопоточности делает разработку дороже в 3-5 раз, но при этом навык этот крайне востребован

### Решение проблемы критических секций через блокировки
*В лекции строчку с установкой флага и циклом надо поменять местами*

**Алгоритм Деккера** - использовать несколько флагов. Одна нить должна устанавливать флаг работы своей, а проверять флаг работы другой. Нормально работает для синохронизации двух нитей, если их будет больше, то использование алгоритма становится очень трудоёмким. Дполнительное требование - записывать флаги строго в память, чтобы нити могли их читать.

**Lock prefix (x86)** - позволяет команде, идущей после него, монопольно работать с памятью. Лежит в основе метода **CAS (Compare and Set)**, позволяющего релизовать синхронизацию.

**ARM: ldrex, stres**

**CAS (Compare and Set)** позволяют реализовывать спинлоки `while(CAS(flag, 1)) {}` используется в ядрах ОС и позволяет реализовать более сложные атомарные операции. `CAS(flag, value)` вернёт значение в `flag`, устноавив при этом в ячейку памяти, значение `value`. При заходе в критическую секцию будут устноавлена единичка. Для выхода из секции будет достаточно поставить 0. Спинлок не очень хорош на практике, так как попавшие в него ядра будут работать в холостую.

**Примтив** - переменная непрозрачного типа, над которой определён некоторый набор опреаций.

*Добавить про примитивы*

Простейшие примитивы позволяют создать более сложные примитивы синхронизации.

*Добавить про сложные примитивы*

#### Проблемы методов блокировки
- Deadlocks - у нас 2 критических секции, которые мы используем одновременно, но при этом в одном месте вторая секция блокируется внутри блокировки первой, а другом месте - первая секция блокируется внутри блокировки второй. Получаем мёртвую блокировку и тоже своего рода race condition. 
  - Зачастую принято писть документы с описанием необходимости порядка блокировок.
  - Можно возвращать оишбку при возникновении цикла, но сделать это на многих из примитивов сложно. Вдобавок, мы не особо можем выйти из дэдлока, так как совместные данные были изменены
  - Транзацкионный захват - старый метод, нарушает инкапсуляцию и требует знать обо всех блокировка
- Голодание - при использовании упорядоченного захвата или группового мы получаем ситуацию с простаиванием. Из-за этой ситуации мыы
  - *дописать*
- Ошибочное определение границ критической секции. Если мы закроем критическую секцию раньше её реального конца, получим ошибку соревнования

### Блоикровка через гармоническое взаимодействие
Вместо примитивов синхронизации тут используются примтивы синхронизованной передачи данных (очередь FIFO с сигнализацией на появление в ней данных и ограничением объёма).

Разделяемых данных при этом подходе нет.

Критические секции полностью спрятаны в функциях примитива.

Таким образом, мы получаем многие преимущества параллелизм, не сталкиваясь с его главными проблемами.

**Труба** - кольцевой буфер с определённым для него операциями `read(2)`/`write(2)`. `read()` блокируется, если труба пуста, `write()` заблокируется при полном заполнении трубы.

#### Проблемы гармонического взаимодействия
- Работа с копиями данных
  - Требуется доплонительная память
  - Время на копирование
  - Данные могут быть не актуальны
- Нет произвольного доступа к данным
- Нет разделяемых данных, а они могут нам понадобиться

Развитием идеи гармонического взаимодействия стала мысль о передаче не просто данные, а зпросы, команды или целые программы.

## Параллелизм на практике
**Нить** - то, для чего создаётся иллюзия последовательного выполнения

**Нить** - минимальная единица планирование (*Иртегов назвал дурацким, так как надо определить планирование*)

В первую очередь оптимально реализовывать параллелизм в случаях, когда в программе есть ввод-вывод. Например, ппроцессор получает запрос от сервера, обрабатывает его и запрашивает данные с диска, форматирует полученные данные и отправляет обратно по сетевому интерфейсу. В моменты, пока процессор ждёт запроса или ответа от диска, он мог бы заниматься чем-то более полезным.

![](./materials/23-10-23%20-%20input_output.png)

*Когда речь идёт об одноядерной ситуации, нити и процессу могут перемешиваться по понятиям, но в целом нить далеко не всегда относится к процессу, а у процесса может быть несколлько нитей.*

Операции чтения и записи блокирующие, поэтому во время блокировки процессор может заниматься чем-то другим. При это когда блокировка снимется, программа продолжит исполняться дальше, будто бы этой блокировки и не было (*вот она и иллюзия последовательности*).

При блокировке процесса, как и при прерывании, необходимо сохранить контекст процесса

## КРИТ ПРО КОНТЕКСТ ПРОЦЕССА
**Контекст процесса (лтбо нити, в данном случае безразлично)** - такой набор регистров ЦП, что при его сохранении и восстановлении процесс не заметит прерывания