- [Инфо](#инфо)
- [Доп. инфо](#доп-инфо)
  - [Некоторые функции и системные вызовы](#некоторые-функции-и-системные-вызовы)
  - [Распределение памяти, работа API malloc/free](#распределение-памяти-работа-api-mallocfree)
- [23.09.04 - лекция (Введение. Системы семейства Unix)](#230904---лекция-введение-системы-семейства-unix)
  - [Как работать, что читать, *КАК ВЫЖИТЬ*???](#как-работать-что-читать-как-выжить)
    - [Номера секций для `man`](#номера-секций-для-man)
- [23.09.11 - лекция](#230911---лекция)
  - [Среда исполнения](#среда-исполнения)
    - [Ядро](#ядро)
    - [Наконец, определение процесса](#наконец-определение-процесса)
    - [Терминальная сессия](#терминальная-сессия)
    - [Атрибуты процесса](#атрибуты-процесса)
  - [Эффективные идентификаторы](#эффективные-идентификаторы)
- [23.09.18 - лекция](#230918---лекция)
  - [Атрибуты процесса (продолжение)](#атрибуты-процесса-продолжение)
    - [Пользователь](#пользователь)
    - [Пользовательский стэк](#пользовательский-стэк)
  - [Доступ к системным переменным (атрибутам системы)](#доступ-к-системным-переменным-атрибутам-системы)
  - [Пользовательский стэк (стэк процесса)](#пользовательский-стэк-стэк-процесса)
  - [Доступ к переменным среды](#доступ-к-переменным-среды)
    - [Конкретные переменные среды](#конкретные-переменные-среды)
    - [`TZ`](#tz)
    - [Изменение переменных среды](#изменение-переменных-среды)
  - [`setuid`](#setuid)
  - [Системные вызовы ввода/вывода](#системные-вызовы-вводавывода)
    - [Что такое файл?](#что-такое-файл)
- [23.09.25 - Лекция](#230925---лекция)
  - [Файловая система и где хранятся файлы](#файловая-система-и-где-хранятся-файлы)
    - [Основные папки в корне Линукс](#основные-папки-в-корне-линукс)
  - [Продолжаем про определение и основные свойства файла](#продолжаем-про-определение-и-основные-свойства-файла)
  - [Системный вызов `open(2)`, дескрипторы файлов, `file_t` и `vnode`](#системный-вызов-open2-дескрипторы-файлов-file_t-и-vnode)
    - [Как работает `open(2)`](#как-работает-open2)
  - [`close(2)`](#close2)
  - [`read(2)`](#read2)
  - [`write(2)`](#write2)
  - [Стандартные потоки и их связь с дескрипторами](#стандартные-потоки-и-их-связь-с-дескрипторами)
- [23.10.02 - лекция](#231002---лекция)
  - [`fsync(2)`](#fsync2)
  - [`lseek(2)`](#lseek2)
  - [`dup(2)`](#dup2)
  - [`fcntl(2)`](#fcntl2)
    - [`struct flock`](#struct-flock)
  - [*Хуяк!* И тут у нас управление памятью](#хуяк-и-тут-у-нас-управление-памятью)
    - [Веселуха с динамической памятью и попытки её решить](#веселуха-с-динамической-памятью-и-попытки-её-решить)
- [23.10.09 - лекция](#231009---лекция)
  - [Продолжение про выделение памяти](#продолжение-про-выделение-памяти)
    - [Слабовые аллокаторы](#слабовые-аллокаторы)
    - [Сборка мусора](#сборка-мусора)
      - [Генерационная сборка мусора](#генерационная-сборка-мусора)
  - [Виртуальная память](#виртуальная-память)
    - [Ещё раз про сравнение пользовательского и системного режима](#ещё-раз-про-сравнение-пользовательского-и-системного-режима)
    - [Чем плоха базовая адресация](#чем-плоха-базовая-адресация)
      - [КРИТ ПРО СЕЛЕКТОР](#крит-про-селектор)

# Инфо
Лектор - Иртегов Дмитрий Валентинович

Семинарист - Куталев Андрей Витальевич ([bitgrandmaster@yandex.ru](mailto:bitgrandmaster@yandex.ru))

[Более-менее актуальные лекции](http://parallels.nsu.ru/~fat/unixsvr4-new/trunk/)

[Как сдавать задачи](https://classroom.google.com/u/3/c/NTg5NDgxNTc4ODA4/m/NjIwNjE0NDU3ODY4/details)
- [Задачи](https://docs.google.com/document/d/1242C_65gJ_8HscvJ4RolW09KGS-jieYWwomrRTK_bn0/edit#heading=h.v7414bii3pa)



# Доп. инфо
Вакхалия - "Unix изнутри"

## Некоторые функции и системные вызовы
После функции будет стоять `2`, если это системный вызов, и `3C`, если это C-библиотека
- `perror()` - `3C` - будет часто использоваться, и очень удобна для вывода ошибок в `stderr`
- `time()` - `2` - возвращает время в секундах с начала **ЭПОХИ (1 января 1970, 00:00:00 UTC)**

## Распределение памяти, работа API malloc/free
[Статья с базовыми принципами](https://habr.com/ru/companies/ruvds/articles/740466/):
- `malloc` выделяет указанное количество байт в виртуальной памяти и возвращает указатель на начало выделенной области либо `NULL`, если память не была выделена
- Чтобы `free` мог очищать отдельные блоки памяти, он должен знать их стртовый адрес и размер блока
- Если освобождаются несколько лежащих рядом блоков, они объединяются в одной общее свободное пространство. Этот метод называется `coalescing`
- Возникает проблема фрагментации памяти: если мы выделяем маленькие куски памяти, а потом избавляемся лишь от части из них, мы получим область памяти, в которой возможно много свободных ячеек, но идут они не последовательно, а значит не могут быть использованы
  - **Решение: избыточное выделение памяти** - выделять память блоками, допустим, по 4 байта. Тогда при очистке у нас будет куда больше свободной памяти. **Проблема:** если мы много раз выделяем малые объёмы памяти, то с точки зрения программы занятой будут считаться многие ячейки, которые на самом деле свободны
    - **Решение:** использовать разные участки памяти для выделения памяти разного размера. Например, выделить 25% для малых участков (меньше 4 байт), а остальную - для больших
- `boundary tag allocator` - для каждого участка памяти используются дополнительные ячейке:
  - `address` - здесь записан размер блока памяти (`size`)
  - `status` - флаг, указывающий, занят этот блок или нет
  - `address + 2 + size` - конец блока памяти, также хранит `size`. Это необходимо для реализации `coalescing`

# 23.09.04 - лекция (Введение. Системы семейства Unix)
Unix не доминирующий, но пережил уже 2,5 поколения.

Различные системы семейства Unix:
- Android
- Linux
- WinDriver / Intel VxWorks - система реального времени для интернета вещей
- IBM AIX
- HP UX
- MacOS, IOS
- Sun microsystems / Oracle Solaris

Unix-системы различаются: 
- по лицензированию (free & open source / commerce)
- методам применения (серверы, рабочие станции, мобильные устройства и устройства умного дома)
- Аппаратная архитектура (x86/x64, ARM, MIPS, PowerPC, PA/RISC)
- Архитектура ядра (монолитное ядро, потоки, микроядро Unix SVR4, Multiple personality microkernel)

К общим особенностям семейства Unix относят:
- API - общий стандарт интерфейса ядра и системных библиотек, код совместим с точностью до перекомпиляции
- Стандартный командный язык
  - Командные процессоры sh (bash, ksh) и утилиты
  - Часть стандарта POSIX
  - Может быть недоступен (на Андроид, IOS и др.)
- Стандартный API, сетевой интерфейс и интерфейс графической оболочки

Стандарт POSIX сделает вас гига-чадом в мире программирования, включает в себя множество API, которые будут рассмотрены позже

*Кулстори: Linux появился, когда компания-владелец Unix сделала его платным, при этом Линукс не заимствовал никакого кода из Unix (а точнее, `AT&T Unics`), но повторял многий его функционал*

Unix система включает в себя:
1. Ядро
   1. Само ядро (планировщик, диспетчер системных вызовов, менеджер памяти)
   2. Драйверы устройств
   3. Дополнительные модули (например, драйверы файловых систем и интернет-протоколов)
2. Вторичный загрузчик для дополнительных системных процессов
3. Userland (код, исполняющийся с пользовательскими привилегиями)
4. Инсталлятор и система управления пакетами

## Как работать, что читать, *КАК ВЫЖИТЬ*???
Одна из лучший книг - **Хевилэнд, Грей, Салам. "Системное программирование в UNIX"**

**Читайте доки!!!** Есть они в трёх видах:
- команда `man <имя>` - выводить справку прямо в терминал
- Документация от oracle

### Номера секций для `man`
- `1` - команда shell
- `1M` - команда shell, доступная администратору
- `2` - системные вызовы
- `3C` - стандартная библиотека C

# 23.09.11 - лекция
## Среда исполнения
Процессу можно дать несколько определений:
- Функциональное определение - песочница для запуска программ с ограниченными привилегиями

Каждый процесс имеет своё виртуальное адресное пространство.

Unix-системы используют защиту памяти, что почти похоже на виртуальную память.

Защита памяти реализована следующим образом:

![](./materials/23-09-11_mem-def.png)

Единственный способ попасть вовне среды исполнения - использование системных вызовов - типы прерывания, которые передают управление фрагменту кода с системными правами доступа.

**Не любая среда может пользоваться системными вызовами**

`malloc` может содержать в себе системный вызов, если на куче кончится память и понадобится её увеличить.

Код стандартной библиотеки исполняется из образа в памяти процесса. Также в памяти процесса лежат и другие используемые процессом библиотеки

**Библиотека** - кусок кода, привязываемый к программе статически (при компиляции, привязка называется **линкова**) или динамически (при исполнении. `dlopen`).

Функция в языке в Си, в отличие от простого куска кода, следует соглашению о вызове функций Си.

**`ABI`** - application binary interface - соглашение о вызовах.

### Ядро
Ядро - **все компоненты, работающие в системном режиме (определение Иртегова).** Код в привилегированной области памяти, исполняемый с повышенными привилегиями.

Выполняется командой `syscall`/`sysenter` (что и является системным вызовах), но в Unix имеют особые обёртки, которые выглядят как обычные функции.

Ядро управляет виртуальной памятью, внешними устройствами и всеми процессами.

Таким образом полная схема защиты памяти будет выглядеть так:

![](./materials/23-09-11_mem-def-2.png)

Благодаря этому мы можем добавлять различные атрибуты процессам и не сильно беспокоиться о безопасности.

### Наконец, определение процесса
Процесс - объект операционной системы, т.е. структура данных в ядре, с которой связаны некоторые атрибуты, часть из них видна процессу, часть могут быть изменены только ядром, а часть неизменны на протяжение всего времени жизни процесса.

Процесс - исполняющаяся программа вместе с необходимым окружением (сегменты данных и стэка, user area и др.)

Образ процесса - виртуальное адресное пространство процесса во время исполнения.

Когда мы запускаем программу, на самом деле мы сначала создаём процесс, а уже в рамках него запускаем программу.

Каждый процесс имеет свой уникальный (в один момент времени) `pid`.

Основные структуры процесса (отображённые на память файлы):
- `TEXT` - код программы
- `DATA` - инициализированные статические данные
- `BSS` - неинициализированные статические данные - район памяти, забитый нулями, его нет в бинарнике, там только указан его размер. Смысл этого раздела в наше время почти полностью утрачен.
- `STACK` - хранит нестатические локальные переменные
- `HEAP` - здесь обитаем `malloc`
- Динамические сегменты - из них состоят динамические библиотеки
- User Area (дескриптор процесса в ядре) - фактически, отображение процесса в ядро. Был в старых Unix-системах, сейчас в основном отсутствует из-за многопоточности.
  - Стэк процесса в ядре
  - Дескрипторы открытых файлов
  - Атрибуты процесса

Виртуальная память процесса в архитектуре `Intel x86`:
![](./materials/23-09-11_process-x86.png)

Виртуальная память процессах на `Intel x64`:
![](./materials/23-09-11_process-x64.png)

*Разрыв в середине пространства вызван тем, что на текущий момент для адресации используется только `48` бит из 64-х*

Все процессы кроме `init` имеют родителя. `init` имеет `pid = 1`, запускается при старте системы ядром и запускает все остальные процессы.

### Терминальная сессия
Физически терминалы обслуживаются демоном `ttymon` (раньше был `getty`)

Виртуальные терминалы (сессии) создаются динамически различными сервисами. Например, для сессий терминала `ssh` создателем будет демон `sshd` 

При входе пользователя создаёт сессия с ID, который равен ID процесса-создателя, проводится авторизация, устанавливается ID пользователя и запускается шелл, шелл берётся из учётной записи пользователя (обычно хранится в `/etc/passwd`)

Шеллы с управлением заданиями создают на каждую команду группу процессов.

### Атрибуты процесса
Атрибуты процесса хранятся в пользовательской области в ядре и в пользовательском стэке.

В ядре:
- Процесс
  - ID
  - родитель
  - группа
  - терминал (его может не быть)
  - сессия
  - ограничения (открытые файлы, время процессора, то есть `rlimit`ы)
- Пользователь
  - Идентификатор (реальный/эффективный)
  - Группа (реальный/эффективны)
- Файловая система
  - Открытые файлы
  - Текущая директория
  - Корневая директория (`setroot`)
  - Ограничения (`umask`, `ulimit`)
- Обработка сигналов

В пользовательском стэке хранятся параметры командной строки и переменные среды.

Переменные среды процесса хранятся в памяти процесса 

## Эффективные идентификаторы
Эффективные идентификаторы позволяют пользователю или группе быть представителями других пользователей и групп.

# 23.09.18 - лекция
## Атрибуты процесса (продолжение)
Часть атрибутов процесса находится в ядре. Их можно изменять системными вызовами.

Можно поменять группу процесса, но нельзя поменять ID процесса.

Если процесс потерял родителя (тот завершился раньше самого процесса), то родителем станет процесс `init`

Терминал меняется вместе с сессией.

Ограничения можно только понизить.

### Пользователь
Пользователь - это число.

**НЕ ПУТАТЬ ГРУППЫ ПОЛЬЗОВАТЕЛЕЙ И ГРУППЫ ПРОЦЕССОВ!** По умолчанию процесс принадлежит к тем же группам, что и пользователь.

### Пользовательский стэк
В Си-функцию `main` передаются 3 аргумента: `int argc`, `char** argv`, `char** envp`.

`argc` - вспомогательный и содержит количество аргументов командной строки

`argv` - массив строк, представляющих собой аргументы, передаваемые в команду при её вызове

`envp` - `environment` - переменные среды = аргумент процесса. Хранит массив строк формата `name=value`. Заканчивается `NULL`

## Доступ к системным переменным (атрибутам системы)
Относится к библиотеке `unistd.h`

`sysconf` - смотрит значение системных переменных
- `LINE_MAX` - максимальная длина строки ввода

`pathconf` - посмотреть параметры файловой системы (например, длину имени файла,)

**ЛУЧШЕ ИСПОЛЬЗОВАТЬ ИМЕННО ЭТИХ ФУНКЦИИ ВМЕСТО ЛИМИТОВ ИЗ `limits.h`**

## Пользовательский стэк (стэк процесса)
Кроме переменных среды и позиционных аргументов в пользовательском стэке хранится также стэковый кадр и ограничен защитной областью, которая препятствует бесконечному разрастанию стэка.

**Стэковый кадр** - область памяти в пользовательском стэке, куда сохраняются параметры функции (хотя и не всегда и не все), адрес возврата, сохранённые регистры, локальные переменные, а также дополнительно в C указатели на обработчики исключений и деструкторы локальных переменных.

## Доступ к переменным среды
Можно получить третьим аргументов (говорилось выше), через внешнюю переменную `extern char** environ` (в начальный момент времени совпадает с переменными среды родителя), либо через функции `getenv`, `putenv`.

### Конкретные переменные среды
`PATH` - переменная среды, хранящая каталоги через `,`. В этих каталогах будут искаться исполняемые файлы (*фан-факт - в Винде пути разделяются `:`*).

`TERM` - тип терминала, используется экранными редакторами и другими программами

`HOME` - домашний каталог

`USER` - имя пользователя (**НЕ ПУТАТЬ С `UID`!**)

`SHELL`

`LOGIN`

### `TZ`
**Ядро живёт по Гринвичу**

Если переменная среды `TZ` не установлена, то часовой пояс берётся из файла `/etc/localtime`.

Существует несколько форматов часового пояса:
- `Asia/Novisibirsk` - указывает на файл в `/usr/share/zoneinfo` - бинарнике, в котором хранится вся информация о часовом поясе. 
- В Solaris:
  - `/etc/TIMEZONE` - имя часового пояса
  - `/etc/LOCALTIME` - смещение часового пояса
- Стандартные названия имён (например, `PST8PDT`)
- `<Любые 3 буквы>-<сдвиг>`

Если мы хотим не менять переменную среды, у родителя, а только у нового процесса, то можно написать значение переменной среды, а после в той же строке вызвать команду.

### Изменение переменных среды
Для изменения переменных среды можно просто обратиться к неё через `$`, также для работы с переменной рекомендуется её экспортировать

Если при изменении переменных среды в C-программе через `putenv`, `setenv` нам начинает не хватать места на стэке, будет автоматически вызван `malloc`, а переменная переменные среды переместятся на стэк. Именно поэтому рекомендуется использовать эти функции, а не `char** envp`.

Если вдруг мы хотим поменять переменную среды для нашего терминала, можно использовать функцию `source`, если мы хотим поменять переменную среды для каждой нашей терминальной сессии, то мы можем отредактировать `.bashrc`

## `setuid`
Доступ к ресурсам основывается на эффективных ID пользователя и группы (по ним проверяются права доступа)

Реальный ID ставится при входе пользователя в систему. В этот момент чаще всего эффективный ID приравнивается реальному.

При запуске программы с битом `setuid` её эффективный идентификатор приравнивается к реальному идентификатору хозяина файла.

Пароли в Linux хранятся в `/etc/shadow`. При этом возникает вопрос, как защитить этот файл от произвольного доступа, но дать доступ пользователю через утилиту `passwd`. **Ответ:** `passwd` запускается с битом `setuid`. *Фан-факт:* если рут запустит `passwd`, то он сможет поменять любой пароль.

У `sudo` под капотом тоже содержится `setuid` бит.

**НЕ ПУТАТЬ `setuid`-бит с системным вызовом `setuid` - он позволяет менять эффективный ID процесса, устанавливая его идентичным реальному ID**

Также есть системный вызов `setgid` - работает аналогично `setuid`, но для группы

## Системные вызовы ввода/вывода
### Что такое файл?
**Файл** - последовательность байтов с адресацией с точностью до байта

**Файл** - именованная совокупность данных (*из книги Иртегова*)(*на самом деле это в первую очередь справедливо для регулярных файлов*)

Метка конца файла не входит в данные файла.

Файл - это универсальный интерфейс с внешними устройствами. Таким образом, даже устройства для ввода-вывода звука будут иметь своё представление в виде файла.

**Определение из словаря POSIX:** файл - объект, который можно читать и писать.

**Всё есть файл (*ну... кроме процессов, хотя... см. дальше*)**

**Папка `proc`** содержит информацию о процессах, в частности, там можно увидеть всё адресное пространство процесса.

# 23.09.25 - Лекция
## Файловая система и где хранятся файлы
Доступ к постоянной памяти производится по секторам. Обычно они составляют 512 байт.

**Файловая система** - структура данных на внешнем носителе. На самом деле этим определением могут называться 3 разных, пусть и связанных сущности:
- **Формат данных**, описывающие размещение данных
- **Программа - модуль ядра**, позволяющий работать с файловой системой
- **Экземпляр файловой системы** на конкретном носителе

Файловая система сравнима с архивом. Ключевое различие в возможности изменения размера файлов.

### Основные папки в корне Линукс
- `/bin` - бинарные файлы
- `/boot` - файлы при загрузке
- `/dev` - файлы устройств и псевдоустройств (в т.ч. диски)
- `/etc` - общесистемные конфиги
  - `/opt` - 
- `/home` - каталоги пользователей
- `/lib` - основные библиотеки, необходимые для работы программ из `/bin`, `/sbin` (**либы - неисполняемые системные файлы**)
- `/media` - временные носители (флэшки, диски и т.п.)
- `/mnt` - временно монтируемые файловые системы
- `/opt` - дополнительное ПО
- `/proc` - виртуальная файловая система, представляющая состояние ядра ОС и запущенных процессов в виде файлов
- `/root` - домашний каталог рута
- `/run` - информация о системе с момента запуска, pidы, сокеты и т.п.
- `/sbin` - бинарники для администрирования
- `/srv` - данные для предоставляемой системой сервисов
- `/sys` - информация о драйверах, устройствах и некоторых свойствах ядра
- `/tmp` - временные файлы
- `/usr`
- `/var` - хранит изменяемые файлы (файлы регистрации, временные почтовые файлы)

## Продолжаем про определение и основные свойства файла
Формат файлов системе по большей части безразличен, исключение - бинарные исполняемые файлы

С точки зрения приложений существует 2 типа файлов: текстовые и бинарные.

Файлы хранятся в ядре и реализуют интерфейс чтения/записи.

**Файл-каталог** - файл, содержащий информацию о своих файлах и каталогах потомках

На самом деле в один и тот же каталог можно прийти от нескольких родителей

## Системный вызов `open(2)`, дескрипторы файлов, `file_t` и `vnode`
`open(char* pathname, int flags, [mode_t mode])` - `2` - Открывает файл по указанному пути и с указанными флагами, в случае успеха возвращает индекс, указывающий на элемент массива в user area - указатель на дескриптор файла.

`char* pathname` - путевое имя, содержащее имена каталогов через прямой слэш. Могут быть относительными и абсолютными. Абсолютный путь начинается с `/`, относительный путь - с другого символа, относительные пути строятся от текущей директории - переменной среды `PWD`, которая есть у каждого процесса

**Дескриптор** - число, относящееся к описанию файла, хранящемуся в ядре (в user area). Описание содержит отступ и флаги:
- `O_RDONLY`
- `O_WRONLY`
- `O_RDWR`
- `O_APPEND` - как `O_WRONLY`, но указатель помещается в конец файла
- `O_CREAT` - создаёт файл, если он не существует (**может создать только регулярный файл**). При этом флаге необходимо указывать права доступа (`mode_t mode`)
- `O_TRUNC` - стирает содержимое файла
- `O_EXCL` - используется вместе с `O_CREAT` и вернёт ошибку, если файл уже существует
- `O_SYNC` - заставляет `write(2)` ожидать окончания физической записи на диск (по-умолчанию данные записываются сначала в оперативную память)
- `O_NDELAY`, `O_NONBLOACK` - открытие специального байт-ориентированного файла или именованного программного канала часто вызывает блокировку. Любой из этих флагов предотвратит блокировку `open(2)`

*За каждый флаг отвечают определённые биты в аргументе `int flags`, поэтому для их комбинации надо использовать побитовое ИЛИ (`|`)*

Опциональный параметр `mode_t mode` указывает права доступа к создаваемому файлу.

**В случае неудачи** `open(2)` вернёт `-1`

### Как работает `open(2)`
1. Файл ищется в иерархии директорий для получения `inode` (**файловая запись**, она у файла одна)
2. Проверяются права доступа
3. В таблице дескрипторов размещается новый дескриптор
4. Проверяется системная структура файлов и, если необходимо, размещается новое поле
5. Если необходимо, размещается новая структура информации о файле `file_t`
6. Соединяется с подходящим драйвером устройства:
   - Создать структуру `vnode` (в Линукс - `inode`)
   - Записать в поля этой структуры указатели на функции драйвера
7. Возвращается дескриптор

Структура информации о файле (`file_t`) хранится в ядре и создаётся каждый раз при вызове `open(2)`, тогда как `vnode` будет один на все структуры `file_t` одного файла

Структура `file_t`:
```c
typedef struct file {
  kmutex_t f_tlock; /* short term lock */
  ushort_t f_flag;
  ushort_t f_flag2; /* extra flags (FSEARCH, FEXEC) */
  struct vnode *f_vnode; /* pointer to vnode structure */
  offset_t f_offset; /* read/write character pointer */
  struct cred *f_cred; /* credentials of user who opened it */
  struct f_audit_data *f_audit_data; /* file audit data */
  int f_count; /* reference count */
  struct filock *f_filock; /* ptr to single lock_descriptor_t */
} file_t;
```

[Структура `vnode`](https://github.com/illumos/illumos-gate/blob/master/usr/src/uts/common/sys/vnode.h)

**На самом деле дескриптором корректнее называть структуру `file_t`, а не индекс в user_area, его называют "ручкой"**

*Фан-факт:* права доступа проверяются только в момент открытия файла

## `close(2)`
`close(int fd)` - освобождает индекс, указывающий на дескриптор `file_t`. Если это последний дескриптор на `file_t`, то эта структура также удаляется. Если удалена последняя структура `file_t`, то будет удалена структура `vnode`, но лишь через некоторое время

## `read(2)`
`ssize_t read(int fd, void* buf, size_t count)` - пытается прочитать из дескриптора файла до `count` байтов и записать их в буфер по адресу `void* buf`. Возвращает количество считанных байтов либо `-1` при ошибке (**запись нуля байт не является ошибкой**)

## `write(2)`
`ssize_t write(int fd, void* buf, size_t count)` - записывает в файл по дескриптору `fd` `count` байт из буфера по адресу `void* buf`. Возвращает количество записанных байт либо `-1` при ошибке

## Стандартные потоки и их связь с дескрипторами
- `0` - `stdin`
- `1` - `stdout`
- `2` - `stderr`

# 23.10.02 - лекция
## `fsync(2)`
Любая программа может писать данные гораздо быстрее, чем это происходит на внешних накопителях, поэтому зачастую данные пишутся в системный буфер, а далее, параллельно дальнейшим операциям производится запись в память

```c
#include <unistd.h>

int fsync(int fd);
```

Ожидает записи данных из буфера в постоянную память. Удобнее, чем использовать флаг `O_SYNC` в `open(2)`, так как мы можем отдельно решать, в какие моменты нам важно, что данные были записаны, а в какие мы оставляем запись из буфера в постоянную память на усмотрение системы.

Возвращает `0` в случае успеха и `-1` с записью кода ошибки в `errno` при неудаче

## `lseek(2)`
```c
#include <sys/types.h>
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
```
Сдвигает указатель в файле по заданному дескриптору. В случае успеха возвращает расстояние в байтах от начала файла и `-1` с записью кода ошибки в `errno` при неудаче.

`whence` определяет, откуда будет происходить сдвиг курсора:
- `SEEK_CUR` - от текущей позиции курсора
- `SEEK_SET` - от начала файла
- `SEKK_END` - от конца файла

При сдвиге назад от начала будет оставаться нулевая позиция.

При сдвиге дальше конца мы можем читать данные и будем получать `\0`. Если же мы попытаемся записать данные туда, то получим разреженный файл - между блоками с данными будет пространство с нулями, под которое не выделяется память на диске.

Интересный пример применения разреженных файлов есть в некоторы торрент трекеров, которые сразу создают файл нужной длину и потом, скачивая отдельные куски, складывают их сразу в нужные места (*другие наращивают файл постепенно*)

Обычно разреженные файлы НЕ ТЕКСТОВЫЕ

## `dup(2)`
```c
#include <unistd.h>

int dup(int fd);
```
Возвращает новый дескриптор, относящийся к тому же `file_t`. Ищет свободную ручку с нуля. `dup2()` ищет с указанного индекса

## `fcntl(2)`
```c
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>

int fcntl(int fd, int cmd, /* arg */);
```
Представляет собой сборник из команд, которым не захотели выделять отдельные системные вызовы. Возвращаемое значение в случае успеха зависит от `cmd`, как и следующие за `cmd` аргументы

Флаги без `args`:
- `F_GETFD` - получить состояние флага закрытия-по-`exec`
- `F_GETFL` - Получить флаги `NDELAY`, `NONBLOCK`, `SYNCH`, `APPEND`

Флаги с `int arg`:
- `F_DUPFD`
- `F_SETFD`
- `F_SETFL`

### `struct flock`
```c
typedef struct flock
{
  short l_type;
  short l_whence;
  /* SEEK_SET, SEEK_CUR, SEEK_END */
  off_t l_start;
  off_t l_len;
  /* len == 0 means until end of file */
  long l_sysid;
  pid_t l_pid;
  long pad[4]; /* reserve area */
} flock_t; 
```
Флаги с для `fcntl` с `struct flock *arg`:
- `F_FREESP` - освободить физический носитель.
  - Если идём от конца файла, то укоротит место для файла
  - Если указать пространство внутри файла, то мы создадим в нём дырку
- *добавить*

## *Хуяк!* И тут у нас управление памятью
**Статическое управление памятью**
- Требуемое количество памяти известно в момент сборки программы
- Достаточно проверить, есть ли требуемая память в момент загрузки
- Размечается процессором
- Достаточно помнить границу между занятой и свободной памятью

**Динамическое управление памятью**
- Память может запрашиваться и освбождаться во время исполнения программы
- Необходимо поддерживать список свободных областей памяти (называется **пул** либо **куча**)
- Стэковые кадры в C/C++ являются простейшим примером динамической памяти (*так как пременные существют лишь до тех пор, пока исполняется функция*)
- Стэковое (**LIFO**) управление памятью при загрузке программ

### Веселуха с динамической памятью и попытки её решить
В связи с выделением непрерывного блока памяти с началом по строго указанному указателю мы получаем проблему **внешней фрагментации** - между выделенными блоками будут пустые пространства произвольного размера, которых по отдельности будет не хватать для выделения новго блока, хотя в сумме памяти хватило бы.

Одно из решений - выделять кусок памяти кратной какому-то конкретному числу длины под любой запрос памяти. Проблема - **внутренняя фрагментация** - даже под небольшой объём данных мы выделим большой блок, из-за чего много пространства будет простаивать.

Зачастую создаётся определённая структура с информацией о свободных блоках.

Стратегии поиска свободных блоков:
- Best fit - требует просмотра всего пула либо сортировки, увеличивает фрагментацию и уменьшает средний размер отбрасываемого "хвоста"
- First fit - находим первый подходящий блок (*используется чаще всего, для реализации часто используется кольцевой список*)
- Worst fit - требует сортировки блоков, заключается в отрезании от самого большого блока нужное количество памяти (*реазлиуется вместе с maxHeap - именно поэтому кучу называют кучей, хотя сам по себе worst fit в чистом виде уже и не используется*)

Про склеивание свободных блоков и алгоритм парных меток можно прочитать [выше](#распределение-памяти-работа-api-mallocfree)

Существует множество и других стратегий `malloc`, которые оптимизированы под конкретные и в разной степени специфичные задачи:
- Для компьютеров, предназначенных для сложных математических расчётов
- Для компьютеров разделённого времени (выполняющих множество задач параллельно, принимающих пользовательские сигналы)
- Для систем реального времени (автопилот машины и т.п.)

**Алгоритм близнецов (best fit)** подходит как раз для систем реального времени, так как выделяет память за фиксированное время. Заключается в создании блоков размером в степени двойки. Деление памяти делается по принципу бинарного дерева. Проходим вниз дерева до тех пор, пока не будет найден минимально подходящий блок. Объединиться свободные блоки могут только если они относятся к одному и тому же родителю.

# 23.10.09 - лекция
## Продолжение про выделение памяти
### Слабовые аллокаторы
Slab - плита, лист, пластина

Испльзуется, если нам нужно много блоков одинакового размера (особенно, если они не кратны степеням двойки)

В ядре создаётся объект кэша, в котором указывается, какого размера блоки мы хотим выделять. Затем берётся большой кусок памяти и режется на фрагменты указанного нами размера.

Кэши связываются списком.

В кэше хранятся указатели на занятые слабы, частично свободные и полностью свободные.

Слабы не лишены проблемы дефрагментации, но её нельзя назвать ни внешней, ни внутренней.

*Дальшей идёт допматериал про попытки решения проблемы этой дефрагментации*

### Сборка мусора
Чтобы не было проблем с каскадной порчей данных и утечек памяти, необходимо эту память корректно освобождать за счёт одной из стратегий сборки мусора.

Существует 2 основных стратегии:
- Подсчёт ссылок (уходящий последним гасит свет)
- Рекурсивный просмотр ссылок (mark and sweep).
  - В момент работыы стратегии необходимо остановить всю деятельность, которая может привести к уничтожению или созданию ссылок и объектов
  - Рекурсивно движемся по все указателям, помечая объекты, как живые
  - Все непомеченные объекты будут удалены. Перед следующим запуском сборщика необходимо снять метки
  - Достаточно прожорлива по производительности и потребляемой памяти.

Стратегия mark and sweep обладает рядом недостаков, для которых предложены различные решения:
- Высокое потрбления памяти
- Блокирование исполнения программ
  - Решается неблокирующим сборщиком

**Копирующий сборщик**. Создаём 2 области в помечченные живыми объектами перемещаем в новый объект. Ведущие из области мусора ссылки *игнорируются (?)*.

#### Генерационная сборка мусора
Улучшенной версией будет **генерационная сборка мусора**. Делается в 2 прохода через большую и малую сборку мусора *по не самым пока что понятным мне правилам*:
![](./materials/23-10-09%20-%20generation%20garbage%20collector.png)

Генерационный сборщик основан на предположении, что старые объекты редко ссылаются на новые, поэтому при малых сборках старые объекты вообще не трогаются, однако так бывает не всегда. **Remembering set** - набор ссылок из старых объектов на новые.

**Garbage First (G1)** - вместо поколений разбивает кучу на области одинакового размера и использует remembering set для отслеживания ссылок между областями и оценивания количества живых объектов в каждой из областей. Выбрав регион с максимальным количеством мусора и без ведущих туда ссылок, проводит неблокирующую сборку

*Остановился на 35-м слайде презентации про память и сказал, что дальше идти смысла нет сейчас*

## Виртуальная память
Linux и Windows используют **аппаратную защиту памяти** или, что похоже, но не совсем то же самое, **виртуальную память**.

**MMU** - Memory management Unit - стоит на пути от процессора к памяти и "что-то делает с адресами запрашиваемых ичеек". В отличие от, например, переключателя банок памяти для CdM-8, MMU не обязательно отобразит отправленный процессором адрес в какой-то адрес в памяти - вместо этого он может выкинуть исключение.

Процесс не знает, где он лежит в реальной памяти, а лишь может обращаться к ячейкам в рамках определённого лимита.

Если процесс запросит доступ к ячейке выше лимита, то MMU выбросит исключение, если ячейка будет меньше лимита, то MMU добавит к запрашиваемому адресу начало его области в реальной памяти (`BASE`). `BASE` и `LIMIT` передаются процессором в регистры MMU

**Запомните!!!** Системный вызов переводит исполнение кода в режим ядра.

В том числе, в режиме ядра можно осуществлять ввод-вывод и менять регистры MMU. А значит, ядро может перемещать реальное расположение процесса в памяти.

### Ещё раз про сравнение пользовательского и системного режима
Система:
- Может делать ввод-вывод
- Может менять регистры MMU
- Иногда может вообще выключить MMU
- Имеет доступ к пользовательской памяти
- Может произвольно переходить в пользовательский режим

Пользователь:
- Первые 3 пункта с отрицанием
- Не имеет доступ к памяти ядра
- *дописать про режим ядра*

### Чем плоха базовая адресация
Главная проблема базовой адресации (записанного ранее алгоритма работы MMU) - необходимость выдавать процессу непрерывную область памяти. Это приводит к всё той же проблеме фрагментации.

Решением проблемы стало разделение области памяти на отдельные фрагменты => в MMU хранится множество пар `BASE`-`LIMIT`. (*Всопминаем разделение памяти процесса и преисполняемся*). Сегментация определяется архитектурой процессора.

#### КРИТ ПРО СЕЛЕКТОР
Соответственное, теперь запрос от процессора делится на 2 части: селектор и смещение. Селектор определяет регистр в MMU. Кодируются одни числом, что логично.

Также к описанию каждого сегмента добавились права: чтение, запись или и то, и то.

Чтобы не ограничиваться количеством регистров MMU, выделили в памяти область под таблицы трансляции. В них также хранятся селекторы, права доступа, базовый адрес и размер области. Теперь MMU Достаточно хранить адрес таблицы трансляции

<hr>

Наиболеее часто используемый сейчас вариант: страничные таблицы трансляции без указания размера блоков с фиксированной небольшой длиной (на 32-битных системах это около 4 КБ. Такой вариант позволяет разметить 2^20, что примерно миллион областей).