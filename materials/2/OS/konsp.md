- [Инфо](#инфо)
- [Набор функций и системных вызовов](#набор-функций-и-системных-вызовов)
- [23.09.04 - лекция (Введение. Системы семейства Unix)](#230904---лекция-введение-системы-семейства-unix)
  - [Как работать, что читать, *КАК ВЫЖИТЬ*???](#как-работать-что-читать-как-выжить)
    - [Номера секций для `man`](#номера-секций-для-man)
- [23.09.11 - лекция](#230911---лекция)
  - [Среда исполнения](#среда-исполнения)
    - [Ядро](#ядро)
    - [Наконец, определение процесса](#наконец-определение-процесса)
    - [Терминальная сессия](#терминальная-сессия)
    - [Атрибуты процесса](#атрибуты-процесса)
  - [Эффективные идентификаторы](#эффективные-идентификаторы)
- [23.09.18 - лекция](#230918---лекция)
  - [Атрибуты процесса (продолжение)](#атрибуты-процесса-продолжение)
    - [Пользователь](#пользователь)
    - [Пользовательский стэк](#пользовательский-стэк)
  - [Доступ к системным переменным (атрибутам системы)](#доступ-к-системным-переменным-атрибутам-системы)
  - [Пользовательский стэк (стэк процесса)](#пользовательский-стэк-стэк-процесса)
  - [Доступ к переменным среды](#доступ-к-переменным-среды)
    - [Конкретные переменные среды](#конкретные-переменные-среды)
    - [`TZ`](#tz)
    - [Изменение переменных среды](#изменение-переменных-среды)
  - [`setuid`](#setuid)
  - [Системные вызовы ввода/вывода](#системные-вызовы-вводавывода)
    - [Что такое файл?](#что-такое-файл)

# Инфо
Лектор - Иртегов Дмитрий Валентинович

Семинарист - Куталев Андрей Витальевич ([bitgrandmaster@yandex.ru](mailto:bitgrandmaster@yandex.ru))

[Более-менее актуальные лекции](http://parallels.nsu.ru/~fat/unixsvr4-new/trunk/)

[Как сдавать задачи](https://classroom.google.com/u/3/c/NTg5NDgxNTc4ODA4/m/NjIwNjE0NDU3ODY4/details)
- [Задачи](https://docs.google.com/document/d/1242C_65gJ_8HscvJ4RolW09KGS-jieYWwomrRTK_bn0/edit#heading=h.v7414bii3pa)



# Набор функций и системных вызовов
После функции будет стоять `2`, если это системный вызов, и `3C`, если это C-библиотека
- `perror()` - `3C` - будет часто использоваться, и очень удобна для вывода ошибок в `stderr`
- `time()` - `2` - возвращает время в секундах с начала **ЭПОХИ (1 января 1970, 00:00:00 UTC)**

# 23.09.04 - лекция (Введение. Системы семейства Unix)
Unix не доминирующий, но пережил уже 2,5 поколения.

Различные системы семейства Unix:
- Android
- Linux
- WinDriver / Intel VxWorks - система реального времени для интернета вещей
- IBM AIX
- HP UX
- MacOS, IOS
- Sun microsystems / Oracle Solaris

Unix-системы различаются: 
- по лицензированию (free & open source / commerce)
- методам применения (серверы, рабочие станции, мобильные устройства и устройства умного дома)
- Аппаратная архитектура (x86/x64, ARM, MIPS, PowerPC, PA/RISC)
- Архитектура ядра (монолитное ядро, потоки, микроядро Unix SVR4, Multiple personality microkernel)

К общим особенностям семейства Unix относят:
- API - общий стандарт интерфейса ядра и системных библиотек, код совместим с точностью до перекомпиляции
- Стандартный командный язык
  - Командные процессоры sh (bash, ksh) и утилиты
  - Часть стандарта POSIX
  - Может быть недоступен (на Андроид, IOS и др.)
- Стандартный API, сетевой интерфейс и интерфейс графической оболочки

Стандарт POSIX сделает вас гига-чадом в мире программирования, включает в себя множество API, которые будут рассмотрены позже

*Кулстори: Linux появился, когда компания-владелец Unix сделала его платным, при этом Линукс не заимствовал никакого кода из Unix (а точнее, `AT&T Unics`), но повторял многий его функционал*

Unix система включает в себя:
1. Ядро
   1. Само ядро (планировщик, диспетчер системных вызовов, менеджер памяти)
   2. Драйверы устройств
   3. Дополнительные модули (например, драйверы файловых систем и интернет-протоколов)
2. Вторичный загрузчик для дополнительных системных процессов
3. Userland (код, исполняющийся с пользовательскими привилегиями)
4. Инсталлятор и система управления пакетами

## Как работать, что читать, *КАК ВЫЖИТЬ*???
Одна из лучший книг - **Хевилэнд, Грей, Салам. "Системное программирование в UNIX"**

**Читайте доки!!!** Есть они в трёх видах:
- команда `man <имя>` - выводить справку прямо в терминал
- Документация от oracle

### Номера секций для `man`
- `1` - команда shell
- `1M` - команда shell, доступная администратору
- `2` - системные вызовы
- `3C` - стандартная библиотека C

# 23.09.11 - лекция
## Среда исполнения
Процессу можно дать несколько определений:
- Функциональное определение - песочница для запуска программ с ограниченными привилегиями

Каждый процесс имеет своё виртуальное адресное пространство.

Unix-системы используют защиту памяти, что почти похоже на виртуальную память.

Защита памяти реализована следующим образом:

![](./materials/23-09-11_mem-def.png)

Единственный способ попасть вовне среды исполнения - использование системных вызовов - типы прерывания, которые передают управление фрагменту кода с системными правами доступа.

**Не любая среда может пользоваться системными вызовами**

`malloc` может содержать в себе системный вызов, если на куче кончится память и понадобится её увеличить.

Код стандартной библиотеки исполняется из образа в памяти процесса. Также в памяти процесса лежат и другие используемые процессом библиотеки

**Библиотека** - кусок кода, привязываемый к программе статически (при компиляции, привязка называется **линкова**) или динамически (при исполнении. `dlopen`).

Функция в языке в Си, в отличие от простого куска кода, следует соглашению о вызове функций Си.

**`ABI`** - application binary interface - соглашение о вызовах.

### Ядро
Ядро - **все компоненты, работающие в системном режиме (определение Иртегова).** Код в привилегированной области памяти, исполняемый с повышенными привилегиями.

Выполняется командой `syscall`/`sysenter` (что и является системным вызовах), но в Unix имеют особые обёртки, которые выглядят как обычные функции.

Ядро управляет виртуальной памятью, внешними устройствами и всеми процессами.

Таким образом полная схема защиты памяти будет выглядеть так:

![](./materials/23-09-11_mem-def-2.png)

Благодаря этому мы можем добавлять различные атрибуты процессам и не сильно беспокоиться о безопасности.

### Наконец, определение процесса
Процесс - объект операционной системы, т.е. структура данных в ядре, с которой связаны некоторые атрибуты, часть из них видна процессу, часть могут быть изменены только ядром, а часть неизменны на протяжение всего времени жизни процесса.

Когда мы запускаем программу, на самом деле мы сначала создаём процесс, а уже в рамках него запускаем программу.

Каждый процесс имеет свой уникальный (в один момент времени) `pid`.

Основные структуры процесса (отображённые на память файлы):
- `TEXT` - код программы
- `DATA` - инициализированные статические данные
- `BSS` - неинициализированные статические данные - район памяти, забитый нулями, его нет в бинарнике, там только указан его размер. Смысл этого раздела в наше время почти полностью утрачен.
- `STACK` - хранит нестатические локальные переменные
- `HEAP` - здесь обитаем `malloc`
- Динамические сегменты - из них состоят динамические библиотеки
- User Area (дескриптор процесса в ядре) - фактически, отображение процесса в ядро. Был в старых Unix-системах, сейчас в основном отсутствует из-за многопоточности.
  - Стэк процесса в ядре
  - Дескрипторы открытых файлов
  - Атрибуты процесса

Виртуальная память процесса в архитектуре `Intel x86`:
![](./materials/23-09-11_process-x86.png)

Виртуальная память процессах на `Intel x64`:
![](./materials/23-09-11_process-x64.png)

*Разрыв в середине пространства вызван тем, что на текущий момент для адресации используется только `48` бит из 64-х*

Все процессы кроме `init` имеют родителя. `init` имеет `pid = 1`, запускается при старте системы ядром и запускает все остальные процессы.

### Терминальная сессия
Физически терминалы обслуживаются демоном `ttymon` (раньше был `getty`)

Виртуальные терминалы (сессии) создаются динамически различными сервисами. Например, для сессий терминала `ssh` создателем будет демон `sshd` 

При входе пользователя создаёт сессия с ID, который равен ID процесса-создателя, проводится авторизация, устанавливается ID пользователя и запускается шелл, шелл берётся из учётной записи пользователя (обычно хранится в `/etc/passdw`)

Шеллы с управлением заданиями создают на каждую команду группу процессов.

### Атрибуты процесса
Атрибуты процесса хранятся в пользовательской области в ядре и в пользовательском стэке.

В ядре:
- Процесс
  - ID
  - родитель
  - группа
  - терминал (его может не быть)
  - сессия
  - ограничения (открытые файлы, время процессора, то есть `rlimit`ы)
- Пользователь
  - Идентификатор (реальный/эффективный)
  - Группа (реальный/эффективны)
- Файловая система
  - Открытые файлы
  - Текущая директория
  - Корневая директория (`setroot`)
  - Ограничения (`umask`, `ulimit`)
- Обработка сигналов

В пользовательском стэке хранятся параметры командной строки и переменные среды.

Переменные среды процесса хранятся в памяти процесса 

## Эффективные идентификаторы
Эффективные идентификаторы позволяют пользователю или группе быть представителями других пользователей и групп.

# 23.09.18 - лекция
## Атрибуты процесса (продолжение)
Часть атрибутов процесса находится в ядре. Их можно изменять системными вызовами.

Можно поменять группу процесса, но нельзя поменять ID процесса.

Если процесс потерял родителя (тот завершился раньше самого процесса), то родителем станет процесс `init`

Терминал меняется вместе с сессией.

Ограничения можно только понизить.

### Пользователь
Пользователь - это число.

**НЕ ПУТАТЬ ГРУППЫ ПОЛЬЗОВАТЕЛЕЙ И ГРУППЫ ПРОЦЕССОВ!** По умолчанию процесс принадлежит к тем же группам, что и пользователь.

### Пользовательский стэк
В Си-функцию `main` передаются 3 аргумента: `int argc`, `char** argv`, `char** envp`.

`argc` - вспомогательный и содержит количество аргументов командной строки

`argv` - массив строк, представляющих собой аргументы, передаваемые в команду при её вызове

`envp` - `environment` - переменные среды = аргумент процесса. Хранит массив строк формата `name=value`. Заканчивается `NULL`

## Доступ к системным переменным (атрибутам системы)
Относится к библиотеке `unistd.h`

`sysconf` - смотрит значение системных переменных

`pathconf` - посмотреть параметры файловой системы (например, длину имени файла,)

**ЛУЧШЕ ИСПОЛЬЗОВАТЬ ИМЕННО ЭТИХ ФУНКЦИИ ВМЕСТО ЛИМИТОВ ИЗ `limits.h`**

## Пользовательский стэк (стэк процесса)
Кроме переменных среды и позиционных аргументов в пользовательском стэке хранится также стэковый кадр и ограничен защитной областью, которая препятствует бесконечному разрастанию стэка.

**Стэковый кадр** - область памяти в пользовательском стэке, куда сохраняются параметры функции (хотя и не всегда и не все), адрес возврата, сохранённые регистры, локальные переменные, а также дополнительно в C указатели на обработчики исключений и деструкторы локальных переменных.

## Доступ к переменным среды
Можно получить третьим аргументов (говорилось выше), через внешнюю переменную `extern char** environ` (в начальный момент времени совпадает с переменными среды родителя), либо через функции `getenv`, `putenv`.

### Конкретные переменные среды
`PATH` - переменная среды, хранящая каталоги через `,`. В этих каталогах будут искаться исполняемые файлы (*фан-факт - в Винде пути разделяются `:`*).

`TERM` - тип терминала, используется экранными редакторами и другими программами

`HOME` - домашний каталог

`USER` - имя пользователя (**НЕ ПУТАТЬ С `UID`!**)

`SHELL`

`LOGIN`

### `TZ`
**Ядро живёт по Гринвичу**

Если переменная среды `TZ` не установлена, то часовой пояс берётся из файла `/etc/localtime`.

Существует несколько форматов часового пояса:
- `Asia/Novisibirsk` - указывает на файл в `/usr/share/zoneinfo` - бинарнике, в котором хранится вся информация о часовом поясе. 
- В Solaris:
  - `/etc/TIMEZONE` - имя часового пояса
  - `/etc/LOCALTIME` - смещение часового пояса
- Стандартные названия имён (например, `PST8PDT`)
- `<Любые 3 буквы>-<сдвиг>`

Если мы хотим не менять переменную среды, у родителя, а только у нового процесса, то можно написать значение переменной среды, а после в той же строке вызвать команду.

### Изменение переменных среды
Для изменения переменных среды можно просто обратиться к неё через `$`, также для работы с переменной рекомендуется её экспортировать

Если при изменении переменных среды в C-программе через `putenv`, `setenv` нам начинает не хватать места на стэке, будет автоматически вызван `malloc`, а переменная переменные среды переместятся на стэк. Именно поэтому рекомендуется использовать эти функции, а не `char** envp`.

Если вдруг мы хотим поменять переменную среды для нашего терминала, можно использовать функцию `source`, если мы хотим поменять переменную среды для каждой нашей терминальной сессии, то мы можем отредактировать `.bashrc`

## `setuid`
Доступ к ресурсам основывается на эффективных ID пользователя и группы (по ним проверяются права доступа)

Реальный ID ставится при входе пользователя в систему. В этот момент чаще всего эффективный ID приравнивается реальному.

При запуске программы с битом `setuid` её эффективный идентификатор приравнивается к реальному идентификатору хозяина файла.

Пароли в Linux хранятся в `/etc/shadow`. При этом возникает вопрос, как защитить этот файл от произвольного доступа, но дать доступ пользователю через утилиту `passwd`. **Ответ:** `passwd` запускается с битом `setuid`. *Фан-факт:* если рут запустит `passwd`, то он сможет поменять любой пароль.

У `sudo` под капотом тоже содержится `setuid` бит.

**НЕ ПУТАТЬ `setuid`-бит с системным вызовом `setuid` - он позволяет менять эффективный ID процесса, устанавливая его идентичным реальному ID**

Также есть системный вызов `setgid` - работает аналогично `setuid`, но для группы

## Системные вызовы ввода/вывода
### Что такое файл?
**Файл** - последовательность байтов с адресацией с точностью до байта

Метка конца файла не входит в данные файла.

Файл - это универсальный интерфейс с внешними устройствами. Таким образом, даже устройства для ввода-вывода звука будут иметь своё представление в виде файла.

**Определение из словаря POSIX:** файл - объект, который можно читать и писать.