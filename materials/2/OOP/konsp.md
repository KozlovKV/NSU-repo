- [Инфо](#инфо)
- [Дополнительные заметки](#дополнительные-заметки)
  - [Пакеты в Java](#пакеты-в-java)
    - [import](#import)
    - [Компиляция кода, раскиданного по пакетам](#компиляция-кода-раскиданного-по-пакетам)
  - [`equals` и `hashCode`](#equals-и-hashcode)
- [23.09.07 - лекция](#230907---лекция)
  - [Введение](#введение)
- [23.09.14 - Лекция](#230914---лекция)
- [23.09.21 - лекция](#230921---лекция)
  - [Примитивные типы данных](#примитивные-типы-данных)
    - [Классы примитивных типов](#классы-примитивных-типов)
  - [Ключевые слова на Java](#ключевые-слова-на-java)


# Инфо
Лектор - Власов Александр Александрович / Шадрина Анастасия Александровна (иногда)

Семинаристка - Быкова Галина Павловна 

[Всё о практике](https://classroom.google.com/u/3/c/Njc3NDc0ODQ3OTFa/p/NjIwOTc0MTA4NDM5?pli=1)

**Для `build.gradle` в качестве DSL использовать `Groovy`**

# Дополнительные заметки
## Пакеты в Java
[Источник](https://habr.com/ru/articles/755654/)

Для использования множества классов с (возможно) пересекающимися именами в Java используются пространства имён, также называемые пакетами. 

Организуются пакеты весьма просто: имя пакета - адрес до файла после папки `src`, то есть файл по адресу `project/src/kozlov/kirill/main/Main.java` будет относиться к пакету `kozlov.kirill.main`. Для указания принадлежности файла к пакету необходимо в начале файла прописать `package kozlov.kirill.main;`. Если этого не указать, сущности из файла **попадут в безымянный пакет**, что крайне не рекомендуется для хоть сколько-нибудь серьёзных проектов.

```java
package kozlov.kirill.main;

public class Main() {
  public static void main(String argv[]) {
    // ...
  }
}
```

### import
К сущностям из безымянного проекта можно обращаться откуда угодно, что создаёт опасность коллизии имён. Для обращения к методу класса из пакета из примера выше мы прописываем в коде полный путь `kozlov.kirill.main.Main.main()`. 

Чтобы не писать каждый раз длинное имя пакета используются импорты:
```java
import kozlov.kirill.main.Main;

// ...

Main.main();
```

Импорт существует 3 типов:
- `import package.name.ClassName` - импорт класса, самый распространённый
- `import package.name.ClassName.staticMethod` - импорт статического метода
- `import package.name.*` - импорт пакета целиком. Используется редко, так как не спасает от конфликта имён и не показывает чётко, что конкретно из пакета мы используем

Импортировать другие файлы в файл того же пакета **НЕ НУЖНО**. Это делается автоматически

Также в каждый файл автоматически импортируется `java.lang.*`, где лежат фундаментальные классы (`String` и т.п.)

Для пакета `package.name`: `package.name` будет подпакетом `package`. `import package.*` **НЕ ИМПОРТИРУЕТ** `package.name`, а только файлы из самой папки `package`.

### Компиляция кода, раскиданного по пакетам
`javac` вызывается со следующими параметрами: `javac -d <destination_folder> <path/to/classes/in/package>/*.java` (*разумеется, вместо `*.java` можно указать конкретные имена классов*). Для подробной информации о компиляции можно добавить `-verbose`

Для компиляции множества файлов из папки `/src` можно прописать следующую команду: `javac -d out/ -sourcepath src/ <path/to/file/with/MainClass.java>`

Для запуска собранных `.class` файлов вызываем `java (-cp | -classpath <out_folder>) package.name.MainClass` - вместо пути до файла с `MainClass` указываем его пакетное расположение

## `equals` и `hashCode`
[Источник](https://javarush.com/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam)

Метод `equals` определён в классе `Object` и наследуется всеми классами. Его базовая реализация просто сравнивает ссылки на инстансы, что часто нас не удовлетворяет. Исправить это можно, переписав метод `equals`, используя декоратор `@Override`:
```java
public class Card {
  private int id;
  private String name;

  // ...

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true; // Проверяем на равенство ссылок, чтобы удовлетворять рефлексивности
    }
    if (obj == null) {
      return false; // Если используются instanceof или getClass(), эта проверка не нужна
    }
    if (!(obj instanceof Card)) {
      return false; // instanceof вернёт true даже если Card - родительский для obj, чтобы получить конкретный класс, можно воспользоваться методом getClass()
    }
    super.equals(o); // Если в родительских классах есть переопределение
    Card otherCard = (Card) obj; // Приводим объект к нужному классу (за счёт проверок выше, тут мы уже уверены, что это возможно сделать)
    // Сравниваем все значимые поля. Примитивные типы сравниваются логическими операторами, ссылочные - их методом equals()
    return this.id == otherCard.id && this.name.equals(otherCard.name); 
  }
}
```

Вместе с `equals` **ВСЕГДА** необходимо переопределять метод `hashCode()`, так как он играет ключевую роль для построения `HashMap` с нашим классов в качестве ключей. Хэш-код для равных объектов (тех, что равны по переопределённому `equals`) должен быть одинаковым. Желательно, чтобы хэш-код для не равных объектов был разным (уменьшит число коллизий)

# 23.09.07 - лекция
## Введение
Языки общего назначения *барабанная дробь* универсальны. Доменно-специфичные используются для каких-то конкретных задач (например, SQL)

Парадигма программирования - совокупность принципов, методов и понятий, определяющих способ конструирования программ. Существует 5 основных парадигм:
1. Императивное программирование - память-состояние и изменяющие его операторы. Самая первая из парадигм, простая для понимания, но громоздкая
2. Структурное программирование - разделение на подпрограммы, основные конструкции: циклы и ветвления
3. Функциональное программирование - описываем конечную цель, а не последовательность действий для её достижения (*привет, Haskell!*). Лёгкое тестирование, отладка, оптимизация, проверка корректности, **НО** не все задачи выполнимы чистыми функциями
4. Логическое программирование - логический вывод на основании заданных парадигм
5. ООП - всё строится вокруг **объекта** (*см. ниже*)

Объект обладает тремя основными типами характеристик (*т.е. объект - нечто, что обладает:*):
1. Состояние - внутренние свойства объекта, определяющие, собственное, состояние объекта и влияющие на его поведение
2. Поведение - как объект взаимодействует с другими объектами
3. Идентификатор - уникален для объектов одного типа

Основные фишки Java - это garbage collector и virtual machine - обе они были и в ООП языках до Java, но ни один из них так не выстрелил

Разделение платформы Java:
- ME - micro-edition - для устройств с ограниченными ресурсами
- SE - standard edition - крепкий середнячок
- EE - enterprise edition - для жоских проектов в жоских конторах

Кроссплатформенность достигается как раз за счёт виртуальной машины

**JIT-компиляция** - динамическая умная компиляция - использует информация о часто повторяющихся участках кода, компилирует код во время его исполнения, что несколько ускорит работу

**AOT-компиляция** - компиляция как в C, то есть очень быстрая, но железозависимая

# 23.09.14 - Лекция
Одна из основных мотиваций для создания объектов - желание создавать грязные функции, имеющие взаимодействие с глобальными данными, но при этом нарезать глобальные данные на отдельные сегменты, сделав их, фактически, уже не глобальными.

*Что появилось раньше: класс или объект?*

**Класс** - способ группирования объектов, схожих по поведению и состоянию.

Часто встаёт вопрос о том, какая степень схожести поведения и состояний объектов является достаточной для включения их в один класс.

*Также объект и класс могут быть определены в обратном порядке, как происходит, например, в языке Java.*

В Java объект:
- Существует определённое время
- Для его создания мы должны знать, каким он должен быть
- Для создания необходимо задать начальное состояние, а после удаления освободить выделенные ресурсы

# 23.09.21 - лекция
## Примитивные типы данных
Примитивные типы отличаются от классов тем, что хранят непосредственно своё значение и при присваивании передаёт непосредственно его значение.

Вторая причина для существования примитивных типов - быстрая трансляция байт-кода при JIT-компиляции.

При этом беззнаковых типов в Java нет. Сделано это было для уменьшения количества примитивных типов и устранения некоторых ошибок, связанных с беззнаковым зацикливанием.

*Немного затирают про то, что такое UTF-кодировка и зачем она появилась*

**В Java все строки зафиксировано хранятся в `UTF-16`. Строка - НЕ примитивный тип.**

**Адресно арифметики в Java нет**

### Классы примитивных типов
Каждый примитивный тип имеет отображение в виде класса. В таком случае мы лишаемся преимуществ в виде быстрой компиляции и компактности, но зато получаем некоторые другие возможности (использовать методы, задавать типы generic-классам).

К счастью, писать везде методы приведения примитивных типов к объектам и наоборот не нужно - компилятор принимает неявное их приведение

## Ключевые слова на Java
- Имена примитивных типов
- Команды управления процессом исполнения (`for`, `if`, `while`, `return` и т.п. - один в один как в Си)
- Модификаторы доступа
  - `private`
  - `protected`
  - `public`
- Управление пакетами ([Что это вообще такое](#пакеты-в-java))
  - `package`
  - `import`
- Обработка исключений
- ООПшные команды (*интересно, почему модификаторы доступа выделили отдельно?..*)
  - `var` - выделим его отдельно, так как он позволяет задать тип переменной, явно его не указывая, если этот тип можно определить по выражению справа (*как в JS, только свободно определяется лишь в начале, потом, ясное дело, не изменен*)
  - `this`
  - `super`
- `enum`
- `void`
- Зарезервированы, но не используются, *лол* - `const`, `goto`
- Зарезервированные константы: `true`, `false`, `null`

