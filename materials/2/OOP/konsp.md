- [Инфо](#инфо)
- [Дополнительные заметки](#дополнительные-заметки)
  - [Пакеты в Java](#пакеты-в-java)
    - [import](#import)
    - [Компиляция кода, раскиданного по пакетам](#компиляция-кода-раскиданного-по-пакетам)
  - [`equals` и `hashCode`](#equals-и-hashcode)
  - [`Iterable<T>`, `Spliterator` и `Stream`](#iterablet-spliterator-и-stream)
- [23.09.07 - лекция](#230907---лекция)
  - [Введение](#введение)
- [23.09.14 - Лекция](#230914---лекция)
- [23.09.21 - лекция](#230921---лекция)
  - [Примитивные типы данных](#примитивные-типы-данных)
    - [Классы примитивных типов](#классы-примитивных-типов)
  - [Ключевые слова на Java](#ключевые-слова-на-java)
- [23.09.28 - лекция](#230928---лекция)
  - [Принципы ООП](#принципы-ооп)
    - [Абстракция](#абстракция)
    - [Инкапсуляция](#инкапсуляция)
    - [Создание связей между классами](#создание-связей-между-классами)
      - [Наследование](#наследование)
  - [Параметризованные типы](#параметризованные-типы)
- [23.10.05 - лекция](#231005---лекция)
- [23.10.12 - лекция](#231012---лекция)
  - [Интерфейсы](#интерфейсы)
  - [Абстрактные классы](#абстрактные-классы)
  - [Как наследоваться](#как-наследоваться)
- [23.10.19 - лекция](#231019---лекция)
  - [Модификаторы полей класса](#модификаторы-полей-класса)
  - [Nested-классы (вложенные)](#nested-классы-вложенные)
  - [Типизация](#типизация)
    - [Duck typing](#duck-typing)
  - [Полиморфизм](#полиморфизм)
    - [Ad hoc полиморфизм](#ad-hoc-полиморфизм)
    - [Параметрический полиморфизм](#параметрический-полиморфизм)
    - [*третий тип*](#третий-тип)


# Инфо
Лектор - Власов Александр Александрович / Шадрина Анастасия Александровна (иногда)

Семинаристка - Быкова Галина Павловна 

[Всё о практике](https://classroom.google.com/u/3/c/Njc3NDc0ODQ3OTFa/p/NjIwOTc0MTA4NDM5?pli=1)

**Для `build.gradle` в качестве DSL использовать `Groovy`**

# Дополнительные заметки
## Пакеты в Java
[Источник](https://habr.com/ru/articles/755654/)

Для использования множества классов с (возможно) пересекающимися именами в Java используются пространства имён, также называемые пакетами. 

Организуются пакеты весьма просто: имя пакета - адрес до файла после папки `src`, то есть файл по адресу `project/src/kozlov/kirill/main/Main.java` будет относиться к пакету `kozlov.kirill.main`. Для указания принадлежности файла к пакету необходимо в начале файла прописать `package kozlov.kirill.main;`. Если этого не указать, сущности из файла **попадут в безымянный пакет**, что крайне не рекомендуется для хоть сколько-нибудь серьёзных проектов.

```java
package kozlov.kirill.main;

public class Main() {
  public static void main(String argv[]) {
    // ...
  }
}
```

### import
К сущностям из безымянного проекта можно обращаться откуда угодно, что создаёт опасность коллизии имён. Для обращения к методу класса из пакета из примера выше мы прописываем в коде полный путь `kozlov.kirill.main.Main.main()`. 

Чтобы не писать каждый раз длинное имя пакета используются импорты:
```java
import kozlov.kirill.main.Main;

// ...

Main.main();
```

Импорт существует 3 типов:
- `import package.name.ClassName` - импорт класса, самый распространённый
- `import package.name.ClassName.staticMethod` - импорт статического метода
- `import package.name.*` - импорт пакета целиком. Используется редко, так как не спасает от конфликта имён и не показывает чётко, что конкретно из пакета мы используем

Импортировать другие файлы в файл того же пакета **НЕ НУЖНО**. Это делается автоматически

Также в каждый файл автоматически импортируется `java.lang.*`, где лежат фундаментальные классы (`String` и т.п.)

Для пакета `package.name`: `package.name` будет подпакетом `package`. `import package.*` **НЕ ИМПОРТИРУЕТ** `package.name`, а только файлы из самой папки `package`.

### Компиляция кода, раскиданного по пакетам
`javac` вызывается со следующими параметрами: `javac -d <destination_folder> <path/to/classes/in/package>/*.java` (*разумеется, вместо `*.java` можно указать конкретные имена классов*). Для подробной информации о компиляции можно добавить `-verbose`

Для компиляции множества файлов из папки `/src` можно прописать следующую команду: `javac -d out/ -sourcepath src/ <path/to/file/with/MainClass.java>`

Для запуска собранных `.class` файлов вызываем `java (-cp | -classpath <out_folder>) package.name.MainClass` - вместо пути до файла с `MainClass` указываем его пакетное расположение

## `equals` и `hashCode`
[Источник](https://javarush.com/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam)

Метод `equals` определён в классе `Object` и наследуется всеми классами. Его базовая реализация просто сравнивает ссылки на инстансы, что часто нас не удовлетворяет. Исправить это можно, переписав метод `equals`, используя декоратор `@Override`:
```java
public class Card {
  private int id;
  private String name;

  // ...

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true; // Проверяем на равенство ссылок, чтобы удовлетворять рефлексивности
    }
    if (obj == null) {
      return false; // Если используются instanceof или getClass(), эта проверка не нужна
    }
    if (!(obj instanceof Card)) {
      return false; // instanceof вернёт true даже если Card - родительский для obj, чтобы получить конкретный класс, можно воспользоваться методом getClass()
    }
    if (!super.equals(o))
      return false; // Если в родительских классах есть переопределение
    Card otherCard = (Card) obj; // Приводим объект к нужному классу (за счёт проверок выше, тут мы уже уверены, что это возможно сделать)
    // Сравниваем все значимые поля. Примитивные типы сравниваются логическими операторами, ссылочные - их методом equals()
    return this.id == otherCard.id && this.name.equals(otherCard.name); 
  }
}
```

Вместе с `equals` **ВСЕГДА** необходимо переопределять метод `hashCode()`, так как он играет ключевую роль для построения `HashMap` с нашим классов в качестве ключей. Хэш-код для равных объектов (тех, что равны по переопределённому `equals`) должен быть одинаковым. Желательно, чтобы хэш-код для не равных объектов был разным (уменьшит число коллизий)

## `Iterable<T>`, `Spliterator` и `Stream`
Stream API позволяет нам удобно работать с итерируемыми объектами, то есть в первую очередь коллекциями. [Статья о методах](https://javarush.com/groups/posts/2203-stream-api)

Любая структура, реализующая интерфейс `Iterable<T>`, будет иметь дэфолтную реализацию сплиттератора, которую можно использовать для создания потока:
```java
var split = new BfsTreeCollection<>(root).spliterator();
var l = StreamSupport.stream(split, false).filter(x -> x < 5).toList();
System.out.println(l);
```

# 23.09.07 - лекция
## Введение
Языки общего назначения *барабанная дробь* универсальны. Доменно-специфичные используются для каких-то конкретных задач (например, SQL)

Парадигма программирования - совокупность принципов, методов и понятий, определяющих способ конструирования программ. Существует 5 основных парадигм:
1. Императивное программирование - память-состояние и изменяющие его операторы. Самая первая из парадигм, простая для понимания, но громоздкая
2. Структурное программирование - разделение на подпрограммы, основные конструкции: циклы и ветвления
3. Функциональное программирование - описываем конечную цель, а не последовательность действий для её достижения (*привет, Haskell!*). Лёгкое тестирование, отладка, оптимизация, проверка корректности, **НО** не все задачи выполнимы чистыми функциями
4. Логическое программирование - логический вывод на основании заданных парадигм
5. ООП - всё строится вокруг **объекта** (*см. ниже*)

Объект обладает тремя основными типами характеристик (*т.е. объект - нечто, что обладает:*):
1. Состояние - внутренние свойства объекта, определяющие, собственное, состояние объекта и влияющие на его поведение
2. Поведение - как объект взаимодействует с другими объектами
3. Идентификатор - уникален для объектов одного типа

Основные фишки Java - это garbage collector и virtual machine - обе они были и в ООП языках до Java, но ни один из них так не выстрелил

Разделение платформы Java:
- ME - micro-edition - для устройств с ограниченными ресурсами
- SE - standard edition - крепкий середнячок
- EE - enterprise edition - для жоских проектов в жоских конторах

Кроссплатформенность достигается как раз за счёт виртуальной машины

**JIT-компиляция** - динамическая умная компиляция - использует информация о часто повторяющихся участках кода, компилирует код во время его исполнения, что несколько ускорит работу

**AOT-компиляция** - компиляция как в C, то есть очень быстрая, но железозависимая

# 23.09.14 - Лекция
Одна из основных мотиваций для создания объектов - желание создавать грязные функции, имеющие взаимодействие с глобальными данными, но при этом нарезать глобальные данные на отдельные сегменты, сделав их, фактически, уже не глобальными.

*Что появилось раньше: класс или объект?*

**Класс** - способ группирования объектов, схожих по поведению и состоянию.

Часто встаёт вопрос о том, какая степень схожести поведения и состояний объектов является достаточной для включения их в один класс.

*Также объект и класс могут быть определены в обратном порядке, как происходит, например, в языке Java.*

В Java объект:
- Существует определённое время
- Для его создания мы должны знать, каким он должен быть
- Для создания необходимо задать начальное состояние, а после удаления освободить выделенные ресурсы

# 23.09.21 - лекция
## Примитивные типы данных
Примитивные типы отличаются от классов тем, что хранят непосредственно своё значение и при присваивании передаёт непосредственно его значение.

Вторая причина для существования примитивных типов - быстрая трансляция байт-кода при JIT-компиляции.

При этом беззнаковых типов в Java нет. Сделано это было для уменьшения количества примитивных типов и устранения некоторых ошибок, связанных с беззнаковым зацикливанием.

*Немного затирают про то, что такое UTF-кодировка и зачем она появилась*

**В Java все строки зафиксировано хранятся в `UTF-16`. Строка - НЕ примитивный тип.**

**Адресно арифметики в Java нет**

### Классы примитивных типов
Каждый примитивный тип имеет отображение в виде класса. В таком случае мы лишаемся преимуществ в виде быстрой компиляции и компактности, но зато получаем некоторые другие возможности (использовать методы, задавать типы generic-классам).

К счастью, писать везде методы приведения примитивных типов к объектам и наоборот не нужно - компилятор принимает неявное их приведение

## Ключевые слова на Java
- Имена примитивных типов
- Команды управления процессом исполнения (`for`, `if`, `while`, `return` и т.п. - один в один как в Си)
- Модификаторы доступа
  - `private`
  - `protected`
  - `public`
- Управление пакетами ([Что это вообще такое](#пакеты-в-java))
  - `package`
  - `import`
- Обработка исключений
- ООПшные команды (*интересно, почему модификаторы доступа выделили отдельно?..*)
  - `var` - выделим его отдельно, так как он позволяет задать тип переменной, явно его не указывая, если этот тип можно определить по выражению справа (*как в JS, только свободно определяется лишь в начале, потом, ясное дело, не изменен*)
  - `this`
  - `super`
- `enum`
- `void`
- Зарезервированы, но не используются, *лол* - `const`, `goto`
- Зарезервированные константы: `true`, `false`, `null`

# 23.09.28 - лекция
*Забавно, но иногда в методах классов можно опускать `this` - компилятор сам его подставит*

Оператор `new ClassName()` создаёт объект на хипе и возвращает ссылку, которая будет указывать на этот объект и храниться уже в стэке.

**Контракт класса** - будущее поведение объекта класса.

## Принципы ООП
Обязательны принципы для ООП:
 - Абстракция
 - Инкапсуляция
 - Наследование
 - Полиморфизм

Дополнительные принципы:
- Типизация
- Параллелизм
- Сохраняемость

### Абстракция
Абстракция выделяет существенные характеристики объекта и чётко определяет его концептуальные границы с точки зрения наблюдателя.

Наличие наблюдателя в этом определении очень важно, так как без него мы не сможем выделить ключевые для нас свойства

### Инкапсуляция
Процесс отделения друг от друга элементов объекта, которые определяют его устройство и поведение. Инкапсуляция служит для того, чтобы изолировать контрактные обязательства абстракции от их реализации.

Инкапсуляция не сводится только лишь к модификаторам прав доступа `private`, `public`, package-private, `protected` - ещё есть интерфейсы (`interface`) и абстрактные классы (`abstract`).

Подробнее о модификаторах прав доступа:
- `private` - доступно только внутри класса
- `public` - доступно извне
- `protected` - видимость в пакете и подклассах (см. [наследование](#наследование))
- package-private - задаётся по умолчанию - доступно везде в рамках пакета

В одном файле может быть **только один публичный класс**.

### Создание связей между классами
**Ассоциация** - любое отношение между объектами (*велик - владелец, препод - часы и т.п.*)

**Зависимость** - вроде, тут всё итак ясно

**Агрегация** - часть относится к целому (*велик - колесо: колесо отделимо от велика*)

**Композиция** - часть относится к целому и учитывает время жизни (*велик - рама: рама может жить только вместе с великом*)

#### Наследование
Наследование создают такую иерархию абстракций, в которой подклассы заимствуют строение и функциональность от одного или нескольких суперклассов.

**Иерархия** - упорядочение абстракций путём разложения их по уровням.

```java
class SubClass extends SuperClass {
  // your code here
}
```

**Привидение типа upcast** - приводим тип подкласса к его суперклассу. Тут всё безопасно и нормально. При вызове методов, существующих в суперклассе и переопределённых в подклассе, будет вызван переопределённый метод, так как мы просто поменяли тип ссылки.

**Приведение типа downcast** - приводим тип суперкласса к типу подкласса. Необходимо указывать тип явно. Опасно и часто вызывает `ClassCastException`.

**Все типы в Java наследуются от `java.util.Object`**

Про `equals` и `hashCode` писал [тут](#equals-и-hashcode)

**Альтернативное определение наследование (принцип подстановки Барбары Лисков)** - реализовывать наследование надо так, чтобы в случае подстановки подкласса на место суперкласс (upcast) контракты не нарушались.

**Ещё раз принцип, но более академично:**
- Функции, использующие базовый тип, должны иметь возможность использовать его подтипы, не зная об этом (то есть чтобы для них работал upcast приведение типа)
- Наследующий класс дополнять, а не замещать поведение базового класс

<hr>

Из всего этого можно заключить, что наследование - **очень сильная связь** - поэтому желательно прибегать к нему лишь в крайних случаях. **Рекомендуется использовать композицию**

## Параметризованные типы
Можно использовать поля типа `Object`, чтобы хранить в них любые ссылочные типы, но тогда мы никак не можем поставить ограничения на записываемые в поля данные, из-за чего лишаемся строгой типизации и можем словить Runtime Error при ошибочном downcast приведении типа.

Поэтому используется другой принцип. Мы указываем, что класс будет работать с одним и тем же произвольным типом `T` (*название не строгое, а просто каноническое*). Может быть несколько параметризованных типов

*Фан-факт:* на самом деле при компиляции все записи параметризованного типа заменяются на `Object`, то есть мы возвращаемся к первой версии, но обходим проблему незаметных при написании кода ошибок.

```java
// Добавлю экзампл, когда решу третью лабу
```

Можно задать границы типовых параметров (bounds). Верхняя граница задаётся за счёт записи `<T extends UpperClass>` - мы можем указать в качестве параметра только класс `UpperClass` или его подклассы. (После компиляции вместо `Object` будет подставляться `UpperClass`, то есть тем самым мы ограничим upcast)

**Generic-классы** - классы с параметрическими типами данных

# 23.10.05 - лекция
*Больше половины лекции дрючил нас на предмет того, внимательно ли мы слушали лекцию Иртегова вчершанюю*

*Вторую половину пересказывал лекцию Шадриной*

**Контракт включает в себя**:
- набор операций
- параметры операций и нго допустимые значения, интерпретация параметров
- допустимые возвращаемые значения и их интерпретация
- сообщения об ошибках
- предусловия
- постусловия
- инварианты
- побочные эффекты

Алгоритм спецификации:
1. Назвать абстракцию и описать, что она должна делать
2. Для каждой определённой операции написать её спецификацию по пунктам выше 

# 23.10.12 - лекция
## Интерфейсы
*Наверное тут было определение интерфейса или что-то подобное*

Интерфейсы определяют общее поведение объектов (контракт), которое обязательно должно быть.

```java
interface Animal {
  void eat();
  void sayHi();
}
```

Есть 2 способа реализации нескольких интерфейсов в одном объекте:
- После `implements` пишутся несколько интерфейсов.
- Интерфейс может расширять другой интерфейс при помощи `extends`, что корректнее всего называть расширением, а не наследованием.

Второй метод предпочтительнее, так как при первом может возникнуть конфликт контрактов.

Также мы можем создать массив интерфейсов за счёт того, что интерфейс не содержит никакого конструктора. (то же относится и к списку, то есть любой ссылочный тип, которому не нужно тут же инициализировать объекты заданного параметра)

В интерфейсе нельзя задать поля, но можно константы (`final`) или статические (`static`) атрибуты.

Очень часто реализации интерфейсов в разных классах очень похожи, из-за чего мы будем дублировать много кода.

## Абстрактные классы
Абстрактный класс представляет собой нечто среднее между классом и интерфейсом. У методов абстрактного класса также нет реализацией, поэтому мы не можем инициализировать объекты этого класса, однако в абстрактном классе можно задать поля и реализовать часть методов. Абстрактные методы обозначаются словом `abstract`:
```java
public abstract class Animal {
  int health = 100;

  void eat() {
    health += 5;
  }

  abstract void sayHi();
}
```

Очевидно, абстрактные классы могут наследоваться (`extends`), но не имплементироваться (`implements`).

В классах можно использовать **любые модификаторы доступа**, а не **только `public`, как в интерфейсах**.

## Как наследоваться
Если вам хочется сделать множественное наследование, вам не хочется его сделать

# 23.10.19 - лекция
## Модификаторы полей класса
- `final` - константа. Будучи однажды заданной, больше не может быть изменена. Относится к изменениям значений, то есть мы можем изменять содержимое ссылочного типа, но не ссылку на него
- `static` - поле становится полем класса, а не объекта. Для всех объектов и класса будет иметь одно и то же значение. Статические объекты могут иметь доступ только к статическим полям
  - СТАТИЧЕСКИЙ КОНСТРУКТОР вызывает единожды в момент загрузки класса и позволяет инициализировать статические поля класса. Записывается как `static { /*code*/ }`

## Nested-классы (вложенные)
Можно объявить класс внутри класса. Будет иметь возможность обращаться к полям внешнего класса, что порой оказывается ооочень удобно.

`static`-nested класс, что логично, не будет иметь возможности обращаться к полям внешнего класса.

**Анонимные классы** используются, когда мы хотим использовать функционал класса лишь в одном месте:
```java
var value = new SuperClass() { // Если не указать SuperClass, будем наследоваться от Object
  // Code for class
}
```
Собственных конструкторов у анонимных классов нет, но они могут использовать конструкторы классов-родителей (*а ещё мы можем, по идее, просто через замыкание работать с какими-то данными, но это надо ещё проверять*). Подробнее об анонимных классах [тут](https://javarush.com/groups/posts/2193-anonimnihe-klassih)

Nested-интерфейсы тоже существуют, хотя и используются не часто. Позволяют обозначить, что для внешнего интерфейса обязательна также реализация внутреннего интерфейса.

## Типизация
В Java доступна как статическая, так и динамическая типизация.

Языки со слабой типизацией могут преобразовать дробные числа в целые неявно и т.п. Сильная типизация не позволяет так делать.

### Duck typing
Если что-то крякает и летает, оно является уткой. Говоря более формально, типы объектов определяются их поведением

## Полиморфизм
### Ad hoc полиморфизм
Заключается в перегрузке функций.

### Параметрический полиморфизм
Основывается на generic'ах и наследовании.

### *третий тип*