- [Примечание](#примечание)
- [Личная коллекция алгоритмов](#личная-коллекция-алгоритмов)
- [22.09.03 - лекция](#220903---лекция)
- [22.09.10 - лекция](#220910---лекция)
- [22.09.14 - семинар](#220914---семинар)
- [22.09.17 - лекция](#220917---лекция)
  - [Сложность программы](#сложность-программы)
  - [Инструменты для проверки эффективности](#инструменты-для-проверки-эффективности)
- [22.09.21 - семинар](#220921---семинар)
- [22.09.24 - лекция](#220924---лекция)
  - [Работа со строками](#работа-со-строками)
- [22.10.01 - лекция](#221001---лекция)
  - [Структура](#структура)
  - [Применение const](#применение-const)
  - [Мемоизация](#мемоизация)
- [22.10.05 - семинар](#221005---семинар)
  - [define-"функция"](#define-функция)
  - [Решето эратосфена](#решето-эратосфена)
- [22.10.08 - лекция](#221008---лекция)
  - [Динамическая память](#динамическая-память)
    - [Пример просто объявления динамического массива интов](#пример-просто-объявления-динамического-массива-интов)
  - [Массивы vs связыне списки](#массивы-vs-связыне-списки)
    - [Реализация списка](#реализация-списка)
- [22.10.15 - лекция](#221015---лекция)
  - [Препроцессор](#препроцессор)
  - [Почти что шаблоны типов](#почти-что-шаблоны-типов)
  - [Условный define](#условный-define)
- [22.10.22 - лекция](#221022---лекция)
  - [Битовые операции](#битовые-операции)
  - [Сортировки](#сортировки)
    - [Сортировка вставками](#сортировка-вставками)
  - [Бинарный поиск](#бинарный-поиск)
- [22.10.29 - лекция](#221029---лекция)
  - [Бинарное чтение/запись файлов](#бинарное-чтениезапись-файлов)
- [22.11.05 - лекция](#221105---лекция)
- [22.11.12 - лекция](#221112---лекция)
  - [Сортировка слиянием](#сортировка-слиянием)
  - [Быстрая сортировка](#быстрая-сортировка)
- [22.11.19 - лекция](#221119---лекция)
  - [Динамический массив](#динамический-массив)
  - [Стэк](#стэк)
    - [Реализация на массиве](#реализация-на-массиве)
    - [Реализация на списке](#реализация-на-списке)
  - [Очередь](#очередь)
    - [Реализация на массиве](#реализация-на-массиве-1)

# Примечание
Лектор - Стененко Александр Александрович

[Система тестирования](https://fresh.nsuts.ru)


# Личная коллекция алгоритмов
- [Бинарный поиск](#бинарный-поиск)
- [Сортировка слиянием](#сортировка-слиянием)
- [Быстрая сортировка](#быстрая-сортировка)

# 22.09.03 - лекция
Для перевода двоичного числа по битам, необходимо инвертировать биты и прибавить 1

Стэк - область памяти, выделенная под исполнение программы. Стэк не очень большой.

Стэковй фрейм - область стэка, хранящая локальные переменные области видимости. При завершении исполнения этой области, содержимое стэкового фрейма уничтожается.

Heap (куча) - вся остальная память, к которой можно обращаться по указателям.

# 22.09.10 - лекция
Можно использовать `goto` вместо множественных `break`. 

Также можно использовать для обработки ошибок, т.к. в C нет исключений.

В иных случаях использовать `goto` не рекомендуется.

# 22.09.14 - семинар
Для использования дополнительных символов используется `unsigned char`. При обычном `char` числовое представление идёт от -128 до 127, при этом символы соответствуют только числам от 0 до 127.

# 22.09.17 - лекция
Массив - это на саомом деле указатель но последовательность ячеек памаяти.

Запись `a[2]` и `*[a+2]` эквивалентны.


## Сложность программы
t(n) - время исполнения программы

Асимптотика: f(x) = O(g(x)) - существует такое x1 > 0 и c > 0, что для любого x > x1 f(x) <= c*g(x)

## Инструменты для проверки эффективности
Библиотека `assert.h` позволяет вызывать функцию `assert(<expr>)`. Если выражение в функции даёт ложь, программа прерывается и выдаёт ошибку. Фактически, реализует отлов исключений, но без возможности выбирать код ошибки и помещать внутрь кусок кода

---
# 22.09.21 - семинар
`#define NAME <value>` - присваивает лэйблу `NAME` константное значение.

---
# 22.09.24 - лекция
## Работа со строками
```C
strcmp(char* a, char* b); // Сравнивает строки a и b. Возвращает -1, если a < b, 0 <=> a == b, 1 <=> a > b 
strcpy(char* dst, char* src); // Коирует строку по адресу src на адрес dst
strlen(char* s) // Возвращает длину строки
strcat
```

# 22.10.01 - лекция
## Структура
Структура - собственные типы данных, содержащие логически связанные поля
```c
struct PointStruct {
  int x, y, z;
}; // Самый простой вариант объявления структуры

// Объявление переменной с типом структуры
struct PointStruct p;
p.x = 1;
p.y = 2;

// Чтобы не писать каждый раз struct, можно использовать typedef
typedef struct PointStruct {
  int x, y, z;
} Point;
// Либо
typedef struct {
  int x, y, z;
} Point;
// В таком случае объявление переменной будет выглядеть так:
Point p;

// При инициализации можно задавать значения в {} для всех полей подряд, либо указывать поля в виде .field
Point p1 = {1, 2, 3} // p1.x = 1, p1.y = 2, p1.z = 3
Point p2 = {.y = 2} // p2.x = 0, p2.y = 2, p2.z = 0
```

## Применение const
`const` перед указателем запрещает изменение данных по этому указателю. Удобно, чтобы не копировать "тяжёлые" структуры, причём:
```c
const type * p1; // Нельзя менять значение по указателю, но можно передвинуть указатель
type * const p2; // Можно изменять значение по указателю, но нельзя передвигать указатель
const type * const p3 = ... // Нельзя изменять ни указатель ни значение по нему. Поэтому требуется сразу задать значение
```

## Мемоизация
Для сложных алгоритмов полезно просчитать некоторое количество значений заранее.

Например, вместо рекурсии вычислить числа фибоначчи сразу до n-го, используя массив:
```c
int fib[SIZE] = {};
int n; // Вводим сами
fib[0] = 1
fib[1] = 1
for (int i = 2; i < n; ++i)
  fib[i] = fib[i-1] + fib[i-2];
```
В таком случае алгоритм будет работать гораздо быстрее. Асимптотика `O(n)`

# 22.10.05 - семинар
## define-"функция"
```c
#define ABS(a) ((a) > 0 ? (a) : -(a)) // подставит на место ABS(n) наше выржение с n на месте a
```

## Решето эратосфена
$$
gcd(a, b) = \begin{cases}
  a, b = 0\\
  b, a = 0\\
  gcd(b, a \% b)
\end{cases}
$$

# 22.10.08 - лекция
## Динамическая память
Переменные, объявленный в какой-то из функций, хранятся в стэке и уничтожаются при завершении её исполнения.

Переменные, объявленные в глобальной области либо в функциях с префиксом `static`, хранятся в статической части, их срок жизни не зависит от завершения функций.

`heap` - очень большая область в опреативной памяти, к которой осуществляется доступ по указателю. Называется также динамической памятью.

`malloc(size)` - выделяет в динамической памяти `size` байт и возвращает указатель типа `void*`, поэтому для работы с линамическими массивами конкретного типа необходимо провести явное приведение типа. Если возвращается `NULL`, значит выделить память не удалось.

`calloc(len, size)` - выделяет в памяти `len * size` байт и зануляет их. В остальном действие аналогично `malloc()`

Указатели на динамическую память могут быть возвращены из функции, то есть, фактически, функция будет возвращать массив.

**После работы с динамической памятью, её необходимо очистить с использованием функции `free(ptr)`**

### Пример просто объявления динамического массива интов
```c
int* arr1 = (int*)malloc((sizeof int) * count);
int* arr2 = (int*)calloc(count, sizeof int);
// ...
// Работаем с массивом
// ...
free(arr);
```

## Массивы vs связыне списки
Массив - область в памяти, идущая подряд. Обращение по индексу происходит за `O(1)`

Спсико - раздельные ячейки в памяти, каждая из которых хранит адрес ледующей ячейки списка. Список двусвязный - каждая ячейка хранит адрес как предыдущей, так и следующей ячеек. Асимптотика обращения - `O(n)`
 
Однако, вставка элемента в массив происходит за `O(n)`, тогда как в списке, если мы уже имеет указатель на ячейку, перед/после которой мы хотим вставить элемент, эта операция зыймёт `O(1)`. Такая же ситуация и с удалением

### Реализация списка
Основой для списка будет структура, хранящая зачение и указатель. Ячейки списка могут храниться в массиве либо можно напрямую записывать указатели с использованием `malloc()`

# 22.10.15 - лекция
## Препроцессор
Перед компиляцией вызывается процесс предобработки. Самое наглядное использование было [тут](#define-функция)

Сложные `define`-ы лучше всего писать в скобках, так как действия из него подставляются как есть:
```c
#define SUM(a, b) a + b
int x;
x = SUM(2, 2) * 2 // Получим 2 + 2 * 2 = 6, хотя скорее всего ожидался повышенный приоритет у суммы
#define SUM(a, b) (a + b) // С такой версией сработает корректно
```

## Почти что шаблоны типов
Чтобы написать `define` для многострочных скрпитов в конце каждой строки надо указывать `\`:
```c
#define ARR_TEMPLATE(T) \
  typedef struct T##Arr { \ // ## позволяет склеивать аргумент T с другими командами, что позволит дать структурам разных типов разные имена
    T *values; \
    int length; \
  } T_##Arr\

ARR_TEMPLATE(int); // Определяет структуру для массива int'ов
ARR_TEMPLATE(double); // Определяет структуру для массива double'ов

int_arr arrInt;
double_arr doubleArr;
```

[!NOTE]
Test

## Условный define
```c
#define DEBUG // Если будет эта строчка, то код внутри #ifdef ... #endif скомпилируется
// вместо дейфана в файле можно сделать его при компилировании кода с флажком

int lupa() {
  // ...
  #ifdef DEBUG // может быть любое имя
    // printf или что-то иное, что нужно нам для отладки, но не должно попасть в релизную версию
  #endif
  // ...
}
```

# 22.10.22 - лекция
## Битовые операции
При сдвиге знакового числа вправо, слева добавляются единицы.

Главный элемент для работы с побитовыми операциями - маски. Вот несолько базовых способов их конструирования.
```c
typedef unsigned long long ULL;
ULL index;
ULL mask1 = 1 << index; // Единица на позиции index
ULL mask2 = ~(mask1); // Нуль на позиции index, все остальные биты - единицы
ULL mask3 = mask1 - 1; // Все биты на позициях < index - единицы
ULL mask4 = mask3 << (sizeof(ULL) - index); // Все биты до index, считая справа - единицы
```

## Сортировки
### Сортировка вставками
Идём со второго элемента, и проверяем каждый `i`: на какую позицию `j` слева его нужно вставить, сдвигаем элементы `[j, i)` на 1 позицию вправо и вставляем `i`-ый на `j`-ю позциию

![insertion sort](https://miro.medium.com/max/1102/1*krA0OFxEDgi8hVHJffCi4w.gif)


## Бинарный поиск
```c
// Ищет последнее вхождение elem в массив arr в диапазаоне [l, r). Если вхождения нет, возвращает -1 
int binSearch(const int *arr, int elem, int l, int r) {
    int mid, midVal, len = r;
    --r;
    while (l <= r) {
        mid = (l + r) / 2;
        midVal = arr[mid];
        if (elem < midVal)
            r = mid - 1;
        else if (elem > midVal)
            l = mid + 1;
        else {
            if (mid+1 == len || arr[mid+1] != elem)
                return mid;
            else
                l = mid + 1;
        }
    }
    return -1;
}
```
![Binary search](https://blog.penjee.com/wp-content/uploads/2015/04/binary-and-linear-search-animations.gif)

# 22.10.29 - лекция
Выделенная под структуру область памяти доводится до значения, кратного наибольшему типы данных в ней:
```c
#include <stdio.h>

struct Boba {
    double l;
    char chrs[9];
};

int main() {
    printf("%d", sizeof(struct Boba)); // 24
    return 0;
}
```
Если мы хотм сэкономить память, то можно прописать в начале файла особую директиву компилятора
```c
#include <stdio.h>

#pragma pack(push, 1)

struct Biba {
    double l;
    char chrs[9];
};

struct Boba {
    double l;
    char chrs[9];
};

int main() {
    printf("%d", sizeof(struct Boba)); // 17
    return 0;
}
```
Функция `offsetof(struct, member)` из библиотеки `stddef.h` возвращает расстояние в байтах от начала структуры до её поля. Будет удобно в таком кейсе:
```c
#include <stdio.h>
#include "stddef.h"

typedef struct Biba {
    int field1;
    int field2;
} Boba;

int main() {
    Boba data = {10, 5};
    ////////////////////////////////////////////////////////////////////////////////
    int* field2Ptr = &data.field2;
    Boba *dataPtr = (Boba*)(field2Ptr - offsetof(Boba, field2) / sizeof(int));
    // либо
    char* field2Ptr = (char*)&data.field2;
    Boba *dataPtr = (Boba*)(field2Ptr - offsetof(Boba, field2));
    // второй вариант предпочтительнее, так как не до конца ясно, всегда либо будет корректно делиться сдвиг на sizeof
    ////////////////////////////////////////////////////////////////////////////////
    printf("%d\n", dataPtr->field1); // 10
    // не очень очевидно, но фактически мы можем сохранять указатели лишь на отдельные поля структуры и при их помощи получать адреса целых структур
    return 0;
}
```

Такт в процессоре - перекладывание значения из одного регистра в другой

## Бинарное чтение/запись файлов
Символ `\n` в файлах обозначет конец строки в UNIX-системах.

В Винде конец строки обозначается двумя символоами - `\r\n`

Если для чтения/записи вместо `"r"`/`"w"` указать `"rt"`/`"wt"`, то при чтении перенос каретки будет убираться, а при записи - добавляться.

При простом указании `"r"`/`"w"`, режимы автоматически устанавливаются в бинарные: `"rb"`/`"wb"`

Буфер хранит изменения в файлах до момента своего переполнения, потом сбрасывает их в файл. Принудительно сбросить буфер можно при помощи `fflush(FILE *)`

Ещё некоторые функции для работы с файлами
- `feof(FILE *f)` - проверяет, закончился ли бинарный файл
- `fputc(int c, FILE *f)` - записывает символ
- `fgetc(FILE *f)` - получает символ
- `fputs(const char* str, FILE *f)` - запись строки. **Не добавляет переноса строки**
- `fgets(char *str, int n, FILE *f)` - считывает строку в `str` либо до переноса, либо до конца строки, либо `n` символов. **Считывает вместе с переносом строки**
- `remove(const char *file_name)`
- `fseek(FILE f*, int offset, int access)` - сдвигает указатель в бинарном файле на `offset`. Начальная позиция зависит от `access`:
  - `0` - начало файла
  - `1` - текущее положение
  - `2` - конец файла
- `rewind(FILE *f)` - начать чтение файла заново
- `ftell(FILE *f)` - возвращает текущую позицию в файле
- `fread/fwrite(void *buffer, unsigned size, unsigned n, FILE *f)` - чтение/запись бинарных данных в буфер `buffer` из потока файла `f`

# 22.11.05 - лекция
`static type <var_name>` внутри функций не доступен снаружи, но сохраняется между вызовами функций

# 22.11.12 - лекция
## Сортировка слиянием
**Суть:** делим массив рекурсивно пополам и сливаем половинки в порядке неубывания элементов
```c
#include <stdio.h>
#include "malloc.h"
#include "string.h"

int* merge(int *arr, int l, int mid, int r) {
    int lLen = mid - l + 1, rLen = r - mid, iL = 0, iR = 0, i = 0;
    int *left = (int*) calloc(lLen, sizeof(int)),
        *right = (int*) calloc(rLen, sizeof(int));
    arr = arr + l;
    memmove(left, arr, lLen * sizeof(int));
    memmove(right, arr + lLen, rLen * sizeof(int));
    while (iL < lLen && iR < rLen)
        if (left[iL] < right[iR])
            arr[i++] = left[iL++];
        else
            arr[i++] = right[iR++];
    while (iL < lLen)
        arr[i++] = left[iL++];
    while (iR < rLen)
        arr[i++] = right[iR++];
    free(left);
    free(right);
    return arr;
}

void mergeSort(int* arr, int l, int r) {
    if (l < r) {
        int mid = l + (r - l) / 2;
        mergeSort(arr, l, mid);
        mergeSort(arr, mid+1, r);
        merge(arr, l, mid, r);
    }
}
```

## Быстрая сортировка
```c
void quickSort(int A[], int L, int R) {
    if (R - L <= 1) return;
    int mid = A[L + rand() % (R - L)];
    int x = L, y = L;
    for (int i = L; i < R; ++i) {
        if (A[i] < mid) {
            swap(A[x], A[i]);
            if (x != y) swap(A[y], A[i]);
            ++x;
            ++y;
        } else if (A[i] == mid) {
            swap(A[y], A[i]);
            ++y;
        }
    }
    quicksort(A, L, x);
    quicksort(A, y, R);
}
```

# 22.11.19 - лекция
## Динамический массив
Базовая концепция очень проста: выделяем память под массив нового размера, переписываем данные из старого, записываем новые данные, очищаем память из под старого массива.

Интересный момент 1 - функция `realloc(ptr, newByteSize)` из `stdlib.h`, которая проводит расширение памяти по возможности на том же месте, без полного переопределения.

Интересный момент 2 - выделять некоторое количество памяти заранее, а не под каждое добавление, потом просто записывать данные по необходимости в пустые ячейки. Такой подход сэкономит много времени. Оптимальнее всего увеличивать длину в 1,5-2 раза от текущей (то есть экспоненциально). В таком случае структура динамического массива будет такой:
```c
#include <stdlib.h>

typedef struct Vector_s {
  int *arr;
  int cnt; // Сколько элементов занято фактически
  int len; // Сколько общая длина массива
} Vector;

void push(Vector *vec, int newVal) {
  if (vec->cnt == vec->len)
    vec->arr = realloc(vec->arr, vec->len * 2);
  vec->arr[vec->cnt++] = newVal;
}
```

## Стэк
**Суть:** мы имеем доступ только к последнему добавленному элементу (*LIFO: Last in, first out*).

### Реализация на массиве
```c
#include "malloc.h"

typedef struct ArrStack_s {
    int *arr;
    int size;
    int freeIndex;
} ArrStack;

ArrStack *create(int n) {
    ArrStack *newStack = (ArrStack *) malloc(sizeof(ArrStack));
    newStack->arr = (int *) calloc(n, sizeof(int));
    newStack->size = n;
    newStack->freeIndex = 0;
    return newStack;
}

int isEmpty(const ArrStack *stack) {
    return stack->freeIndex == 0 ? 1 : 0;
}

int top(const ArrStack *stack) {
    if (isEmpty(stack))
        return -1; // Несуществующий элемента
    return stack->arr[stack->freeIndex-1];
}

int pop(ArrStack *stack) {
    if (isEmpty(stack))
        return -1; // Несуществующий элемента
    return stack->arr[--stack->freeIndex];
}

void push(ArrStack *stack, int val) {
    if (stack->freeIndex == stack->size) {
        stack->arr = realloc(stack->arr, sizeof(int) * stack->size * 2);
        stack->size *= 2;
    }
    stack->arr[stack->freeIndex++] = val;
}
```

### Реализация на списке
```c
#include "malloc.h"

typedef struct ListElem_s {
  struct ListElem_s *next;
  int val;
} ListElem;

typedef struct List_s {
  ListElem *head;
} List;

/*
Тут у нас идут функции для работы со списками
*/

typedef struct ListStack_s {
    List *list;
} ListStack;

ArrStack *create(int n) {
    ListStack *newStack = (ListStack *) malloc(sizeof(ListStack));
    initList(newStack->list);
    return newStack;
}

int isEmpty(const ArrStack *stack) {
    return stack->list->head->next == NULL ? 1 : 0;
}

int top(const ArrStack *stack) {
    if (isEmpty(stack))
        return -1; // Несуществующий элемента
    return stack->list->head->next.val;
}

int pop(ArrStack *stack) {
    if (isEmpty(stack))
        return -1; // Несуществующий элемента
    return erase(stack->list->head->next);
}

void push(ArrStack *stack, int val) {
  addAfter(stack->list->head, val);
}
```

## Очередь
**Суть:** добавление элемента в конец, а обращение к началу (*FIFO: first in, first out*)

### Реализация на массиве
Многое похоже на стэк, так что просто отмечу важный момент: при извлечении элемента из начала лучше просто двигать вправо индекс начала, а не удалять полностью этот элемент. При этом в какой-то момент массив можно закольцевать (индекс конца будет впереди индекса начала)