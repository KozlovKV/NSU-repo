============ Использование реальных библиотек ==============

В C/C++ довольно сложно использовать библиотеки из-за различий платформ, компиляторов, настроек и т.п.
Поэтому иногда используется простой подход "встраивания" всего кода библиотеки в свой проект.
Вместо того, чтобы качать или собирать отдельно статическую/динамическую библиотеку, исходный код собирается как часть проекта.
Не всякая библиотека это позволяет: она должна быть написана с прицелом на такое испольвание.

Встраивание в простейшем варианте --- это использование header-only библиотек.
header-only библиотека распространяется в виде одного хедера с полным исходным кодом библиотеке.
Чтобы её подключить, достаточно добавить #include.

header-only библиотеки бывают:
 * Плохие: хедер подключается одинаково во все TU, а значит код библиотека компилируется заново в каждой TU.
 * Хорошие: ровно в одной TU нужно подключить хедер, предварительно объявив некоторый макрос.
            Когда он объявлен, в хедере включены определения функция, а когда нет --- только объявления.
            Благодаря этому код библиотеки компилируется только в одной TU.

Примеры header-only библиотек:
    https://github.com/nothings/single_file_libs
    https://github.com/nothings/stb


======================== inline ============================

inlining --- оптимизация программ, в том числе на C.
Она заключается в том, вместо вызова функции вставляется весь её код.


Инлайнинг функций не важен сам по себе, но часто открывает дорогу другим оптимизациям.
Потому что оптимизаторы обычно работают в пределах одной функции.
Пример:
  int sqr(int x) { return x*x; }
  ...
  struct Info *my;
  my->res = 0;
  for (int i = 0; i < n; i++)
    my->res += sqr(i);
Если компилятор не видит код sqr, то он вынужден предполагать худшее, то есть:
  sqr изменяет значения ВСЕХ глобальных переменных
  sqr изменяет содержимое ВСЕЙ кучи
  sqr изменяет локальные переменные, если указатели на них просочились в глобальные переменные, в кучу или в другие функции...
Это означает, что он обязан на каждой итерации заново загружать из памяти res, и каждый раз сохранять обратно в память --- не самый быстрый код.

Если функция sqr заинлайнится, тогда получается:
  struct Info *my;
  my->res = 0;
  for (int i = 0; i < n; i++)
    my->res += i * i;
Теперь компилятор видит, что при вычислении i * i ничего не изменяется.
Значит он может суммировать все квадраты в регистре CPU, а потом сохранить финальный результат в память.


В силу того, как работает раздельная компиляция в C, для инлайнинга функции абсолютно НЕОБХОДИМО, чтобы её тело было видно в том же TU.
Фактически это означает, что тело функции надо писать в хедере.
Обычно функции нельзя определять в хедере, т.к. тогда они будут компилироваться много раз и линкер будет ругаться на множественное определение.

Можно сделать функцию static, тогда она будет разная в каждом TU, и не будет ошибок линковки.
Недостаток: код функции попадает во все .obj-файлы, где она используется --- замедление линковки.
Возможно даже увеличение размера .exe, ведь все эти функции должны иметь разный адрес (хотя этот вопрос решаем).

Чтобы решить проблему, ввели ключевое слово inline.
* Сначала его ввели в C++.
  В C++ inline функция (в хедере) компилируется и записывается в .obj в каждом TU, где она используется.
  При линковке линкер должен определить дубликаты функции из разных TU и удалить все копии, кроме одной.
  Как результат: медленная сборка в большинстве C++ проектов.
* Затем inline добавили в C99.     (в Visual C inline скорее всего работает не так)
  В C99 inline функция (в хедере) является только объявлением, позволяющим заинлайнить вызов.
  Машинный код для неё самой НЕ генерируется, и в .obj-файл НЕ попадает.
  Программист должен самостоятельно вставить определение inline-функции в одном TU с помощью extern inline.

Обычная функция:
  min.h:
    int min(int a, int b);                  //объявление
  min.c:
    int min(int a, int b) {                 //определение
      return (a < b ? a : b);
    }

inline-функция в стиле C++:
  min.h:
    inline int min(int a, int b) {          //объявление и определение
      return (a < b ? a : b);
    }
  min.c:
    //ничего писать не надо

inline-функция в C99:
  min.h:
    inline int min(int a, int b) {          //объявление
      return (a < b ? a : b);
    }
  min.c:
    extern inline int min(int a, int b);    //определение

Универсальный вариант, который будет работать везде, это static inline:
  min.h:
    static inline int min(int a, int b) {          //объявление и определение
      return (a < b ? a : b);
    }
  min.c:
    //ничего писать не надо
