================= Раздельная компиляция ===================

Раньше мы всегда использовали один файл с исходным кодом:

    source.c   ------------>   source.exe
                  (build)

В больших программах хранить весь код в одном файле неудобно.
Удобнее хранить в нескольких файлах:
1) Легко найти какой-то кусок кода по имени файла.
2) Ускорение инкрементальной сборки.

Схема работы языка C с несколькими файлами:
  
    +--------+   preprocess     compile   +--------+
    | main.c | -------------> ----------> | main.o | \
    +--------+                            +--------+  \
                                                       \
     +-------+   preprocess     compile   +-------+     \         +----------+
     | sum.c | -------------> ----------> | sum.o | -----+------> |   main   |
     +-------+                            +-------+     /  link   +----------+
                                                       /           (модуль --- обычно исполняемый файл)
    +--------+   preprocess     compile   +--------+  /            (module --- executable file)
    | prod.c | -------------> ----------> | prod.o | /
    +--------+                            +--------+
  (source files)                         (object files)
  (исходный код)                        (объектные файлы)

Комментарии:
1) Препроцессинг будем считать предварительным шагом компиляции.
   Его можно выполнить без компиляции, но только для отладки макросов, и это почти никто никогда не делает.
2) Каждая строка в этой схеме называется единицей трансляции (Translation Unit).
   То есть main.c / main.o --- это одна TU, sum.c / sum.o --- вторая TU, и prod.c / prod.o --- третья TU.
3) Весь процесс называется сборкой (build).
4) На выходе получается модуль: это может быть либо исполняемый файл или динамически подключаемая (разделяемая между программами) библиотека (*.so - "shared object" / "*.dll" - dynamically linked library).
   О динамически подключаемых библиотеках будет сильно позже.

Важно заметить, что каждый исходный файл компилируется абсолютно НЕЗАВИСИМО от остальных.
Компилятор не может знать абсолютно ничего о содержимом других TU.
Это называется раздельной компиляцией (separate compilation).
Более того, при линковке объектных файлов исходный код недоступен: используется только информация из объектных файлов.
По сути стрелочки на схеме полностью показывают, какой шаг какие данные использует.

Разделение на компиляцию и линковку сделано по принципу:
 > Компиляция --- делает почти всё, и делает это медленно
                  объектный код --- это практически готовый машинный код (с непроставленными адресами)
 > Линковка   --- делает минимум действий, и делает это быстро
                  только скидывает всё в кучу и проставляет адреса ("связывает" использования с определениями)

Вся эта схема разработана с целью оптимизировать сборку больших программ.

Допустим, у вас в проекте 1000 исходных файлов, и вы решили слегка исправить один из них (например, нашли баг).
Благодаря описанной модели, вам нужно скомпилировать только один изменённый файл, а потом запустить полную линковку.
Поскольку линковка работает очень быстро, то это займёт на порядок меньше времени, чем перекомпиляция всего проекта (например 10 секунд против 15 минут).
Такой сценарий (когда мало чего поменялось) называется "инкрементальной сборкой".
(кстати, сегодня уже даже линковка делается инкрементально)

Кроме того, сегодня активно используется параллельная сборка.
Благодаря тому, что компилируются файлы независимо, компилятор запускается параллельно.

Стоит помнить, что язык C появлялся, когда машины были ОЧЕНЬ слабыми.
Они не могли прочитать все исходные файлы в память --- у них не хватало памяти.
А ещё первые компиляторы были однопроходными: они не запоминали полностью даже исходный код одного файла.
В таких условиях без описанной выше системы ничего серьёзного на C было бы невозможно написать.
(кстати, Tiny C Compiler является однопроходным компилятором)

Как вызывать компиляцию и линковку в командной строке?
Заметим, что cl.exe означает "Compile & Link" --- он запускает сразу и компиляцию, и линковку.
Варианты:
* cl source.c                       //компилирует source.c в source.obj и линкует его в source.exe
* cl /c source.c                    //только компилирует source.c в source.obj (линковка не запускается)
* cl main.c sum.c prod.c            //компилирует все три файла и линкует результат в exe
* cl main.obj sum.obj proj.obj      //берутся указанные объектные файлы и линкуются в exe

В GCC ситуация аналогичная, только объектные файлы имеют расширение .o, а ключ "только компилируй" выглядит как -c

Чтобы можно было работать с несколькими исходными файлами, надо уметь использовать что-то из другого Translation Unit.
Что может быть нужно:
1) Функции: тело может быть в одном TU, а вызывать можно в другом
2) Глобальные переменные: могут быть определены в одном TU, и в другом можно их использовать.
3) ??Структуры?? --- увы, использовать объявленные в другом TU структуры невозможно.

Важно различать определение и объявление:
> Определение (definition) --- определяет тело/содержимое сущности, ?заводит для неё место/память?.
> Объявление (declaration) --- просто постулирует, что сущность есть, и поясняет, как её можно использовать.
Естественно, объявлять сущность можно сколько угодно раз, а определять больше одного было бы странно.

Функции:
  int sum(int n, int *arr);     //объявление: сигнатура функции без тела

  int sum(int n, int *arr) {    //определение: есть тело = код функции
    return arr[0] + arr[n-1];
  }

Глобальные переменные:
  int arr[1000];                //определение
  Node *root;                   //(выглядит как обычно)

  extern int arr[1000];         //объявление: есть extern
  extern Node *root;            //(говорит, что такая переменная есть, возможно в другой TU)

ВАЖНО: Для структур не заводится место в образе программы.
Структуры лишь говорят компилятору, по какому смещению нужно читать поля из указателя.
Поэтому у структуры НЕТ ОПРЕДЕЛЕНИЙ, есть только объявления.
Структуры полностью отсутствуют в объектных файлах, и до линкера не доходят.

  struct Node;                  //forward-declaration: говорит о том, что структура с этим именем есть
                                //можно работать с указателями Node*, но в полям обращаться нельзя (incomplete type)

  struct Node {                 //полноценное объявление структуры
    int value;                  //после него компилятор позволяет оперировать полями
    struct Node *next;
  };

Чтобы работать со одной структурой в нескольких TU, нужно объявить её (одинаково) в каждом TU.


Правило одного определения (One Definition Rule, ODR):
  Каждая используемая сущность должна быть определена ровно в одном месте (программы).

По стандарту языка C++ правило ODR должно выполняться.
Увы, в языке C этого правила формально нет, так что вы можете определить одну и ту же глобальную переменную дважды.
Однако настоятельно рекомендуется придерживаться этого правила, иначе легко запутаться.

Объектный файл --- это набор символов.
У каждого символа есть:
  1) имя
  2) содержимое
Символ может быть одного из типов:
 * функция (code) --- содержит готовый машинный код, только в использованиях глоб. переменных и функций не проставлены адреса
 * глобальная переменная (data) --- содержит размер (сколько байт памяти завести), возможно начальное значение

Что делает линкер (в простейшем случае):
1) Сваливает содержимое всех объектных файлов в один исполняемый файл.
2) Назначает всем символам адреса в исполняемом файле.
3) Пробегает по использованиям глобальных переменных и функций и прописывает правильные адреса.

Внимание: линкер обращает внимание только на имена символов, и проставляет только адреса!
Он не знает типов языка C, не способен даже отличить функцию от переменной!

===== Пример =====

== main.c ==
    #include <stdio.h>
    #include "hello.h" // Включем хэдер, в которам содержатся объявления символов, которые есть в модуле hello
    int main() {
        sayHello(); // Эта функция на определена в модуле main (т.е. её нет в файле main.c), она из другого модуля. Однако её объявление есть в хэдере hello.h.
        sayHello();
        sayHello();
        printf("%d\n", sayHelloCnt); // Глобальная переменная sayHelloCnt, как вы можете заметить, тоже не определена в main.c. Но она объявляна в hello.h.
        return 0;
    }

== hello.c ==
    #include <stdio.h>
    #include "hello.h"
    int sayHelloCnt = 0; // Определили глобальную переменную.
    void sayHello() { // Определили функцию.
        ++sayHelloCnt;
        printf("Hello\n");
    }

== hello.h ==
    #pragma once // Дали препроцессору директиву не включать этот хэдер более чем один раз в какой-либо файл.
    extern int sayHelloCnt; // Объявили глобальную переменную.
    void sayHello(); // Объявили функцию.

== Сборка проекта ==

Компилируем отдельно каждый *.c файл (Translation Unit):
    $ gcc -c main.c -o main.o
    $ gcc -c hello.c -o hello.o

Теперь у нас есть два объектных файла, которые можно слинковать друг с другом, и таким образом получить приложение.
Но давайте сначала посмотрим, какие символы присутствуют в этих файлах. Для этого используем утилиту nm:
    $ nm main.o
                     U _GLOBAL_OFFSET_TABLE_
    0000000000000000 T main
                     U printf
                     U sayHello
                     U sayHelloCnt

Видим, что в main.o определена функция main,
а также есть ссылки на неопределённые символы printf, sayHello и sayHelloCnt (и ещё на некий _GLOBAL_OFFSET_TABLE_).
    $ nm hello.o
                     U _GLOBAL_OFFSET_TABLE_
                     U puts
    0000000000000000 T sayHello
    0000000000000000 B sayHelloCnt

А тут видим, что hello.o содержит определение функции sayHello и переменной sayHelloCnt,
и кроме того тут есть ссылка на неопределённый символ puts (и также на _GLOBAL_OFFSET_TABLE_).

Видно, что main.o ссылается на неопределённые символы, некоторые из которых как раз определены в hello.o.

Cимволы printf, puts определены в библиотеке языка си:
    $ nm `gcc --print-file-name=libc.a` 2>&1 | grep \ printf$
    0000000000000000 T printf
    $ nm `gcc --print-file-name=libc.a` 2>&1 | grep \ puts$
    0000000000000000 W puts

Собираем приложение:
    $ gcc main.o hello.o -o app

И запускаем его:
    $ ./app
    Hello
    Hello
    Hello
    3

===== Дополнительный мателиал: Makefile =====

Пересобирать весь проект при любым изменениях --- идея не самая лучшая, так как компиляция большого количества исходников занимает много времени,
и имеет смысл перекомпилировать только то, что реально поменялось.

Каждый раз, когда нам нужно перекомпилировать какой-то файл в рамках проекта нам нужно вводить команду вида
    $ gcc -c my_module.c -o my_module.o
Делать это вручную не всегда удобно. Кроме того, нам нужно помнить какие именно модули нам надо перекомпилировать, а это тоже не всегда очевидно,
поскольку, когда мы вносим изменения в какой-нибудь хэдер (файл *.h), мы должны перекомпилировать все *.c файлы, которые прямо или косвенно включают в себя этот хэдер.

Искать каждый раз все такие зависимсти --- дело неблагодарное, лучше один раз их прописать, и сделать так, чтобы компьютер сам отслеживал сделанные
изменения в файлах исходного кода и хэдерах и перекомпилировал только те модули, на которые эти изменения влияют.

Так рождается идея о системе автоматической сборки проекта. Примером такой системы является make.
make использует Makefile, которые содержит декларативное описание зависимостей между своими так называемыми целями.
Цель Makefile --- это как правило файл, который получается в процессе сборки (но бывают специальные цели, которые файлами не являются, как правило это all, clean и т.п.).

Каждая цель в мэйкфайле описывается таким образом:
    <цель, которую описываю>: <цель, от которой она зависит>,  <другая цель, от которой она зависит>,  ...
        <команда, которая собирает мою цель>
    
В конкретном случае это будет выглядеть так:
    main.o: main.c hello.h
        gcc -c main.c -o main.o
Тут сказано, что файл main.o зависит от файлов main.c и hello.h (если эти файлы обновятся, то нужно обновить и main.o),
и указана команда, которая этот файл собирает.

== Пример Makefile для проекта, который состоит из файлов main.c, hello.c и hello.h ==
    all: app
    clean:
        rm app main.o hello.o
    app: main.o hello.o
        gcc main.o hello.o -o app
    main.o: main.c hello.h
        gcc -c main.c -o main.o
    hello.o: hello.c hello.h
        gcc -c hello.c -o hello.o

Кагда вы находитесь в директории, содержащей Makefile, то достатчно выполнить команду make для запуска сборки:
    $ make
    gcc -c main.c -o main.o
    gcc -c hello.c -o hello.o
    gcc main.o hello.o -o app

Если всё, что нужно уже собрано из актуальных версий исходников, то make напишет об этом и ничего больше делать не будет:
    $ make
    make: Nothing to be done for 'all'.

Если нужно собрать конкретную цель, то нужно её указать в качестве аргумента make. Например, если я хочу всё собранное удалить, то укажу clean в качестве цели:
    $ make clean
    rm app main.o hello.o
