=================== Компоненты связности ================

Любой неориентированный граф можно разбить на компоненты связности так, что
в каждой компоненте связности можно добраться из каждой вершины в каждую, но нельзя добраться от одной компоненты до другой.

Алгоритм поиска компонент связности:
  C = 0;
  mark[*] = white;              //изначально все вершины белые
  for u in V:                   //перебираем все вершины (в любом порядке)
    if mark[u] == white:        //когда видим белую вершину, запускаем из неё DFS
      DFS(u) <<color[u] = C;>>  //внутри DFS выполняем для посещённых вершин: color[u] = C
      С++;

Как работает алгоритм:
1) Запускается DFS из первой вершины, он посещает все вершины её компоненты связности.
  Для них получается mark = black и color = 0
2) Далее находится какая-то вершины, которая ещё white --- она в другой компоненте связности.
  Из неё запускается DFS, в результате для всей компоненты устанавливается mark = black и color = 1
3) Каждый следующий раз выбирается какая-то белая вершина, из неё запускается DFS,
  который помечает её компоненту как mark = black и записывается новый цвет color

Здесь можно отметить такое свойство DFS:
  Если у вершин уже есть какие-то пометки и мы запустили DFS(s),
  то он обойдёт все вершины, достижимые из s без прохода по заранее помеченным вершинам.

В результате получается "раскраска" вершин графа на компоненты связности.
Например, если есть компоненты связности:
 - 0 4 6 7
 - 2
 - 1 5
 - 3 8 9
То раскраска будет выглядеть как один массив "цветов" (не путать цвета=color с пометками=mark {white/gray/black}):
  int color[] = {0, 2, 1, 3, 0, 2, 0, 0, 3, 3};
Хранить в разбиение вершин на компоненты в виде раскраски проще и удобнее, чем в виде массива списков вершин.

Проход по всем вершинам графа с запуском DFS из каждой белой вершины (без стирания пометок между DFS-ами) называется "серией обходов в глубину".
Поиск компонент связности --- это по сути серия DFS с покраской вершин на каждом новом запуске в новый цвет.

Общее время работы серии DFS?
  1) Если использовать списки инцидентности/смежности, то можно перебрать все рёбра uv, идущие из вершины u, за время, процорциональное их количеству.
  2) Каждая вершина посещается ровно 1 раз (благодаря пометкам)
  3) Тогда каждое ребро просматривается 1 или 2 раза (в две стороны для неориентированного графа)
Получается, что общее время O(E + V) --- линейное/идеальное время.


==================== Обнаружение цикла ======================

Задача: проверить наличие цикла в графе / найти цикл.
Актуальна как для неориентированных графов (проверка, что граф --- это "лес"), так и для ориентированных (проверка, что граф зависимостей корректный).

Алгоритм:
  Запускаем серию DFS на графе.
  Если внутри DFS обнаруживаем ребро uv, ведущее в серую вершину v --- то цикл есть.
  Иначе цикла нет.

Действительно, допустим мы видим в обходе ребро uv в серую вершину v.
Это означает, DFS(u) запущен внутри рекурсии в DFS(v).
Можно проследить путь от v к u, по которому запускались активные вызовы DFS (все вершины этого пути = все серые вершины).
Вместе с ребром uv этот путь образует цикл.

Исключение (для неориентированных графов):
  Если в DFS(f) запускается DFS(v), то в самом DFS(v) нужно игнорировать ребро vf.
  Обычно для этого внутрь DFS передаётся вершина/ребро, по которому его вызвали: DFS(u, f)


=============== Компоненты сильной связности ================

В ориентированном графе вершины u и v сильно связны, если есть путь из u в v и есть путь из v в u.
Очевидно, что сильная связность вершин --- это эквивалентность (есть транзитивность, симметричность, рефлексивность).
Значит все вершины графа можно разбить на классы эквивалентности, которые называются "компонентами сильной связности".
Компонента сильной связности (КСС) --- это максимальное множество вершин, в котором есть путь из каждой вершины в каждую.

Если каждую КСС сжать в вершину (можно после этого ещё склеить кратные рёбра), то получится "конденсация графа" --- ациклический граф компонент сильной связности.
В некоторых задачах это понятие важно. Очевидно, конденсация легко строится, если известны КСС.


Алгоритм поиска компонент сильной связности:
1) Запускаем серию DFS на графе, запоминаем порядок выхода для всех вершин.
2) Разворачиваем все рёбра графа.
3) Очищаем пометки: mark[*] = white.
4) Запускаем серию DFS, перебирая вершины в порядке убывания tout из пункта 1.
   Каждый запущенный DFS в этой серии помечает новую КСС --- надо покрасить её новым цветом, как при поиске компонент связности.

Время работы: O(E + V)


================= Мосты и точки сочленения ==================

В неориентированном графе:
  мост --- ребро, при удалении которого увеличивается количество компонент связности
  точка сочленения --- вершина, при удалении которой увеличивается количество компонент связности

Хочется построить алгоритм, который найдёт все мосты и точки сочленения.


Запустим DFS из вершины неориентированного графа, и будем классифицировать и ориентировать (приписывать направление) рёбра в процессе обхода:
1) Если из DFS(u) мы рекурсивно вызываем DFS(v), то ребро uv направляем от u к v и называем "корневым".
2) Если внутри DFS(u) мы видим серую вершину v, то ребро uv направляем от u к v и называем "обратным".
   Исключение: пропускаем ребро uv, если DFS(u) был запущен из DFS(v) --- в этом случае ребро vu уже корневое!
Таким образом направление будет приписано всем рёбрам (можно показать, что когда мы видим ребро впервые, оно не может вести в чёрную вершину).

Корневые рёбра образуют подвешенное дерево, в котором все рёбра направлены "вниз"  (если корень сверху) --- дерево DFS.
Все остальные рёбра являются обратными: каждое из них ведёт из какой-то вершины u в её предка v в этом дереве.
(обратное ребро uv обязано вести из u в v --- предка u, т.к. в момент его первого просмотра вершина v была серой)


Каждой вершине можно приписать глубину level[u] --- сколько корневых рёбер между u и корнем дерева.
Корень находится на уровне 0, а при спуске по дереву каждая следующая вершина находится на уровне на 1 больше.
Уровни level[u] можно легко проставить всем вершинам в процессе обхода.

Введём теперь "функцию верхнего" up(u):
  up(u) = min{level[w] | v лежит в u-поддереве  &  vw in E --- обратное ребро}
Иными словами, нужно перебрать все вершины из u-поддерева и посмотреть, насколько высоко из них выходят обратные рёбра.
Минимальный уровень, на который выходят обратные рёбра из u-поддерева --- это up(u).


Функция верхнего позволяет легко находить мосты и точки сочленения:

1) Если ребро uv обратное, то оно не может быть мостом
  Почему: есть обходной путь v -> u по дереву
2) Корневое ребро uv --- мост <=> up(v) >= level[v]
  Почему: если up(v) < level[v], то есть ребро, которые выходит в u или выше -> связность при удалении uv не нарушается
          если up(v) >= level[v], то при удалении uv никакое ребро в u-поддереве не выходит из u-поддерева
3) Корневая вершина u --- точка сочленения <=> у неё больше одного сына
  Почему: очевидно
4) Некорневая вершина u --- точка сочленения <=> у неё есть сын s, для которого up(s) >= level[u]
  Почему: если up(s) >= level[u], то при удалении u образуется новая компонента: s-поддерево (из неё нет выходов).
          если up(s) < level[u] для всех сыновей s, то после удаления u есть связь по обратному ребру между каждым s-поддеревом и частью дерева выше u.

Как вычислять функцию верхнего:
  up(u) = min(  min{up(s) | s --- сын u}  ,  min{level[v] | uv --- обратное ребро}  )
                    \   /                    \                                   /
               самое верхнее обратное       самое верхнее обратное ребро из самой u
                ребро из s-поддерева

Можно вычислять up(u) на выходе из рекурсии DFS: все up(s) в этот момент уже должны быть известны.
Остаётся только взять из них минимум, просмотреть все обратные рёбра из самой u и обновить минимум.

Алгоритм:
1) Запускаем серию DFS по всему графу.
   В каждом отдельном DFS вычисляем level, up, проверяем критерии.

Время работы O(E + V).
