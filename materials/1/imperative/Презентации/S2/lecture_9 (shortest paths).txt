================ Кратчайший путь в графе ================

Есть взвешенный граф: вершины --- перекрёстки, рёбра --- дороги.
Вес каждого ребра (вещ. число) --- либо длина дороги, либо время или стоимость её прохождения.
Нужно найти путь из вершины s в вершину t по рёбрам графа с минимальным суммарным весом.
(картинка-пример)

Возможные частные случаи в зависимости от весов:

1) Все веса единичные (нет весов).
В этом случае задача решается обходом в ширину.
2) Все веса неотрицательные (очевидно для длины или времени).
Это условие необходимо для алгоритма Дейкстры.
3) Веса могут быть отрицательными, но нет циклов отрицательного веса.
Нормальный случай для большинства алгоритмов.
4) Веса могут быть отрицательными, разрешены циклы отрицательного веса.
Некоторые алгоритмы можно адаптировать к этим условиям.

Если в графе есть цикл отрицательного веса, то возникает вопрос: как определить кратчайший путь?
Если запретить проходить дважды по вершине, то задача становится очень сложной (NP-трудна).
Обычно разрешают ходить по ребру сколько угодно раз, тогда при проходе через цикл отрицательного веса длина пути становится -infinity.
Мы НЕ будем рассматривать графы с циклами отрицательного веса в контексте алгоритмов поиска кратчайших путей.


===================== Обход в ширину ====================

Все веса единичные, нужно искать кр. путь по количеству рёбер.

Идея алгоритма:
Пусть Ld --- множество вершин на расстоянии d ("слой" d).
Будем выписывать вершины слой за слоем, в порядке увеличения расстояния d.

Очевидно, L0 = {s}: стартовая вершина --- единственная вершина на расстоянии 0.
Далее, в L1 войдут все вершины v, для которых есть ребро sv.
В слой L2 войдут все вершины v, в которые есть ребро uv для вершины из слоя L1, и которые ещё не приписаны к слоям L0 и L1.
Получается, что чтобы найти очередной следующий слой L[d+1], нужно перебрать все вершины из текущего слоя L[d],
перебрать все рёбра, выходящие из них, и записать все ранее неизвестные до этого момента вершины.
(картинка-пример)

Чтобы отмечать, какие вершины мы видели, а какие нет, будем их помечать: mark[u] = F/T.
Получается алгоритм:
  for d = 0, 1, 2, ...
    if L[d] is empty:
      break
    for u in L[d]:
      for uv in E:
        if mark[v] = false:
          mark[v] = true
          add(L[d+1], v)

Если посмотреть внимательно на этот алгоритм:

    L0 | L1 | L2 | ... | L[d] | L[d+1] | ... 
   ----|----|----|-----|------|--------|-------
    s  | a  | f  | ... | %x%  |   m    | (пусто)
       | b  | g  | ... | %y%  |   n    |
       | c  | h  | ... | %z%  |   k    |
       | d  | i  | ... |  w   |   l    |
            | j  | ... |  p   |        |
                       |  q   |   \
                         \         - следующий слой: сюда уже добавлены какие-то вершины
                          \
                           - текущий слой: процентами отмечены уже обработанные вершины (в цикле по u)

В любой момент:
1) В слоях L0, L1, L2, ..., L[d-1] все вершины обработаны и больше не нужны.
  Они больше никогда не понадобятся алгоритму, и никогда не изменятся.
  Значит их хранить уже не нужно.
2) В слоях L[d+2], L[d+3], ... ничего нет: мы пока не добавили туда ничего.
3) В слое L[d] записана последовательность вершин, какая-то начальная часть уже обработана, остальные ещё нет.
  Изменяться она уже не будет.
4) В слое L[d+1] уже лежат какие-то вершины, занесённые при обработке начальной части L[d].
  В этот слой будут добавляться новые вершины при обработке оставшихся вершин L[d] (в конец).

Получается, что хранить нужно только L[d] и L[d+1].
Можно записать их подряд друг за другом:

  __________L[d]___________ ______L[d+1]____...
 |                         |            
 | %x%  %y%  %z% | w  p  q | m  n  k  l 
 |               |         |
 | (эти вершины) |
 | (уже не нужны)|

Заметим, что хранить нужно только последовательность (w p q m n k l), причём:
1) На каждой итерации цикла по L[d] нужно достать очередную вершину из начала последовательности.
2) При занесении ранее неизвестной вершины на слой L[d+1] нужно дописывать её в конец последовательность.
Тогда можно хранить эту последовательность в очереди Q.

Более того, можно даже не следить за тем, где начинается и заканчивается каждый слой:
когда слой L[d] закончится, из очереди начнут доставаться вершины слоя L[d+1], а новые вершины автоматически станут попадать в L[d+2].

С учётом этого получается классический алгоритм обхода в ширину:
  dist[*] = inf
  Q = {s}, dist[s] = 0
  while Q is not empty:
    u = Q.pop                   //извлекаем вершину из начала очереди
    for uv in E:
      if dist[v] = inf:         //будем считать, что dist == inf для непосещённых вершин
        F[v] = u
        Q.push(v)               //добавляем вершину в конец очереди
        dist[v] = dist[u] + 1

Замечания:

1) Каждая вершина заносится в очередь не более одного раза.
  Поэтому не нужно писать кольцевой буфер, очередь можно тривиально реализовать на массиве:
    int Qsize, Qarr[MAXV];              //Qarr[i..Qsize) --- очередь
    for (int i = 0; i < Qsize; i++) {
      int u = Qarr[i];                  //берём текущую вершину
      ...
        Qarr[Qsize++] = v;              //дописываем вершину в конец
      ...
    }

2) Время работы O(E + V) --- со списками инцидентности/смежности.
  Главная часть -- просмотр рёбер.
  Каждая вершина заносится в очередь не больше одного раза, значит вытаскивается тоже.
  Значит каждое ребро просматривается не более одного раза (в каждую сторону в случае неор. графа).

3) С помощью дополнительного массива можно выписать путь.
  Легко заметить, что каждое F[v] --- это предыдущая вершина на каком-то кратчайшем пути из s в v.
  Тогда путь в обратном порядке выглядит как:
      v, F[v], F[F[v]], F[F[F[v]]], ..., F[...F[v]...] = s
  Можно в цикле переходить к предыдущей вершине, пока не попадём в s, а потом просто развернуть выписанную последовательность.

  Массив F определяет "дерево кратчайших путей" (F[v] --- это отец вершины v в дереве).
  В корне получается стартовая вершина s, и любой путь из неё по этому дереву является кратчайшим путём в исходном графе.
  (картинка)


=============== Алгоритм Форда-Беллмана =================

Идея:
Будем хранить D[v] --- длина некоторого пути из s в v.
В любой момент это будет оптимальный найденный на текущий момент путь.
Изначально D[s] = 0, D[v != s] = +infinity, а дальше мы будем эти D[v] постепенно улучшать.

Улучшение по ребру uv ("релаксация"):                          D[v]
  if (D[v] > D[u] + w(uv))                  картинка:   s --------------> v
    D[v] = D[u] + w(uv);                                 \              /
                                                          \------> u ->/ w(uv)
                                                          D[u]        

Если провести достаточно много улучшений, то все пути D[u] станут оптимальными?

"Фаза" --- это улучшение всех рёбер графа по одному разу (в любом порядке).
Утв.: после |V|-1 фазы все D[*] станут оптимальными.

Алгоритм:
  D[*] = +infinity, D[s] = 0
  for phase = 1..|V|-1:
    for uv in E:
      if D[v] > D[u] + w(uv):
        D[v] = D[u] + w(uv)
        F[v] = u

Замечания:

1) Время работы: O(VE)   --- достаточно хранить список рёбер

2) F[v] --- предыдущая вершина в кратчайшем пути, F определяет дерево кр. путей

=============== Алгоритм Флойда-Уоршалла ================

Идея:
Пусть D[u,v] --- длина какого-то пути (текущего наилучшего) из u в v.
Тогда можно улучшить D[u,v] через пром. вершину w:                   D[u,v]
  if D[u,v] > D[u,w] + D[w,v]:                               u ---------------> v
    D[u,v] = D[u,w] + D[w,v]                                  \                /
                                                               \----- w ------/
                                                             D[u,w]       D[w,v]

Если сделать достаточно улучшений в правильном порядке, все пути D[*,*] станут оптимальными.

Изначально в D помещается матрица смежности: D[u,v] --- длина ребра из u в v (если есть кратные рёбра, то минимальное среди таких).
Кроме того, обычно делают D[u,u] = 0, чтобы эти же нули стояли потом в ответе.

Алгоритм:
  D = M                     //копируем матрицу смежности в матрицу D
  for w in V:               //ВНИМАНИЕ: очень важно, чтобы промежуточная вершина перебиралась во ВНЕШНЕМ цикле!
    for u in V:
      for v in V:
        if D[u,v] > D[u,w] + D[w,v]:
          D[u,v] = D[u,w] + D[w,v]
          I[u,v] = w

Замечания:

2) Алгоритм работает при любых весах, хотя циклов отр. веса быть не должно.

3) Время работы O(V^3).
  Способ хранения графа не важен: т.к. сам алгоритм неизбежно работает на матрице, лучше всего подходит матрица смежности.

4) Как найти сам путь из u в v:
  I[u,v] --- это некоторая вершина w на кратчайшем пути из u в v.
  Тогда можно написать рекурсивную функцию, которая выписывает путь из u в v.
  Сначала она достаёт w = I[u,v], потом запускает выписывание пути от u до w и от w до v рекурсивно.

5) Алгоритм поиска транзитивного замыкания для отношения является частным случаем алгоритма Флойда-Уоршалла.
  Можно рассмотреть отношение как граф, в котором каждая пара uv задаёт ребро нулевого веса.


================== Алгоритм Дейкстры ====================

Важно: все веса должны быть неотрицательными --- иначе алгоритм Дейкстры НЕ работает!

Для каждой вершины v храним D[v] --- длина некоторого пути из s в v (оптимальная на текущий момент) и mark[v] --- пометка вершины.

Есть три значения пометки:
  mark[v] = W (белая):   вершина с D[v] = +infinity --- её алгоритм ещё НЕ коснулся
  mark[v] = G (серая):   вершина с D[v] < +infinity --- алгоритм её уже коснулся, на ещё не обработал; D[v] может быть неоптимальным
  mark[v] = B (чёрная):  обработанная вершина с оптимальным значением D[v] = dist(s, v)
(строго говоря, для каждой серой вершины D[v] должно быть равно кратчайшему пути, в котором все вершины кроме последней являются чёрными)

Алгоритм работает так:
  1) Выбираем серую вершину u с минимальным D[*].
  2) Постулируем, что до этой вершины расстояние на самом деле уже оптимальное, и перекрашиваем её в чёрный.
  3) (scan) Просматриваем все исходящие из неё рёбра uv и релаксируем их (как в алгоритме Форда-Беллмана).

Если на шаге 3 если вершина v была белой, её надо перекрасить в серое.
Вообще, на практике обычно не нужно различать белые и серые вершины, поэтому вместо пометки mark=W/G/B хранят булев флаг: обработана вершина или нет.

Алгоритм:
  D[*] = +infinity,  mark[*] = W
  D[s] = 0, mark[s] = G
  while (gray vertex exists):
    u = vertex such that: 1) mark[u] = G
                          2) D[u] = min
    mark[u] = B
    for uv in E:
      if D[v] > D[u] + w(uv):
        D[v] = D[u] + w(uv)
        F[v] = u
        mark[v] = G

Замечания:

1) F задаёт дерево кратчайших путей, так что выписать кр. путь можно как в алгоритме обхода в ширину, например.


Время работы?

Внешний цикл while выполняется V раз, т.к. на каждой итерации одна вершина перекрашивается в чёрное (и никогда не перекрашивается назад).
На каждой итерации нужно:
  а) найти минимум: за O(V)
  б) просмотреть исходящие рёбра: за O(deg(u))  со списками инцидентности/смежности
Получается время работы: O(V^2 + E) = O(V^2).
При этом проще использовать матрицу смежности --- время от этого не изменится.

Для разреженных графов хочется ускорить поиск минимума, чтобы улучшить асимптотику.
Решение: будем хранить все серые вершины в бинарной куче на минимум (сравнивая вершины u и v через D[u] < D[v]).
Тогда минимум находится и извлекается за O(log V), что в сумме даёт O(V log V) на весь алгоритм.
Но теперь на каждое успешно улучшенное ребро нужно тратить O(log V), чтобы обновить положение вершины v в куче.
Итоговое время работы с кучей: O(E log V)



===================================================
Дополнительный материал (знать НЕ нужно).


*** Доказательство корректности алгоритма Форда-Беллмана (полагая, что нет циклов отрицательного веса):
  Очевидно, D[v] может только уменьшаться, но никогда не увеличиваться.
  Кроме того, всегда верно D[v] >= dist(s, v), т.к. D[v] --- это всегда длина некоторого пути из s в v.

  Чтобы доказать, что оптимум для D[v] будет достигнут, рассмотрим кратчайший путь из s в v:
      s = u[0], u[1], u[2], ..., u[k] = v               (u[] --- последовательность вершин в пути)
  (тут очевидно нужна картинка)

  Можно заметить, что после k фаз D оптимально для вершины u[k].
  База (k=0): изначально D[s] = 0 --- оптимально.
  Индукция:
    Обозначим a = u[k], b = u[k+1].
    dist(s, a) = dist(s, a) + w(ab)
  Если D[a] оптимально после k фаз, то за одну дополнительную фазу мы точно просмотрим ребро ab.
  Тогда D[b] станет не хуже D[a] + w(ab) = dist(s, a) + w(ab) = dist(s, b).

  Так как циклов отр. веса нет, то в кратчайшем пути вершины не повторяются, значит рёбер в нём не более |V|-1.


*** Алгоритм Дейкстры с кучей:
  D[*] = +inf, D[s] = 0
  H = {все вершины}                     //изначально кладём все вершины в кучу
  while H is not empty:
    u = H.extractmin                    //берём вершину из корня кучи и удаляем её
    mark[u] = T
    for uv in E:
      if D[v] > D[u] + w(uv):
        D[v] = D[u] + w(uv)
        siftUp(vert2heap[v])            //т.к. D[v] уменьшилось, просеиваем кучу вверх от v

Техническая проблема: при улучшении по ребру нужно уметь определять номер в куче для заданной вершины.
Чтобы это делать, следует хранить взаимное соответствие позиций в куче и вершин графа:
  int heap2vert[...];           //heap2vert[k] --- номер вершины, расположенной на позиции k в куче
  int vert2heap[...];           //vert2heap[v] --- позиция вершины v в куче
Когда в куче элементы меняются местами, нужно сделать swap в обоих этих массивах.
