Изменения:
1) Итоговая оценка = экзамен + практика (см. правила оценивания).
2) Наборы задач: раз в две лекции, устаревание.
   В условии подписано, какие задачи по первой лекции (I), какие --- по второй (II).
3) emailtester --- специальный проверяльщик для некоторых задач (см. отдельную инструкцию).


================= Арифметика по модулю M ==================

Мотивация: как вычислить C(n, k) mod M ?
  C(n, k) = n! / k! / (n-k)! --- биномиальный коэффициент
            также вычисляется через треугольник Паскаля
  mod M --- взятие остатка от деления на M

Пример на доске: вычисляем C(8, 5) mod 10 через треугольник Паскаля.
1) Вариант 1: влоб, потом берём последнюю цифру.
2) Вариант 2: каждое число в треугольнике сразу берём по модулю 10 --- после каждого суммирования.
Результаты одинаковые.

Если n большое (например до 1000), тогда большая разница по времени и простоте реализации.
Чтобы посчитать влоб C(1000, k), нужно писать длинную арифметику --- в результате примерно 300 цифр.
Более того, C(n, k) имеет порядок примерно 2^n, а значит длинное число будет иметь длину O(n).
Тогда чтобы вычислить треугольник Паскаля до n, нужно потратить O(n^3) времени и памяти.
Если всегда брать сразу остаток от деления, то все числа фиксированного размера, длинная арифметика не нужна, время и память O(n^2).

Другой пример: вычисляем 10! mod 11
Перемножаем числа, после каждого умножения сразу берём остаток от деления на 11.
Общая идея такая: если что-то вычисляется при помощи сложений, вычитаний и умножений, то можно все промежуточные результаты сразу брать по модулю m.

Аналогично можно вычислить, например x^3 - 17*x^2 + 4*x - 156 по модулю (10^9 + 7) при x = 123456789.
Чтобы вычислить "влоб" значение многочлена, нужны целые числа, вмещающие до 10^27 --- в 64-битные не входит.
А если каждый промежуточный результат сразу брать по модулю 10^9 + 7, тогда хватает 64-битных чисел.


Как это работает?
Пусть x, y --- произвольные целые числа, и мы знаем их остатки:
  a = x mod m
  b = y mod m
Тогда можно зная только остатки (и не зная полностью числа) найти:
  (x + y) mod m = a [+] b
  (x - y) mod m = a [-] b
  (x * y) mod m = a [*] b
Здесь [+], [-] и [*] обозначают операции сложения, вычитания и умножения "по модулю".
Их легко реализовать в программе:
  a [+] b           return (a + b) % m;
  a [-] b           return (a - b + m) % m;         //не забываем, что остаток от деления отрицательного числа на положительное в C обычно отрицательный!
  a [*] b           return (a * b) % m;             //если a, b, m 32-битные до 10^9, то нужно привести один из множителей к 64-битному типу!
                                                    //иначе будет переполнение: произведение a * b будет обрезано по 32 младшим битам


Можно заметить, что операции по модулю ведут себя во многом так же, как такие же операции над обычными целыми числами.
В частности:
  a [+] b = b [+] a                             //коммутативность сложения
  a [+] (b [+] c) = (a [+] b) [+] c             //ассоциативность сложения
  a [+] 0 = a                                   //прибавление нуля ничего не меняет
  a [-] b [+] b = a                             //вычитание обратно сложению
  a [*] b = b [*] a                             //коммутативность умножения
  a [*] (b [*] c) = (a [*] b) [*] c             //ассоциативность умножения
  a [*] 1 = a                                   //умножение на один ничего не меняет
  (a [+] b) [*] c = (a [*] c) [+] (b [*] c)     //дистрибутивность
Если рассмотреть множество остатков с этими операциями:
  < {0, 1, 2, ..., m-1}, [+], [*] > = Zm
Это называется кольцо вычетов по модулю m.

"Кольцо" --- абстрактное математическое понятие (из алгебры).
Это система с операциями сложения и умножения, в которой выполняются вышеперечисленные алгебраические свойства.
(замечание: традиционно в математике чтобы назвать что-то "кольцом", НЕ обязательны коммутативность и ассоциативность умножения, а также наличие единицы)
Другие примеры колец:
  Z --- кольцо целых чисел
  R[x] --- кольцо многочленов с вещественными коэффициентами
Во всех кольцах можно делать примерно одни и те же алгебраические преобразования.

Можно математически объяснить, почему работает вышеописанный метод "вычисляем все промежуточные результаты по модулю m".
Для этого рассмотрим функцию:
  phi(x) = x mod m     phi: Z -> Zm     (просто берёт у числа x остаток от деления на m)
Эта функция называется "гомоморфизмом" колец Z и Zm, потому что она "сохраняет операции":
  phi(x + y) = phi(x) [+] phi(y)
  phi(x - y) = phi(x) [-] phi(y)
  phi(x * y) = phi(x) [*] phi(y)
То есть чтоб найти остаток суммы в Z, можно просто сложить остатки при помощи операции сложения в кольце вычетов.
(Заметим, что операции деления здесь нет и быть не может!)

Тогда пусть у нас есть формула F(x1, x2, ..., xn) в целых числах, и ней есть только операции сложения, вычитание и умножения.
Пусть G(x1, x2, ..., xn) --- та же формула, но в которой операции + - * заменены на [+] [-] [*]
Тогда:
  phi(F(x1, x2, ..., xn)) = G(phi(x1), phi(x2), ... phi(xn))
То есть можно сразу взять остатки от деления всех атомарных чисел в формуле, а затем вычислять формулу полностью в кольце вычетов.

Другой пример гомоморфизма колец:
  Пусть Z[x] --- кольцо многочленов с целыми коэффициентами.
        a --- любое целое число
  Пусть phi(P) = P(a)               //принимает многочлен, и просто возвращает его значение при x = a
  Такое phi является гомоморфизмом колец Z[x] и Z --- легко проверить, что оно сохраняет операции.


============== Быстрое возведение в степень ===============

Как вычислить a^n = ?
Влоб: a * a * a * a * a .. * a --- работает примерно за n умножений.

Пример:
  n = 169
  a^169 = a^(128+32+8+1) = a^128 * a^32 * a^8 * a^1
  a^1   = a
  a^2   = a^1  * a^1
  a^4   = a^2  * a^2
  a^8   = a^4  * a^4
  a^16  = a^8  * a^8
  a^32  = a^16 * a^16
  a^64  = a^32 * a^32
  a^128 = a^64 * a^64
Получили вычисление a^169 за 10 умножений.

Общий алгоритм:
1) раскладываем n на степени двойки (записываем в двоичной системе)
2) в цикле по k поддерживаем a^(2^k):
   a) если k-ый бит n равен 1, то домножаем текущий результат R на a^(2^k)
   б) для перехода к след. k возводим текущее a^(2^k) в квадрат

Всего не более 2 log2(n) умножений.

Время работы:
1) В Z длина числа растёт линейно с показателем степени, а умножение занимает квадратичное время.
  Если оценивать время возведений в квадрат, оно будет:
    T = (С n/2)^2 + (C n/4)^2 + (C n/8)^2 + ... + 1 = O(n^2)
  Даже просто на последнем возведении в квадрат уже тратится O(n^2) времени.
  Если перемножать влоб, то тоже будет работать за O(n^2) --- никакой выгоды!
2) В Zn все остатки входят в наш тип данных, значит все умножения требуют O(1) времени.
  Общее время работы O(log n) --- намного лучше времени O(n) тривиального алгоритма.


Одно из основных приложений для быстрого возведения в степень --- вычисление обратного по модулю.
Остаток x называется обратным по модулю к a, если a [*] x = 1. Пишется: x = inv(a).
Если у нас есть обратный элемент, то мы можем на него "делить":
  a [/] b = a [*] inv(b)
Причём будет верно обычное свойство:
  a [/] b [*] b = a

Малая теорема Ферма (или Эйлера?):
  Если a и m взаимно просты, то:        //т.е. gcd(a, m) = 1, где gcd --- наибольший общий делитель
    a^phi(m) mod m = 1
  Здесь phi(m) --- функция Эйлера:
    phi(m) = #{ k < m | gcd(k, m) = 1 } --- количество натуральных чисел k < m, взаимно простых с m

Из этого следует:
  a * a^(phi(m)-1) mod m = 1
  a [*] a^(phi(m)-1) = 1   (в Zm)
То есть a^(phi(m)-1) = inv(a) --- это обратный элемент для a в кольце вычетов Zm.
Можно нетрудно доказать, что если gcd(a, m) = g > 1, то обратного элемента точно не существует.

На практике phi(m) вычислять довольно долго, поэтому данный способ обычно применяют только для простого m:
Если m --- простое число, то phi(m) = m-1.
Тогда обратный элемент a^(m-2) легко вычисляется быстрым возведением в степень за O(log m).


===================== Алгоритм Евклида ======================

Наибольший общий делитель (gcd):
  gcd(a, b) = (a, b) = d:    1) оба числа a, b делятся нацело на d
                             2) d = max --- максимален


Вычислять НОД (a, b) можно с помощью алгоритма Евклида.

Легко видеть, что:
  (a, b) = (b, a)
  (a, 0) = a
  (a, b) = (a-b, b)
Отсюда вытекает простой алгоритм Евклида:
  вычитаем из большего числа меньшее, пока одно из них не станет нулём.
Пример: gcd(35, 90) = (90, 35) = (55, 35) = (20, 35) = (35, 20) = (15, 20) = (20, 15) = (5, 15) = (15, 5) = (10, 5) = (5, 5) = (5, 0) = 5
На примере a = 10^9, b = 3 заметим, что время работы этого алгоритма O(a + b).

Ускорим: будем делать все подряд идущие вычитания за одну операцию:
  (a, b) = (a - q*b, b) = (a % b, b)
Получается более канонический алгоритм Евклида:
  (a, b) = (b, a%b) = ... = (a, 0) = a
  (продолжаем цепочку, пока не будет b = 0)
Можно легко реализовать рекурсивно:
  int gcd(int a, int b) { return (b == 0 ? a : gcd(b, a%b)); }

Оценим время работы (для случая a >= b > 0).
а) b <= a/2.
  Тогда (a, b) = (b, r)
         ^        ^
     первое число сократилось x2 за один шаг!
б) b > a/2.
  Тогда (a, b) = (b, r) = (r, ?)
         ^                 ^
     первое число сократилось x2 за два шага!
  (потому что r = a - b < a/2)

Получается, что за два шага первое число сокращается хотя бы в два раза.
Значит количество шагов <= 2 log2(a)
Итоговое время: O(log(a + b))


Намного более полезен "расширенный алгоритм Евклида".
Помимо gcd двух чисел, он дополнительно находит целые числа x и y, такие что:
  a * x + b * y = gcd(a, b)
Здесь:
  a и b задаются как входные данные,
  gcd(a, b) находит в том числе обычный алгоритм Евклида,
  x и y --- дополнительные выходные данные расширенного алгоритма

Для этого пишем рекурсивный алгоритм:
  Euclid(a, b) --> (g, x, y)        //g = gcd(a, b)
Как работает расширенный алгоритм:
  1) Если b = 0, то тривиально находим x, y и g.
  2) Вызываем рекурсивно:  Euclid(b, a % b) ---> (g1, x1, y1)
  3) По полученным из рекурсии значениям g1, x1 и y1 восстанавливаем g, x, y, которые возращаем наружу.
То к обычному алгоритм Евклида добавился пересчёт решения на выходе из рекурсии.

Чтобы понять, как пересчитывать, запишем уравнения для рекурсивного вызова:
  b * x + r * y = g = gcd(b, r)         //r = a % b --- остаток
Мы уже знаем, что g = gcd(b, r) = gcd(a, b) = g1.
Кроме того, остаток r можно выразить так:
  r = a - q * b         //q --- частное при делении a на b
Подставляем это выражение в уравнение и перегруппировываем слагаемые:
  b * x + (a - q * b) * y = g
  b * x + a * y - q * b * y = g
  a * y + b * x - b * q * y = g
  a * y + b * (x - q * y) = g
Значит решение уравнения можно получить по формулам:
  x1 = y
  y1 = x - q * y

Расширенный алгоритм Евклида можно применить для поиска обратного по модулю.
Если gcd(a, m) = 1 (взаимно просты), то запустив алгоритм найдем:
  a * x + b * m = 1
Это равенство по модулю m выглядит так:
  a [*] x = 1
То есть x = inv(a) --- обратный элемент.
Время работы O(log m), отлично работает даже для непростых m.
Кроме того, алгоритм возвращает gcd(a, m), так что можно заодно узнать, есть обратный или нет.


======================== Поле вычетов =========================

Пусть p --- простое число.
Тогда Zp называется "полем" вычетов, потому что в нём можно "делить" на все ненулевые элементы.
  a [/] b = a [*] inv(b)    --- "деление" по модулю через умножение на обратный
При этом выполняется обычное свойство:
  a [/] b [*] b = a
Другие примеры полей:
  R --- поле вещественных чисел
  Q --- поле рациональных чисел
  целые числа Z полем никак не являются, т.к. нет универсального деления

Основное свойство:
  Пусть q = x / y, где x, y и q --- целые числа     (x делится нацело на y)
        a = x mod m
        b = y mod m --- есть обратный в Zm
Тогда:
  q mod m = a [/] b = a [*] inv(b)
То есть можно найти остаток для частного зная остатки числителя и знаменателя, при условии, что у знаменателя b есть обратный элемент.

Как это применять для вычисления C(n, k) mod m:
  C(n, k) = n! / (k! (n-k!)) = x / y
Числитель a и знаменатель b легко вычисляются по модулю m за время O(n).
Далее можно воспользоваться свойством и найти C(n, k) как a [*] inv(b) за время O(log m).

Многие вещи можно делать в поле вычетов так же, как в вещественных числах.
Например, решать линейные системы уравнений или строить интерполяционный многочлен (будет далее).


====================== Командная строка =======================

Командная строка есть во всех операционных системах, даже в Windows и iOS.
Через командную строку можно запускать программы, например:
  chkdsk  C:  /R /X /F        (Windows)
  uname -a                    (Linux)

Командная строка разбивается на токены по пробелам:
  "chkdsk" (первый токен) --- программа, которую надо запустить (можно указывать относительный или абсолютный путь к ней)
  "C:", "/R", "/X", "/F" --- параметры командной строки для запуска программы --- программа может их посмотреть

Параметры командной строки очень полезны при автоматизации.
Можно запускать команду в скрипте, указывая её, что делать (кнопочки/окошечки такой возможности не дают).

Как читать параметры командной строки в программе на C:
  int main(int argc, char **argv) {         //main может принимать эти параметры
    for (int i = 0; i < argc; i++) {        //argc --- количество параметров + 1
      printf("[%d]: %s\n", i, argv[i]);     //argv[0] --- путь к испольняемому файлу
    }                                       //argv[>0] --- параметры командной строки в порядке задания
    return 7;                               //возвращаемое значение main = "код возврата"
  }
Код возврата выставляется по такому соглашению:
  Если программа отработала нормально (без ошибок), возвращаем ноль.
  Если программа отработала с ошибкой, возвращаем не ноль (программа может сама решить, какие числа возвращать в разных ситуациях)
Если программа умирает, то ОС сама выставляет её код возврата, и он ненулевой.

Возвращаемое значение полезно при автоматизации.
Например, когда nsuts/emailtester запускает ваше решение, он проверяет его код возврата.
Если код ненулевой, то решение обычно получает Runtime Error, даже если вы сами вернули ненулевой число.


===================================================
Дополнительный материал (знать НЕ требуется).

Пусть:
  1) A / B --- целое
  2) (B mod p) != 0
Тогда:
  (A / B) mod p = (A mod p) [*] inv(B mod p)
Доказательство: z
  пусть A / B = k --- целое, или:
    A = B * k
  применяем гомоморфизм phi(x) = x mod p --- он сохраняет умножение:
    (A mod p) = (B mod p) [*] (k mod p)
  это равенство в поле Zp, там можно вычислять обратный:
    inv(B mod p) [*] (A mod P) = inv(B mod p) [*] (B mod p) [*] (k mod p) = (k mod p)
                                  \   сокращается до 1   /
  то есть (A/B mod p) = inv(B mod p) [*] (A mod P)
