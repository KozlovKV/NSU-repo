================= Динамические библиотеки ==================

Статическая библиотека (.lib/.a)           Динамическая библиотека (.dll/.so)
  подключается при сборке             подключается в ходе выполнения или при запуске
             (при линковке)


Динамические библиотеки (DL) позволяют делать много интересного!

((1)) (shared) хранение библиотеки в памяти в одном экземпляре.

  +--------+-----------+          +--------+
  | sol.exe|somelib.lib|   ===>   | sol.exe|--
  +--------+-----------+          +--------+  \
                                               \         
  +--------+-----------+          +--------+    \+-----------+
  |word.exe|somelib.lib|   ===>   |word.exe|---->|somelib.dll|
  +--------+-----------+          +--------+    /+-----------+
                                               /         
  +--------+-----------+          +--------+  /
  |calc.exe|somelib.lib|   ===>   |calc.exe|--
  +--------+-----------+          +--------+

Если в системе запущено 100 процессов, и все используют одинаковую библиотеку (например C Runtime Library или kernel32.dll),
то в принципе можно сделать так, чтобы они все использовали физически одну версию, а не каждый процесс свою.

Учитывая, что библиотеки обычно занимают несколько МБ, сложно сказать, насколько это важно сегодня на обычных компьютерах.

((2)) Можно обновить библиотеку, не пересобирая программу.
Пересобираем только DL, заменяем файл и перезапускаем программу.
Зачем:
  а) Нужен bug fix в библиотеке (особенно важно в случае security fix)
  б) Требование при использовании LGPL-библиотеки в коммерческой программе --- возможность пересобрать и заменить библиотеку.
  в) Быстрее инкрементальная сборка приложения --- надо собрать/слинковать только те DL, в которых произошли изменения.

((3)) Расширения библиотеки.
OpenGL --- известная библиотека для трёхмерной графики.
Изначально выпущена в 1994 с набором базовых функций, с тех пор постоянно расширяется --- добавляются новые функции.

Допустим, мы в 2011 году и делаем игру.
   Game.exe  ----->  opengl32.dll
Мы хотим:
  1) чтобы игра работала у людей с видеокартами уровня 2006 года и новее.
  2) использовать шейдеры тесселляции для игроков с новыми видеокартами (2010 год и новее).
Как использовать функции для шейдеров тесселляции, но только если они есть в ОС/драйвере игрока?

В OpenGL есть механизм "расширений".
1) Игра запрашивает у OpenGL список всех расширений, которые работают на данном драйвере/видеокарте:
    char *extensions = glGetString(GL_EXTENSIONS)
2) Если в списке расширений нет желаемого ("ARB_tessellation_shader"), то фичу использовать нельзя.
2') Если в списке расширений есть желаемое, тогда надо получить функции для его использования:
    PFNGLPATCHPARAMETERIPROC glPatchParameteri = (PFNGLPATCHPARAMETERIPROC)wglGetProcAddress("glPatchParameteri");
3') Дальше игра может вызывать дополнительные функции по указателю, но только в том случае, если они есть.
P.S. Это неточное описание происходящего. Реальность несколько сложнее =)

((4)) Игровые моды.

Архитектура Doom 3:
    +-----------+          +--------------+
    | Doom3.exe-+----------+> gamex86.dll |
    +-----------+          +--------------+
   игровой движок     игровая механика = геймплей
  ID Software, 2004        (можно заменить)

Сам движок (Doom3.exe) был собран в 2004 году, и никто кроме ID Software пересобрать его не мог (до 2011 года -- далее исходный код опубликовали).
Однако с сайта ID Software можно было скачать MSVC-проект, который собирается в работающий пример gamex86.dll.
Можно изменять код этого проекта, создавая тем самым собственный геймплей --- т.е. создавая игровой "мод".
Помимо оригинальной gamex86.dll с геймплеем Doom 3, в виде мода этого движка долго существовал TheDarkMod с кардинально отличающимся геймплеем.

((5)) Система плагинов.

К редактору Notepad++ можно подключать "плагины", изменяющие его поведение.
Каждый плагин ---- это dll-файл, который надо положить в спец. место (поддиректория plugins в месте установки).

  +---------------+          +-----------------+
  | notepad++.exe |--------->| ColorPicker.dll |
  +---------------+   \      +-----------------+
                   \   \
                    \   \    +---------------------+
                     \   --->| ClipboardHelper.dll |
                      \      +---------------------+
                       \ 
                        \    +------------------+
                         --->| AutoComplete.dll |
                             +------------------+

При запуске notepad++ ищет все dll-ки, динамически загружает каждую из них.
Далее он вызывает функции с фиксированным именем, чтобы узнать, кто они такие и что умеют.
Плагин говорит, какие надо добавить кнопочки, окошечки, обработчики событий и т.п.

В результате получается расширяемый редактор.
Установить плагин может даже пользователь, который не умеет собирать программы.

Система плагинов есть во многих серьёзных программах.


>>> Динамическая библиотека (DL) полностью определяется операционной системой.
В стандарте C о них нет ни единого слова.
Схема работы в Windows и Linux (Unix и т.д.) похожа, но имеет много отличий.

             Windows:                                Linux:
     Dynamic Link Library (.dll)               Shared Object (.so)

Модуль (module) --- это либо исполняемый файл, либо динамическая библиотека (типа .exe / .dll под виндой).
Разница обычно только в том, что в .exe есть точка входа main, и его можно запустить.
При сборке/линковке кода на C всегда получается какой-то модуль.


================= Динамическое подключение =================

Схема подключения DL и получения указателя на функции:

В системе Windows:

  #include <windows.h>                                          //хедер с функциями Windows API (есть только в Windows!)

  HMODULE hDll = LoadLibrary("mydll.dll");                      //LoadLibrary ищет и подключает заданную dll в память
  typedef int (*FuncType)(int, int);                            //нам дадут только адрес функции, тип мы должны знать сами!
  FuncType myfunc = (FuncType)GetProcAddress(hDll, "myfunc");   //запрашиваем адрес функции с именем myfunc из DLL
  int sum = myfunc(3, 5);                                       //вызываем функцию по полученному указателю
  FreeLibrary(hDll);                                            //опционально: отключаем dll-ку из памяти

В системе Linux (POSIX):

  #include <dlfcn.h>                                            //хедер с функциями работы с .so

  void *hDll = dlopen("mydll.so", RTLD_LAZY);                   //подключаем .so-библиотеку с заданным именем
  typedef int (*FuncType)(int, int);                            //тип указателя на функцию
  FuncType myfunc = (FuncType)dlsym(hDll, "myfunc");            //запрашиваем адрес функции с именем myfunc из .so
  int sum = myfunc(3, 5);                                       //вызываем функцию по полученному указателю
  dlclose(hDll);                                                //опционально: отключаем .so из памяти

Также см. работающие примеры в архиве: dynamic_win и dynamic_linux

Чтобы функцию можно было загрузить из DL, при сборке DL её надо экспортировать.

====================== Экспорт функций ======================

Способ экспортирования зависит от ОС.
Кроме того, на каждой ОС их несколько.

* Windows+MSVC 1) .def-файл   (используется очень редко)
Список экспортируемых символов/функций записываем в отдельном файле:

  [mydll.def]:
    LIBRARY mydll
    EXPORTS
      myfunc

  [mydll.c]:
    int myfunc(int a, int b) {
      return a + b;
    }

Передаём этот файл при сборке:
  cl mydll.c mydll.def /LD
Здесь:
  mydll.c --- наш код
  mydll.def --- список экспортируемых функций
  /LD --- создать dll-файл вместо exe


* Windows+MSVC 2) dllexport    (используется почти всегда)
Экспортируемые функции помечаются специальным образом в объявлении.
__declspec(...) --- специальный атрибут компилятора MSVC.

  [mydll.c]:
    __declspec(dllexport) int myfunc(int a, int b) {
      return a + b;
    }

Тогда при сборке ничего дополнительного указывать не нужно:
  cl mydll.c /LD
(список экспортируемых функций составляет компилятор, а затем обрабвтывает линкер)


* Windows+MSVC 3*) по "ординалам"   (почти не используется)
См. задачу "BLAS в квадрате".


* Linux+GCC 1) По умолчанию экспортируется ВСЁ.
Просто собираем:
  gcc mydll.c -shared -fPIC -o mydll.so
Здесь:
  -shared --- собрать динамическую библиотеку (shared object)
  -fPIC --- не использовать абсолютные адреса в машинном коде,
            чтобы можно было поместить код куда угодно в памяти (Position-Independent Code)

В языке C это ещё нормально, а вот в C++ обычно получается очень много функций с длинными мутными именами.
В результаты с экспортом всего по умолчанию .so может увеличиться по размеру в несколько раз просто из-за хранения всех имён внутри.
Так что вариант рабочий, но несколько неприличный.


* Linux+GCC 2) Явно экспортируем    (предпочтительный вариант)
Экспортируемые функции надо помечать явно в объявлении.
__attribute__((...)) --- специальный атрубит компилятора GCC.

  [mydll.c]:
    __attribute__((visibility("default"))) int myfunc(int a, int b) {
      return a + b;
    }

После чего собирать можно так:
  gcc mydll.c -shared -fPIC -fvisibility=hidden -o mydll.so
Здесь:
  -fvisibility=hidden --- отключает экспорт по умолчанию (hidden означает прятать все функции, т.е. не экспортировать)
  пометка visibility("default") говорит экспортировать (default = видимость по умолчанию)


================== Статическое подключение ==================

Подключать в коде вручную каждую DL и вытаскивать указатель на каждую функцию --- очень муторно.
Это приемлемо только для маленького количества библиотек и функций.
Кроме того, в C++ имена большей части символов зависят от особенностей компилятора, и их просто не получится явно прописать.

Поэтому есть механизм статического подключения DL.
Он позволяет при сборке модуля записать в него:
  1) какие DL надо подключить
  2) какие функции из них надо вытащить (импортировать)
При запуске программы всё это автоматически подключает загрузчик ОС.
В Windows он всегда ищет DLL в директории, в которой лежит .exe-файл (потом смотрит system32 + PATH).
В Linux загрузчик НЕ смотрит в текущей директории, а смотрит в RPATH, зашитом в исполняемый файл при сборке (можно заставить искать в той же директории с помощью "-Wl,-rpath=.").

Наверняка все видели при запуске какой-нибудь программы в Windows вылетающее окошко с сообщением типа:
  "The program can't start because MSVCP120.dll is missing from your computer."
  "The procedure entry point ucrtbase.terminate could not be located in dynamic link library api-ms-win-crt-runtime-l1-1-0.dll."
Такое случается, если загрузчик не смог найти прописанные DLL или необходимые функции в них.

Статическое подключение используется практически всегда для DL.
Исключения --- те случаи, когда абсолютно необходимо подключать что-то во время выполнения (например: моды, плагины, расширения).


>>> Windows/MSVC.
На MSVC при сборке .dll всегда также генерируется .lib --- так называемая "библиотека импорта" (import library).
В ней для каждого экспортированного символа есть крошечный helper-символ с тем же именем.
Реальный машинный код функций расположен целиком внутри .dll: helper-функция лишь вызывает этот код по указателю.
Библиотеку импорта можно слинковать с кодом, в котором используются функции из DL --- helper-функции покроют потребности линкера.
Когда программа запускается, загрузчик Windows импортирует все функции из DL и прописывает в память все указатели.

Пример:
  [myprog.c]:
    int myfunc(int a, int b);           //объявление функции необходимо, чтобы компилятор знал,
    int main() {                        //что она есть и как её вызывать
      return myfunc(3, 5);
    }

Когда создаём DL:
  cl mydll.c /LD            --- получаем mydll.dll и mydll.lib
Когда собираем программу с использованием DL:
  cl myprog.c mydll.lib     --- получаем myprog.exe
Если mydll.lib не передать, то линкер будет жаловаться на отсутствие символа myfunc.
Естественно, полученный myprog.exe на самом деле не содержит собственно код myfunc --- реальный код находится в mydll.dll.

* Есть возможность слегка оптимизировать вызовы функции из DLL.
Для этого используется атрибут dllimport.

Пример:
  [myprog.c]:
    __declspec(dllimport) int myfunc(int a, int b); //подсказываем компилятору,
    int main() {                                    //что функция на самом деле из DLL
      return myfunc(3, 5);
    }
Учтите, что dllimport --- это лишь небольшая оптимизация, она не обязательна.


>>> Linux/GCC.

Файл .so выполняет роль библиотеки импорта, если передать его линкеру.

Когда создаём DL:
  gcc mydll.c -shared -fPIC -o mydll.so     --- получаем mydll.so
Когда собираем программу с использованием DL:
  gcc myprog.c mydll.so -o myprog           --- получаем myprog
Никакие атрубиты в определении не нужны.
Линкер берёт из mydll.so только список импортируемых функций --- при запуске функция лежит в автоматически подключаемом mydll.so.


>>> Общепринятый кросс-платформенный вариант.

Заметим, что для статического подключения DL нужно отдать пользователю:
1) mydll.h (хедеры) --- объявления функций для компилятора
2) mydll.lib (библиотека импорта) --- символы для линкера
3) mydll.dll (DL) --- машинный код функций для загрузчика
В Linux один файл mydll.so закрывает сразу пункты 2 и 3.

Проблема: есть противоречие в том, какие атрибуты должны стоят у объявления функции в mydll.h:
  Windows, сборка mydll.dll:
    __declspec(dllexport) int myfunc(int a, int b);
  Windows, сборка myprog.exe:
    __declspec(dllimport) int myfunc(int a, int b);
    int myfunc(int a, int b);       //так тоже можно
  Linux, сборка mydll.so:
    __attibute__((visibility("default"))) int myfunc(int a, int b);
  Linux, сборка myprog:
    __attibute__((visibility("default"))) int myfunc(int a, int b);
    int myfunc(int a, int b);       //так тоже можно (вроде)
Разумеется, заводить три хедера с одинаковыми объявлениями --- очень плохой вариант.

Чтобы решить проблему, атрибут заворачивают в макрос:
  [mydll_exports.h]
    #ifdef _WIN32     //Windows/MSVC
      #ifdef MYDLL_EXPORTS                      //если собираем mydll.dll
        #define MYDLL_API __declspec(dllexport)
      #else                                     //если собираем что угодно другое
        #define MYDLL_API __declspec(dllimport)
      #endif
    #else             //Linux/GCC
      #define MYDLL_API __attribute__((visibility("default")))
    #endif

Этот макрос в каждой DL помещают в отдельный хедер, например mydll_export.h, и include-ят его во всех публичных хедерах.
Если в DL только один публичный хедер, можно написать макрос прямо в нём.

Далее в публичных хедерах используется макрос:
  [mydll.h]:
    #include "mydll_exports.h"
    MYDLL_API int myfunc(int a, int b);

Остальные файлы пишутся как обычно:
  [mydll.c]:
    #include "mydll.h"
    int myfunc(int a, int b) {
      return a + b;
    }
  [myprog.c]:
    #include "mydll.h"
    int main() {
      return myfunc(3, 5);
    }

Тогда собираем так:
  Windows/MSVC:
    cl mydll.c /LD /D MYDLL_EXPORTS
    cl myprog.c mydll.lib
  Linux/GCC:
    gcc mydll.c -shared -fPIC -o mydll.so
    gcc myprog.c mydll.so -o myprog
На MSVC необходимо объявить макрос MYDLL_EXPORTS при сборке самой библиотеки --- чтобы было dllexport.
При сборке использующих библиотеку программ объявлять макрос нельзя --- чтобы было dllimport.
На Linux/GCC можно ничего не объявлять: там visibility можно указывать как при экспорте, так и при импорте.

Также см. работающие примеры в архиве: static_any

===================== Подключение CRT =======================

Любая программа на C автоматически использует библиотеку CRT --- C Runtime Library (она же libc).
Там лежат всякие memcpy, printf, malloc, и многое другое.

Библиотеку CRT можно слинковать как статическую библиотеку или как динамическую.
Например, в MSVC:
  cl myprog.c /MT   ---- линковать CRT статически внутрь myprog.exe
  cl myprog.c /MD   ---- линковать CRT как динамическую библиотеку --- загружается из dll при запуске

К сожалению, в MSVC разные умолчания касательно CRT:
  Если компилировать через cl в консоли, то по умолчанию будет /MT.
  Если создать новый проект, в нём по умолчанию будет /MD.

Если в программе есть динамические библиотеки, то крайне желательно линковаться с CRT динамически во ВСЕХ модулях.
Иначе получается проблема:

   +------------------+              +-----------------+-----+
   | myprog.exe (/MD) |~~~~~~~~~~~~~~| mydll.dll (/MT) | CRT |
   +-----+------------+              +-----------------+-----+
         |             \
   +-----+-----+        \    +----------------+-----+
   | CRT (dll) |         ~~~~| cool.dll (/MT) | CRT |
   +-----------+             +----------------+-----+

Здесь код myprog.exe будет вызывать функции из dll-CRT,
а код mydll.dll и cool.dll будут использовать свои приватные CRT (всего получается три разных CRT).
При использовании нескольких CRT есть ограничения:
  1) Куча в каждом CRT своя: нельзя выделять память в одном CRT, а удалять в другом.
  2) У каждого CRT свои потоки ввода/вывода и буферы: читать/писать в один FILE* через разные CRT нельзя.
  и т.д.

P.S. Аналогичная проблема возникает всегда, когда одна и та же статическая библиотека с глобальными переменными линкуется в несколько разных модулей.


Где какие настройки искать в Visual Studio:
  Собирать динамическую библиотеку:
    Project properties: General -> Configuration Type := Dynamic library
  Выбор способа линковки CRT:
    Project properties: C/C++ -> Code Generation -> Runtime Library
Всё остальное можно посмотреть в тексте лекции по статическим библиотекам.