================= Решение линейных систем =================

Линейная система уравнений:

    A11 * X1 + A12 * X2 + A13 * X3 + ... + A1n * Xn = B1
    A21 * X1 + A22 * X2 + A23 * X3 + ... + A2n * Xn = B2
    ....................................................
    Am1 * X1 + Am2 * X2 + Am3 * X3 + ... + Amn * Xn = Bm

Всего m уравнений, n переменных.
В матричном виде: A * X = B

Естественно, в программе система хранится в виде матрицы.
Для решения удобно дописать вектор правой части B в конец матрицы (как дополнительный (n+1)-ый столбец).

Метод Гаусса для решения линейных систем (также "метод исключения переменных"):
1) Приведение к ступенчатому виду.
2) Решение ступенчатой системы.

>>> Ступенчатый вид системы уравнений выглядит так (точнее её матрица):

    X????????????????????????
    0X???????????????????????
    0000X????????????????????
    00000X???????????????????
    0000000X?????????????????
    000000000000000000X??????
    0000000000000000000000X??
    0000000000000000000000000
    0000000000000000000000000

Здесь:
  0 --- это ноль
  X --- число != 0 (на него будем делить)
  ? --- произвольное число

Обозначим номер первого ненулевого элемента в i-ой строке через d[i].
Пусть первые r строк ненулевые (соответственно либо r = m, либо (r+1)-ая строка нулевая).

Тогда матрица/система находится в ступенчатом виде, если:
  1) Последовательность d[i] строго возрастает.
  2) Все строки, начиная с (r+1)-ой, полностью нулевые (если таковые вообще есть).
(рекомендуется понять, что эти условия означают на картинке)

Классифицируем переменные на зависимые и свободные.
  1) Переменная Xj зависимая, если в какой-то i-ой строке d[i] = j
     Применительно к верхней картинке это означает: если в соответствующем столбце матрицы есть 'X'.
  2) Остальные переменные свободные.

Утверждение:
A) Если есть i-ая строка с d[i] = n+1 (то есть 'X' стоит в дополнительном столбце правой части), то решений нет.
B) В противном случае:
   Если приписать произвольные значения всем свободным переменным, то найдётся ровно один способ приписать значения зависимым переменным так, чтобы вместе получилось решение системы.
   Иными словами, существует единственное решение системы, если зафиксировать все свободные переменные на произвольных значениях.

Доказательство:
Случай A:
  Если d[i] = n+1, то это уравнение имеет вид  0*X1 + ... + 0*Xn = Bi  при Bi != 0.
  Очевидно, это условие невозможно удовлетворить, значит у системы нет решений.
Случай B:
  Уравнения r+1..m (если есть) имеют вид 0 = 0 и удовлетворены автоматически.
  Будем перебирать строки/уравнения в порядке от r-ой к 1-ой.
  В каждой i-ой строке можно однозначно выразить значение d[i]-ой переменной через значения всех последующих переменных.
  Заметим, что значения всех последующих переменных к этому моменту уже определены однозначно.

Доказательство для случая B превращается в алгоритм решения ступенчатой системы:
  for (int j = 1; j <= n; j++)
    if (isFree[j])
      X[j] = arbitrary;
  for (int i = r; i >= 1; i--) {
    double sum = 0;
    for (int j = d[i]+1; j <= n; j++)
      sum += A[i][j] * X[j];
    X[d[i]] = (B[i] - sum) / A[i][d[i]];
  }
Время работы O(m*n).

>>> Приведение к ступенчатому виду.

Заметим, что над строками матрицы (уравнениями системы) можно делать такие операции:
  1) swap(Ai, Aj)         --- поменять строки местами
  2) Ai := Ai - Aj * t    --- вычесть из одной строку другую, умноженную на коэффициент
При выполнении этих операций множество решений системы не изменяется.

С помощью этих преобразований можно привести матрицу к ступенчатому виду следующим рекурсивным алгоритмом.

> Случай A: весь первый столбец нулевой.
  В этом случае переменная X1 неизбежно становится свободной --- система уравнений от неё вообще не зависит.
  Нужно пропустить первый столбец и рекурсивно решить задачу без него   (для подматрицы A[1..m, 2..n]).

      0????????         0X???????
      0????????  (rec)  00X??????
      0???????? ------> 0000X????
      0????????         0000000X?
      0????????         000000000

> Случай B: в первом столбце есть ненулевой элемент.
  Допустим, он стоит в k-ой строке, т.е. Ak1 != 0.
  Поменяем местами первую и k-ую строку:

      0&&&&&&&&        X%%%%%%%%
      0????????  swap  0????????
      X%%%%%%%% -----> 0&&&&&&&&
      ?????????        ?????????
      ?????????        ?????????

  Теперь нужно сделать так, чтобы переменная X1 входила только в первое уравнение (это и называется "исключением переменной").
  То есть нужно занулить все элементы первого столбца (кроме элемента в первой строке).
  Это делается вычитанием первого столбца, домноженного на подходящий коэффициент.
  
    for (int i = 2; i <= m; i++) {
      double t = A[i][1] / A[1][1];
      for (int j = 1; j <= n+1; j++)        //не забываем про дополнительный (n+1)-ый столбец!
        A[i][j] -= A[1][j] * t;
    }

  В результате получается то, что надо:

      X????????       X????????       X????????       X????????       X????????
      ?????????  i=2  0????????  i=3  0????????  i=4  0????????  i=5  0????????
      ????????? ----> ????????? ----> 0???????? ----> 0???????? ----> 0????????
      ?????????       ?????????       ?????????       0????????       0????????
      ?????????       ?????????       ?????????       ?????????       0????????

  Теперь фиксируем первую строку и первый столбец и рекурсивно приводим оставшуюся часть (подматрицу A[2..m, 2..n]) к ступенчатому виду.

      X????????         X????????
      0????????  (rec)  0X???????
      0???????? ------> 000X?????
      0????????         000000X??
      0????????         000000000

Алгоритм описан в рекурсивном виде для простоты. Обычно он реализуется без рекурсии.


Время работы:
  Случай A:
    Нужно лишь просмотреть столбец за O(m).
    За весь алгоритм накапливается O(m*n) в худшем случае.
  Случай B:
    Просмотр столбца за O(m), обмен строк за O(n).
    Исключение переменной занимает O(m*n) (для одной переменной) --- основное время работы получается отсюда.
    Всего r зависимых переменный, так что за весь алгоритм O(r*m*n).

Получается время: O(r * m * n), или O(m * n * min(m,n)), или O(N^3)
  (где N = max(m, n) --- обычно размеры матрицы примерно одинаковые, так что только общая степень важна)

Алгоритм использует только сложения, вычитания, умножения и деления, и отлично работает в любом поле.
Варианты:
  1) Вещественные/комплексные числа.
     Из-за сложностей с ошибками округления в этом случае обычно решаются только невырожденные системы (т.е. m = n = r).
  2) Поле вычетов по модулю p.
     Ошибок округления нет, всё идеально точно --- можно надёжно решать даже вырожденные системы с произвольными размерами.


============== Полиномиальная интерполяция ================

Задача интерполяции:
  Дан набор точек (Xi, Yi)     (i = 0 .. n-1, все Xi различны)
  Нужно найти функцию F(x), которая проходит через все точки, т.е. F(Xi) = Yi

Мы рассматриваем полиномиальную интерполяцию (полином = многочлен), то есть функция F должна быть многочленом.
Термины:
  degP = n-1 --- степень P (т.е. в какой максимальной степени входит переменная x)

Получается задача:
  Найти многочлен P со степенью не более n-1, такой что P(Xi) = Yi для i = 0..n-1

Искомый многочлен:
  P(X) = A[0] + A[1] X + A[2] X^2 + A[3] X^3 + ... + A[n-1] X^{n-1}
Нужно найти A[0..n-1] --- n коэффициентов.


>>> Способ I (влоб).

Запишем все условия, что P(Xi) = Yi:
  A[0] + A[1] *  X[0]  + A[2] *  X[0]^2  + A[3] *  X[0]^3  + ... + A[n-1]  X[0]^{n-1}  =  Y[0]
  A[0] + A[1] *  X[1]  + A[2] *  X[1]^2  + A[3] *  X[1]^3  + ... + A[n-1]  X[1]^{n-1}  =  Y[1]
  ............................................................................................
  A[0] + A[1] * X[n-1] + A[2] * X[n-1]^2 + A[3] * X[n-1]^3 + ... + A[n-1] X[n-1]^{n-1} = Y[n-1]
Здесь A[0], A[1], A[2], ... A[n-1] --- n неизвестных, которые мы хотим найти.
      Y[i] --- конкретные числа, заданные во входных данных.
      X[i]^j --- это конкретные числа, которые мы можем посчитать по входным данным.
Значит это линейная система уравнений относительно неизвестных A[j] размера n на n.
Можно решить её методом Гаусса за O(n^3).

Заметим также, что матрица A уравнения имеет вид A[i,j] = X[i]^j.
Такая матрица называется матрицей Вандермонда, её определитель можно найти по простой формуле.
Важно то, что если все X[i] различные, то матрица Вандермонда невырождена => у системы существует единственное решение.


>>> Способ II (интерполяционный полином Лагранжа).

Определим базисные многочлены таким образом:
  Bi(Xj) = { 0;   если i != j
           { 1;   если i == j
Иными словами, i-ый базисный многочлен равен единице в i-ой точке, и нулю во всех остальных заданных точках.

Тогда решение задачи легко составляется линейной комбинацией базисных функций:
  P(X) = sum Yi * Bi(X)
Можно убедиться, подставив X = Xj для каждого j.

Как найти базисные полиномы?

Если у многочлена P(x) есть ноль x=a (т.е. P(a) = 0), то P делится на (x - a).
Заметим, что у многочлена Bi есть n-1 корень --- это все Xj при j != i.
Значит он должен иметь вид:

  Bi(x) = C  *  prod (X - Xj)
               (j!=i)

При таком виде базисный многочлен автоматически зануляется везде, где положено.
Остаётся подогнать C так, чтобы было верно Bi(Xi) = 1 --- отнормировать его.
Для этого достаточно скалярного C:

  Bi(x) =  prod(X - Xj)  /  prod(Xi - Xj)
          (j!=i)           (j!=i)

Здесь числитель --- это многочлен от X.
Знаменатель --- это число. Это число отлично от нуля, потому что Xi != Xj.
Видно, что знаменатель --- это просто числитель, в который подставлено X = Xi --- чтобы при X = Xi обе части были одинаковые.

Вычисляется базисный многочлен за O(n^2), так что общее время работы O(n^3).


>>> Способ III (интерполяционный полином Ньютона).

Будем строить искомый многочлен инкрементально.
Начнём с одной точки X0 -> Y0 и многочлена P(x) = Yi.
Далее на каждом шаге будем добавлять по одной точке в набор, и модифицировать многочлен так, чтобы он имел нужные значения на всех рассмотренных точках.

Допустим, мы сделали k шагов, и нашли многочлен, который имеет правильные значения на первых k точках.
То есть у нас есть многочлен P(X), такой что:
  P(Xi) = Yi    для i = 0..k-1
  degP = k-1
Чтобы добавить k-ую точку, нужно найти многочлен Q(x), такой что:
  Q(Xi) = Yi    для i = 0..k
  degQ = k

Будем искать многочлен в виде Q = P + W.
Заметим, что W = (Q - P) имеет k нулей X[0], X[1], ..., X[k-1], значит он должен делиться на (X - Xi) для всех i = 0..k-1.
Тогда:

  Q =  P  +  C  *  prod  (X - Xj)
                   (j<i)

Достаточно сделать C скаляром, чтобы удовлетворить уравнение.
Для этого подставим X = Xk (добавляемая точка) и выразим C через всё остальное.
Произведение в правой части ненулевое при X = Xk, так что на него можно делить.

Если поддерживать от шага к шагу произведение prod(X-Xj) в виде многочлена,
то время работы будет O(N^2) --- так как на k-ый шаг требуется порядка O(k) времени.


Применения интерполяции:

1) В вещественных числах --- для приближения гладкой функции F(x).
   Это полезно например тогда, когда вычисление функции в заданной точке работает медленно.
   Можно вычислить значение функции в d равномерно распределённых точках, и построить по ним многочлен P(x) степени d-1.
   Т.к. функция раскладывается в ряд Тейлора, есть надежда, что |F(x)-P(x)| мало.

   Действительно, если функция определена на отрезке [a, b] и гладкая, то:
     |F(x) - P(x)| <= O(h^d)
   где h = (b - a) --- длина отрезка
   Следует заметить, что константа в O-большом зависит от производных функции.

   Обычно делают так:
   1) Делим область определения [a, b] на N одинаковых подотрезков.
   2) На каждом подотрезке вычисляем d точек и строим интерполяционный полином.
   3) При вычислении функции в точке x: определяем, в какой подотрезок она попала, и вычисляем соответствующий полином.

   При этом степень d обычно делают невысокой (примерно 5-20), а K увеличивают согласно ограничениям по времени/точности.

2) В поле вычетов: схема Шамира разделения секрета --- в чистом виде полиномильная интерполяция


============== Китайская теорема об остатках ==============

Пусть M[0], M[1], ..., M[n-1] --- это попарно взаимно простые модули.
Обозначим их произведение через P.

Тогда китайская теорема об остатках (КТО) гласит, что:
  система из n уравнений по модулю:
    X mod Mi = Ai      для всех i = 0..n-1
  эквивалентна одному уравнению по модулю:
    X mod P = A
  (для некоторого значения A)

Иными словами, если известны остатки от деления X на взаимно простые модули M[0], M[1], ..., M[n-1],
то всегда можно однозначно восстановить X с точностью до смещения, кратного P.
Нас больше всего интересует алгоритм определения числа A по остаткам Ai.

Обычно на практике берётся достаточно много модулей, так чтобы заведомо было известно, что 0 <= X < P.
В этом случае по известным остаткам Ai можно однозначно восстановить число X.

Интересный пример применения --- длинная арифметика.
Выберем n различных простых чисел M[0], M[1], ..., M[n-1].
Вместо того, чтобы хранить все цифры длинного числа X, будем хранить его остатки от деления на эти модули.
Чтобы сложить, вычесть, умножить (и раделить нацело) два таких длинных числа, достаточно выполнить ту же операцию над остатками по всем модулям.
Если потребуется распечатать число, можно будет перевести его в обычный вид с помощью КТО (главное быть уверенным, что число X не превышает произведение модулей).


>>> Способ I (в стиле Лагранжа)

Определим базисные числа Bi такие, что:
  Bi mod Mj = { 0;   если i != j
              { 1;   если i == j
Если такие числа есть, то искомое решение легко восстанавливается:
  X = sum Ai * Bi

Попробуем найти Bi.
Раз Bi == 0 (mod Mj) для j!=i, значит Bi делится нацело на все Mj (при j!=i).
Так как все модули взаимно простые, то оно обязано делиться и на их произведение.
Тогда Bi должно иметь вид:
  Bi = C * prod Mj = C * (P/Mi)
          (j!=i)

Остаётся подогнать множитель C так, чтобы было верно Bi mod Mi = 1:
  1 = (P/Mi) [*] C   (mod Mi)
Заметим, что (P/Mi) взаимно простое с Mi по условию.
Значит у него есть обратный по модулю Mi:
  C = inv(P/Mi)    (mod Mi)

Так находятся базисные числа.
Можно заметить существенную аналогию с интерполяционным полиномом Лагранжа.

На практике при умножении Bi на Ai может быть переполнение, т.к. Bi достигает P по порядку величины.
Поэтому лучше вычислять ответ по формуле:
  X = sum (P/Mi) * (inv(P/Mi) * Ai  mod Mi)
Здесь:
  у P/Mi желательно взять остаток по модулю Mi перед вычислением обратного.
  Умножение inv(P/Mi) на Ai следует делать по модулю Mi


>>> Способ II (в стиле Ньютона)

Работает аналогично интерполяционному многочлену Ньютона.
Дополнительный материал (см. ниже).


===================== Командная строка ========================

При работе в командной строке всегда "текущая директория" --- директория, где вы сейчас находитесь.

Программу в командной строке можно запускать тремя способами:
1) По абсолютному пути:
   (работает из любой текущей директории)
      /home/user/testing/fitprogr/tasks/xset2/1_easyargs/sol_ok
2) По относительному пути:
   (файл ищется относительно текущей директории)
      xset2/1_easyargs/sol_ok
        (из текущей директории зайти в xset2, внутри в 1_easyargs, и там внутри взять исполняемый файл sol_ok)
      ../../fitprogr/tasks/xset2/1_easyargs/sol_ok
        (из текущей директории выйти наверх на два уровня, затем зайти в поддиректории fitprogs, tasks, xset2, 1_easyargs, и там выполнить файл sol_ok)
3) Без пути:
     chkdsk.exe

В случае способа 3 система:
  0) В случае Windows/DOS смотрит наличие программы в текущей директории
  1) Перебирает все пути, указанные в переменной среды PATH, и проверяет, есть ли в них программа.
Если при этом исполняемый файл можно найти несколькими способами, то обычно используется первый подходящий.

PATH --- переменная среды, как её менять написано много где:
  https://www.howtogeek.com/118594/how-to-edit-your-system-path-for-easy-command-line-access/
  https://nicothin.pro/page/windows-path

Отныне мы зачастую будем работать в с компилятором GCC. Нужно уметь запускать его в командной строке.
Компилятор GCC называется просто "gcc" (в Windows "gcc.exe")
   Общий вид командной строки:
     gcc  {исходные файлы}  {параметры}
   Например:
     gcc sol_ok.c -O2 -o sol_ok

   Часто используемые параметры:
     -O2            --- включить в компиляторе оптимизацию (по умолчанию включена в emailtester)
     -o имя         --- указывает имя записываемого выходного файла (по умолчанию a.out или в случае Windows a.exe)
     -D имя         --- определить константу препроцессора
     -g             --- создать отладочную информацию         (необходима для отладки в gdb и любом другом отладчике)
   Посмотреть прочие параметры можно так:
     gcc --help
   И гораздо более подробно:
     man gcc

  В случае Windows:
  - GCC можно установить в составе mingw-w64 (https://www.mingw-w64.org/)
  - далее достаточно прописать путь к gcc.exe в PATH, и можно будет использовать его в командной строке (аналогично с компиляторами Clang и TCC)


(В случае работы с продуктами компании Майкрософт)
Компилятор Visual C называется "cl.exe".

   Просто добавить его в PATH недостаточно, нужно использовать специальный скрипт: "vcvars32.bat", "vcvars64.bat" или "vcvarsall.bat".
   Варианты:
     а) открыть "Developer Command Prompt for VS XXXX" и жить в голой консоли cmd
     б) настроить скрипт для запуска Far Manager с этими переменными и жить в нём.

   Общий вид командной строки:
     cl.exe  {исходные файлы}  {параметры}
   Например:
     cl sol_ok.c /O2 /Fe"solution.exe"

   Часто используемые параметры:
     /O2            --- включить в компиляторе оптимизацию  (всегда включена в Release и nsuts)
     /Fe"имя"       --- указать другое имя создаваемого exe-файла
     /D имя         --- определить константу препроцессора  (например "/D NDEBUG" выбрасывает assert-ы, так же как "#define NDEBUG" в начале программы)
     /Zi            --- создать отладочную информацию       (необходима чтобы отлаживать программу в Visual Studio)
   Посмотреть все параметры можно так:
     cl /?


=============================================================================================================================
=============================================================================================================================
   Ниже идёт дополнительный материал!
   Его не было на лекции и не будет на экзамене.
=============================================================================================================================
=============================================================================================================================

>> Метод Ньютона для КТО.

Допустим, у нас есть решение A для первых k модулей, то есть:
  A mod Mi = Ai    для всех i = 0..k-1
Нужно добавить модуль Mk и найти число B, которое будет иметь правильные остатки в том числе по нему.

Будем искать B в виде:
  B = A + c * prod Mi
             (i<k)
Легко заметить, что по первых k модулям у A и B одинаковые остатки.
А по последнему модулю можно получить нужный остаток Ai, если выбрать C так:
  c = (B [-] A) [*] inv(prod Mi)     (mod Mk)
                        (i<k)
Время работы такое же.
