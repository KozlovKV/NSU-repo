================== Препроцессор и условная компиляция ====================

Препроцессор --- запускается как первый шаг компиляции, преобразует текст программы.
Препроцессор не знает ничего, что знает компилятор: типы, массивы и т.п. Работает с токенами.
Директива препроцессора --- всё, что начинается с решётки (#) и заканчивается переводом строки.
Препроцессор только смотрит на директивы и выполняет замены макросов в остальном коде.

#define {имя} {что} // определение макроса
#undef {имя}        // "удаление" макроса

Виды макросов:
  #define ENABLE_MAIN                        // пустой макрос (просто удаляется)
  #define SIZE (sizeof(int) * 1000)          // макрос общего вида (заменяется как текст)
  #define BITNESS 64                         // целая константа (понимается препроцессором)
  #define min(x, y) ((x) < (y) ? (x) : (y))  // макро-функция (заменяется как текст с аргументами)

Условная компиляция выглядит так:
    #if {условие1}
    ...                     //остаётся, если {условие1} верно
    #elif {условие2}
    ...                     //остаётся, если {условие1} неверно и {условие2} верно
    #elif {условие3}
    ...                     //остаётся, если {условие{1,2}} неверны и {условие3} верно
    #else
    ...                     //остаётся, если все условия неверны
    #endif
(здесь через ... обозначены произвольные секции кода)

Препроцессор вычисляет все условия, и по обычным правилам C выбирает секцию кода.
Эта секция кода остаётся и её потом видит компилятор, все остальные удаляются, и компилятор их даже не видит.
Такое поведение очень полезно, если какой-то компилятор не понимает синтаксис и ругается --- для него можно написать отдельный кусок кода.
Наличие #elif и #else --- опционально.

Как препроцессор вычисляет условие в #if:
1) сначала он заменяет макросы в условии по обычным правилам
2) потом он вычисляет выражение
3) если получилось 0, то условие неверно, если не 0, то верно

Препроцессор умеет вычислять:
1) Целые константы  (диапазон возможных значений зависит от компилятора).
2) Арифметические выражения над целыми: + - * / ^ ~ ...
3) Сравнения над целыми: == < > <= и т.п.
4) Логические связки: && || !
5) Конструкция defined({имя}) --- вычисляется как 1, если макрос с заданных именем определён, и как 0 иначе.
Препроцессор не умеет вычислять sizeof, т.к. не знает типы, и не умеет работать с вещественными числами, строками, функциями и пр.

Пример:
  #if defined(BITNESS) && BITNESS >= 32
  #if min(BITNESS, 40) >= 45

Сокращения:
  #ifdef  {имя}  то же, что и  #if  defined({имя})
  #ifndef {имя}  то же, что и  #if !defined({имя})

Для условной компиляции обычно используют каждый макрос в одном из двух режимов:
1) Макрос с целочисленным значением (0 или 1, возможны другие значения). Проверка через #if {имя}.
2) Макрос-флаг (не определён или пустой). Проверка через #ifdef {имя}.

Макрос assert (из assert.h) проверяет условие и падает, если оно неверно.
В релизной сборке все assert-ы обычно удаляются, потому что определяется макрос NDEBUG.
Собственная реализация assert:
  #ifdef NDEBUG
    #define assert(cond) ((void)0)
  #else
    #define assert(cond) \
      if (!(cond)) \  
        AssertionFailed(#cond, __FILE__, __LINE__); \
      else \
        ((void)0)
  #endif

Здесь:
1) ((void)0) --- выражение, которое НИЧЕГО не делает
2) Обратный слэш \ связывает эту строку со следующей.
  Директивы препроцессора длятся до перевода строки.
  Чтобы писать многострочные макросы, нужно ставить \ в конце каждой строки, кроме последней.
3) #cond --- заменяется на текст аргумента cond, заключённый в двойные кавычки.
    cond --- заменяется на текст аргумента без кавычек
4) AssertionFailed --- какая-то функция, которую нам надо объявить/определить.
  Обычно выводит что-то вроде: Assertion failed [sizeof(int) == 8] at C:\programs\test.c:45
5) __FILE__ и __LINE__ --- специальные встроенные макросы, которые заменяются на имя текущего файла и текущую строку в нём.
  Естественно, имеется ввиду строка, в которой написан раскрываемый макрос.

Всякие ((void)0) и else добавлены, чтобы решить возникающие иначе проблемы при использовании assert внутри однострочного if/else.
Ещё есть альтернативный вариант: do{}while(0)

Многие макросы определяются "извне" и доступны с самого начала единицы трансляции:
1) Встроенные макросы:
  __GNUC___     --- определяется на GCC
  _MSC_VER      --- определяется на MSVC: значение показывает, какая версия компилятора
  __FILE__, __LINE__ --- специальные макросы (см. выше)
  также есть макросы для определения платформы, настроек компиляции и пр.
2) Кастомные макросы.
  Можно определять макросы в командной строке. Например, определяем BITNESS со значением 64 и пустой NDEBUG:
    gcc my.c -O2 -D NDEBUG -D BITNESS=64
    cl my.c /O2 /D NDEBUG /D BITNESS=64
  В проекте Visual C++ также можно прописать дополнительные макросы.
  Кликаем правой кнопкой на проект -> Properties: C/C++ -> Preprocessor -> Preprocessor Definitions  (макросы разделяются точкой с запятой)


========================= Хедеры ===========================

Проблема: функции, глобальные переменные и структуры надо объявлять в каждой единице трансляции, где они нужны.
Если в проекте >100 единиц трансляции, то это безумное дублирование кода!
Это не только неудобно, но и очень багоопасно, ведь линкер почти ничего не проверяет.

Ещё одна директива препроцессора:
  #include <stdio.h>                //угловые скобки для стандартных библиотек C
  #include "mycoolheader.h"         //кавычки для собственных хедеров
вставляет содержимое заданного файла в текст программы вместо директивы.
Вставляемые файлы обычно называют header (заголовочный файл), им дают расширение ".h" (хотя расширение значения не имеет).
Внутри могут быть вложенные #include.

Как компилятор находит хедер?
Обычно он смотрит относительно той же директории + в заданных include paths.
Если использовать угловые скобки <...> вместо кавычек, то в текущей директории компилятор НЕ смотрит.
Заметим, что можно внутри include писать относительный путь к хедеру (можно и абсолютный, но лучше не надо).

Чтобы прописать include path:
  В консоли:
    gcc my.c -I ../../lib/header        // в include paths
    cl my.c /I ..\..\lib\header         //добавить относительный путь
  В проекте MSVC:
    project properties: C/C++ -> General -> Additional Include Directories

Идея: давайте вынесем в хедеры все объявления, а в исходных файлах ("*.c") будем их подключать по мере необходимости.

Пример:
== sum.h ==
    int sum(int n, const int *arr);      //объявление
    
== sum.c ==
    #include "sum.h"                     //подключаем хедер  (чтобы быть уверенным, что в sum.h и sum.c одинаковая сигнатура sum)
    int sum(int n, const int *arr) {     //определение
        // ...
    }

== main.c ==
    #include "sum.h"                     //подключаем хедер  (чтобы компилятор знал сигнатуру sum)
    int main() {
        // ...
        int res = sum(n, a);             //использование
        // ...
    }

Чаще всего в хедерах нужно подключать другие хедеры (например для объявления структур).
Проблема:
== a.h ==
    #include "b.h"
    // ...
    
== b.h ==
    #include "a.h"
    // ...

В данном случае если включить a.h или b.h, то препроцессор зайдёт в бесконечным цикл вставки этих хередов.
Кроме того, часто используемый хедер может быть вставлен в одну единицу трансляции много раз --- тоже нехорошо.

Чтобы решить проблему, в хедере обязательно пишут "include guard" (страж включения).
Два варианта стража:

1) Используя стандартные средства препроцессора:
== sum.h ==
    #ifndef SUM_H_749837
    #define SUM_H_749837
    // ... (содержимое хедера)
    #endif

  Видно, что макрос SUM_H_749837 после первой вставки станет определён,
  поэтому все другие вставки в данном TU будут выброшены.

2) Используя нестандартную директиву (работает в большинстве компиляторов):
== sum.h ==
    #pragma once
    // ... (содержимое хедера)

  Компилятор сам запоминает включенные файлы, и не включает их дважды.
  Заметим, что #pragma --- это нестандартная директива компилятора.
  (и видимо никогда стандартной не станет из-за того, что разные пути могут указывать на один файл).

Общепринятая практика работы с несколькими файлами в С:
1) Файлы пишут парами: исходный код (.c) / хедер (.h)
2) В хедере обязательно есть страж включения.
3) В хедер выносят ОБЪЯВЛЕНИЯ (структуры, типы, функции, глоб. переменные) всего, что хочется использовать в других единицах трансляции.
4) В исходный файл помещают ОПРЕДЕЛЕНИЯ всего объявленного в хедере + все вещи, являющиеся "приватными" для единицы трансляции (не хочется видеть извне).
Иногда несколько хедеров объединяют в один.


==================== Приватные символы =====================

Даже если глобальная переменная или функция не объявлена в хедере, её всегда можно объявить вручную и использовать в другом TU.
Кроме того, короткие имена могут случайно совпасть в разных единицах трансляции.
Чтобы избежать всего этого, можно сделать символ "приватным" для TU --- тогда нельзя будет использовать его из другой TU.

Для этого в C есть ключевое слово static:
    static int arr[10000];
    static int sum(int n, const int *arr) {
        // ...
    }

Определение, помеченное как static, можно использовать только из текущей единицы трансляции.

Замечание: static определения можно писать в хедере,
правда тогда в каждой единице трансляции будет РАЗНАЯ переменная/функция --- по сути дубликаты.

Пример:
== module.h ==
    #pragma once
    void publicFn();

== module.c ==
    #include "module.h"
    #include <stdio.h>
    static void privateFn(int calledByPublic) {
        printf(
            "%s says: Hi!\n",
            calledByPublic ? "Public" : "Private"
        );
    }
    void publicFn() {
        privateFn(1);
    }

== main.c ==
    #include "module.h"
    void privateFn(int); // сами написали объявление функции privateFn, чтобы попытаться её вызвать из main.c
    int main() {
        publicFn();   // Напечатает "Public says: Hi!"
        privateFn(0); // Не слинкуется из-за static, этого мы как раз и добивалсь:
                      // privateFn может быть вызвана только из publicFn
                      // (или других функций в module.c, но не из main.c)
        return 0;
    }


===================== vararg-функции ======================

В C можно сделать функцию, которая принимает изменяемое/произвольное количество параметров.
Примеры: printf/scanf и подобные.

Чтобы такую функцию объявить/определить, надо в сигнатуре написать три точки в конце списка параметров:
    int printf(const char *format, ...);
    int scanf(const char *format, ...);

При вызове такой функции все параметры складываются на стек (call stack) и вызывается функция.
Компилятор в месте вызова может даже не видеть, что делает эта функция внутри.
Поэтому он принимает какие угодно параметры в любом количестве.

Функция знает, где начинаются её параметры (и где расположены именованные параметры), и где заканчиваются.
Однако про параметры из ... она не знает ни их количества, ни типа --- это просто массив байтов на стеке.
Поэтому чтобы использовать эти параметры, информацию о количестве и типах нужно передать в первые (именованные) параметры.
Например, в scanf/printf format содержит %d/%s/%f, указывающие на тип аргументов.
Заметим, что компилятор внутри функции понятия не имеет, кто и откуда её позвал, и что в аргументы положил.

Параметры функции извлекаются со стека с помощью специальной конструкции:
переменная типа va_list --- это своеобразный мини-бинарный файл на стеке
из него можно читать параметры с помощью va_arg, указывая их тип.

Пример:
    #include <stdarg.h>               //необходимо подключить, чтобы использовать va_list
    int sum(int n, ...) {
        va_list ap;
        va_start(ap, n);              //открываем va_list: надо написать имя последнего именованного параметра вторым аргументом
        int res = 0;
        for (int i = 0; i < n; i++)
            res += va_arg(ap, int);   //читаем со стека int
        va_end(ap);                   //закрываем va_list
        return res;
    }

Разумеется, в качестве второго параметра va_arg можно использовать другие типы: double, const char *, и пр.
Если передать на стек не то (например double или int64_t в примере выше), то случится что-то плохое.

Ограничение: внутри vararg-функции нельзя вызвать другую vararg-функцию, передав туда va_list.
Потому что это уже один параметр типа va_list, а не список параметр разных типов.
Вместо этого можно вызывать функцию, принимающую параметр типа va_list:
    int mysum(int n, ...) {
        va_list ap;
        va_start(ap, n);
        //int res = mysum(n, ap);   //так НЕ работает!
        int res = vmysum(n, ap);    //так работает, см. vmysum ниже
        va_end(ap);
    }
    int vmysum(int n, va_list ap) {
        int res = 0;
        for (int i = 0; i < n; i++)
            res += va_arg(ap, int);
        return res;
    }

ВАЖНО: для всех printf/scanf функций из stdio.h есть эквивалент, принимающий va_list!
    int vprintf(const char *format, va_list ap);
    int vscanf(const char *format, va_list ap);
    int vsprintf(char *buffer, const char *format, va_list ap);
    int vsscanf(char *buffer, const char *format, va_list ap);
    (и т.п.)
Это очень полезно для написания собственного логгирования.
Можно в собственной функции делать что хочется, а потом все аргументы и строку форматирования просто передавать в vfprintf, например.

Собственные функции с переменным количеством аргументов обычно тоже пишут парами: функция, принимающая va_list, и vararg-обёртка над ней.

Техничаская деталь: переменные в va_list помещаются с выравниванием в 4 байта,
поэтому всё, что меньше int (char, short) нужно всё равно извлекать с помощью va_arg как int:
    char c = (char) va_arg(ap, int);

================= Статическая библиотека ==================

>>> Статическая библиотека = набор объёктных файлов (архив, примерно как .tar)

Чтобы собрать статическую библиотеку (name.a для GCC, name.lib для MSVC), надо объёдинить объектные файлы (file.o для GCC, file.obj для MSVC).

Создание библиотеки выполняется отдельной программой:
  GCC:
    ar rcs arithm.a sum.o diff.o
    (значение флагов: r - insert files into archive, c - create archive, s - add archive index)
  MSVC:
    lib sum.obj diff.obj /out:arithm.lib
    (если компилятор cl.exe виден в консоли, то и lib.exe тоже видна)

Чтобы использовать библиотеку, надо добавить её в линковку.
При этом линкер будет использовать все запакованные в неё объектные файлы.
  GCC:
    gcc -O2  main.c   arithm.a              //ищет только в текущей директории
    gcc -O2  main.c   -l:arithm.a           //ищет только в library path (см. ниже)
  MSVC:
    cl /O2   main.c   arithm.lib

Чтобы нормально использовать статическую библиотеку, кроме самого файла библиотеки
нужны также хедеры, в которых прописаны объявления доступных символов.
Если точнее: нужны "публичные" хедеры --- содержащие необходимые пользователю объявления.
В коде библиотеки также могут быть "приватные" хедеры --- они пользователю не нужны.

При подключении надо:
1) настроить include path (чтобы хедеры библиотеки были видны)
2) добавить .a/.lib-файл на вход линкеру
3) настроить пути поиска библиотек линкером

Как настраивать пути в командной строке:
  include path (было раньше):
    GCC:   gcc     -I my/include/path
    MSVC:  cl      /I my/include/path
  library path (новое):
    GCC:   gcc     -L my/library/path                   //ВАЖНО: работает только при подключении типа "-l:mylib.a"
    MSVC:  cl      /link/libpath:my/library/path        //ВАЖНО: лучше писать в КОНЦЕ командной строки

Полный сценарий:

 Создание стат. библиотеки:                     Использование стат. библиотеки:
1) Компилируем всё, НЕ линкуем                 1) Кладём .a/.lib-файл и хедеры куда хотим
2) Собираем файл библиотеки (ar/lib)           2) Включаем эти хедеры в своих TU             
3) Определяем публичные хедеры                    Используем там всякие функции из библиотеки
4) Выдаём пользователю:                        2a) Возможно правим include paths, 
     .a/.lib-файл                                  чтобы хедеры находил компилятор
     публичные хедеры                          3) Добавляем .a/.lib-файл на вход линкеру
                                               3a) Возможно правим library paths

Тонкий вопрос: будет ли .a/.lib работать при линковке на других машине/компиляторе/версии/настройках?
Это вопрос о бинарной совместимости объектных файлов --- надо смотреть, что гарантирует конкретный компилятор.
(пример: на MSVC для языка C++ чаще всего НЕ совместимы .obj-файлы Debug/Release)

>>> Сборка программы или библиотеки скриптом:
    Linux/Unix - shell/bash: .sh
    Windows - batch: .bat, .cmd

В обеих системах есть скриптовый язык.
В простейших случаях скрипт --- это последовательность команд, которые надо по очереди запустить в консоли.
Такой скрипт работает одинаково и в batch, и в shell.
Разумеется, в скриптах есть более сложные возможности: if-ы, циклы, проверка кода возврата и т.п.

Пример простого скрипта (содержимое build.bat):
  cl min.c max.c array.c /O2 /c
  cl megacode.c /c
  cl min.obj max.obj array.obj megacode.obj /Fe"MyCoolProgram.exe"
Скрипт можно запустить так же, как любую обычную программу.

Где какие настройки искать в Visual Studio:
    Собирать статическую библиотеку: Project properties: General -> Configuration Type := Static library
    Имя результата сборки (lib/exe-файла): Project properties: General -> Target Name
    В какую директорию выдавать результат сборки: Project properties: General -> Output Directory
    Добавить второй проект к солюшену: Solution Explorer: Solution 'mymymy.sln' -> Add -> New Project
    Настроить include path: Project properties: C/C++ -> General -> Additional Include Directories
    Добавить в линковку статические библиотеки: Project properties: Linker -> Input -> Additional Dependencies
    Настроить library paths: Project properties: Linker -> General -> Additional Library Directories
    Выбрать проект, который надо запускать: Project -> Set as Startup Project


======================= X-макросы ======================

Мотивация: есть структура, в ней много полей.
Хочется, чтобы можно было делать однотипные действия для каждого поля, например, все распечатать или прочитать.

Проблема в том, что список полей необходимо писать неколько раз:
  - При описании полей в объявлении структуры
  - В коде печати
  - В коде чтения
  - ...
Естественно, если список полей часто меняется, высока вероятность добавить поле, но забыть добавить его обработку в одну из подобных функций.

Решение --- использовать макрос-функцию, которая принимает как аргумент другую макро-функцию (X-макрос).
Получается некоторое "функциональное программирование на препроцессоре".
В определении макроса список всех параметров, где вся информация о каждом параметре передаётся в X-макрос.
Пример:

// Список параметров, описан как _(тип, имя); впоследствии каждое поле мы будем обрабатывать определяя макрос _(Type, field):
    #define PERSON_FIELDS \
        _(str, name) \
        _(int, age) \

// Объявление структуры:
    typedef struct Person {
        #define _(Type, field) \
            Type field;
        PERSON_FIELDS
        #undef _
    } Person;

// Функция, обрабатывающая структуру:
    void printPerson(const Person* person) { 
        #define _(Type, field) \
            printf("%s: ", #field); \
            print##Type(person->field); \
            printf("\n");
        PERSON_FIELDS
        #undef _
    }

Теперь при добавлении нового поля, или редактировании/удалении существующего изменения достаточно сделать в одном месте - макросе PERSON_FIELDS.


===================== Псевдошаблоны ====================

Псевдошаблон --- аналог template из C++.

Мотивация: можно один раз написать структуру данных (растущий массив/список/очередь/стек/хэш-таблицу/дерево/что-то ещё)
общего вида, то есть не указывая какого конкретно типа её элементы,
затем будем генерировать версии такой структуры, заточенные под работу с конкретными типами данных, избегая дублирования общего кода.

Рассмотрим пример: шаблон односвязного списка:
    #include <stdio.h>
    #include <stdlib.h>
    typedef char* str; // Нужен псевдоним, чтобы было навание типа безо всяких звёздочек

    // макрос LIST принимает в качестве аргумента тип, который будут содержать элементы списка.
    // Он определит структуру с именем List_<тип>, а также функцию visitList_<тип>, которая позволяет по списку итерироваться:
    #define LIST(T) \
    typedef struct List_##T { \
        T val; \
        struct List_##T* next; \
    } List_##T; \
    \
    void visitList_##T(List_##T* list, void (*fn)(T)) { \
        for ( ; list != NULL; list = list->next) { \
            fn(list->val); \
        } \
    } \

    // Просто функции, печатающие значения указанных типов данных:
    void print_int(int v) { printf("%d\n", v); }
    void print_str(str s) { printf("%s\n", s); }

    // Макрос вставки элемена для удобного создания списков:
    #define PUSH(T, list, newVal) \
        do { \
            List_##T *newElem = (List_##T*) malloc( sizeof(List_##T) ); \
            newElem->val = newVal; \
            newElem->next = list; \
            list = newElem; \
        } while (0) \

    // Хотим, чтобы были два конкретных варианта списка: список интов и список строк:
    LIST(int)
    LIST(str)

    // Создадим и распечатаем два списка, содержащих разные типы:
    int main() {
        List_int* list_i = NULL;
        for (int i = 0; i < 5; ++i)
            PUSH(int, list_i, i);
        
        List_str* list_s = NULL;
        PUSH(str, list_s, "Hello");
        PUSH(str, list_s, "world");
        
        visitList_int(list_i, print_int);
        visitList_str(list_s, print_str);
        return 0;
    }
    
Упражнение: попробуйте модифицировать макрос LIST, чтобы он объявлял функцию для удаления списка, и с помощью этой функции освободите память в конце.
