==================== Расстановка ферзей ====================

Задача: есть шахматное поле, нужно расставить 8 ферзей так, чтобы они не били друг друга.
Решаем на поле N x N, расставляем N ферзей.

Критерий: ферзь в клетке (r0, c0) бьёт клетку (r, c), если верно одно из условий:
  r = r0
  c = c0
  r+c = r0+c0
  r-c = r0-c0

Очевидно, надо поставить в каждой строке по одному ферзю.
Тогда решение можно представить как последовательность col[0], col[1], col[2], ..., col[N-1],
где сol[r] --- номер столбца, в котором стоит ферзь в r-ой строке.

Как можно сгенерировать любой вариант:
  for r = 0..N-1:
    choose col[r] in {0, 1, 2, ..., N-1}        // можно брать любое число из множества
    put queen at cell (r, col[r])
  check solution col[]

Здесь choose даёт неопределённость: по идее нужно перебрать ВСЕ варианты.
Естественно, еслит перебрать все N вариантов при r = 0, то для каждого из них надо перебрать N вариантов при r = 1, и так далее.
Получается дерево вариантов, которые надо перебрать:

                       c1=0    /
                       -----[o]-  ...
              с0=0    /c1=1    =
             ------[o]------[o]-
            /         \c1=2    =
           /           -----[o]-  ...
          /            c1=0    =
         /             -----[o]-
        /    с0=1     /c1=1    =
     [o]-----------[o]------[o]-  ...
        \             \c1=2    =
 (empty) \             -----[o]-
          \            c1=0    =
           \           -----[o]-  ...
            \ с0=2    /c1=1    =
             ------[o]------[o]-
                      \c1=2    =
                       -----[o]-  ...
                               \

Рекурсивный перебор ("перебор с возвратом"):
  int col[N];                       // текущее решение храним глобально
  void Rec(int r) {                 // (перебирает все варианты для col начиная с r-ого)
    if (r == N) {                   // в этом случае все строки пройдены, получено решение
      checkSolution(col);
      return;                       // дальше перебирать уже некуда
    }
    for (int c = 0; c < N; c++) {   // пробуем все возможные варианты c = col[r]
        col[r] = c;
        Rec(r+1);                   // рекурсивно перебираем все варианты для col[i] при i >= r+1
        col[r] = -1;                // (на всякий случай затираем поставленное число)
    }
  }
  int main() {
    ...
    Rec(0);                         // запускаем полный перебор
    ...
  }

Время работы: O(N^N * N^2)
  (при N = 8: 8^8 = 2^24 = 16 M, плюс ещё 8^2 на проверку --- небыстро)

Программа перебирает решения (массив col) так:

 0                // r=1
 0 0              // r=2
 0 0 0            // r=3
 0 0 0 0          // r=4
 0 0 0 0 0        // r=5
 0 0 0 0 0 0      // r=6
 0 0 0 0 0 0 0    // r=7
 0 0 0 0 0 0 0 0  // r=8 checkSolution: col[0] = col[1] --- плохо
 0 0 0 0 0 0 0 1  // r=8 checkSolution: col[0] = col[1] --- плохо
 0 0 0 0 0 0 0 2  // r=8 checkSolution: col[0] = col[1] --- плохо
 0 0 0 0 0 0 0 3  // r=8 checkSolution: col[0] = col[1] --- плохо
 0 0 0 0 0 0 0 4  // r=8 checkSolution: col[0] = col[1] --- плохо
 0 0 0 0 0 0 0 5  // r=8 checkSolution: col[0] = col[1] --- плохо
 0 0 0 0 0 0 0 6  // r=8 checkSolution: col[0] = col[1] --- плохо
 0 0 0 0 0 0 0 7  // r=8 checkSolution: col[0] = col[1] --- плохо
 0 0 0 0 0 0 1    // r=7
 0 0 0 0 0 0 1 0  // r=8 checkSolution: col[0] = col[1] --- плохо
 ...
 0 0 0 0 0 0 1 7  // r=8 checkSolution: col[0] = col[1] --- плохо
 0 0 0 0 0 0 2    // r=7
 ...                         (все варианты плохие, т.к. col[0] = col[1])
 0 0 0 0 0 0 7    // r=7
 0 0 0 0 0 1      // r=6
 ...
 0 1              // r=2
 ...

Получается, что все решения будут отвергаться из-за col[0] = col[1] до тех пор, пока col[1] не будет изменено с 0 на 1.

Отсечение --- удаление заведомо бесполезной ветви в рекурсивном переборе.
В данном случае всю ветвь с col[0] = col[1] = 0 можно было заметить сразу при установке col[1] = 0 и не перебирать.

Идея отсечения: будем проверять сразу при установке ферзя, бьёт его кто-то или нет.
Если бьёт, то всю ветку можно полностью отсечь: от позиций остальных ферзей ничего уже не зависит.

Реализация: будем хранить и поддерживать в ходе перебора:
  занята ли каждая вертикаль  hasV[c]
  занята ли каждая диагональ  hasS[r+c]
                              hasD[r-c]
Нужно обновлять эту информацию при установке ферзя,
и откатывать изменения при выходе из рекурсии.

Код:
  int col[N];
  int hasV[n], hasS[2N], hasD[-N..N];

  void Rec(int r) {
    if (r == N) {
      print(col);                       // нашли решение --- печатаем его
      return;                           // проверять решение НЕ надо, т.к. все проверки на "бьёт" выполнены ранее в отсечениях
    }

    for (int c = 0; c < N; c++) {
      if (hasV[c] || hasS[r+c] || hasD[r-c])    // отсечение: если вертикаль или диагонали уже бьются
        continue;                               //           тогда ставить ферзя НЕ будем

      col[r] = c;                               // ставим ферзя в клетку
      hasV[c] = hasS[r+c] = hasD[r-c] = 1;      // обновляем глобальное состояние

      Rec(r+1);                                 // запускаем перебор всех вариантов для r+1 и последующих строк

      hasV[c] = hasS[r+c] = hasD[r-c] = 0;      // откатываем изменения, возвращая в точности состояние до установки ферзя
      col[r] = c                                // (мы уверены, что hasX[?] все имели значение 0 до того, как мы записали туда 1)
    }
  }

Время работы = ?
  Если включить только отсечение по вертикали, то очевидно будут перебираться только перестановки: в col[] будут все индексы от 0 до N-1 ровно по одному разу.
  Значит время работы будет порядка O(N!).
  При N=8: N^N = 16 M
           N!  = 40 K --- быстрее в 400 раз, даже без отсечения по диагоналям!
  С отсечениями по диагоналям должно работать ещё быстрее.
Точная асимптотическая оценка времени работы для перебора с отсечениями --- дело сложное.


====================== Число разбиений ======================

17 = 1 + 5 + 3 + 1 + 7   --- разбиение числа 17 на слагаемые
Если разбиения отличаются только порядком слагаемых, то они считаются одинаковыми: 1 + 5 + 3 + 1 + 7  и  1 + 1 + 3 + 5 + 7  --- это одно разбиение.
Требуется найти количество всех различных разбиений заданного числа N.

Замечание: будем искать только невозрастающие последовательности слагаемых.
Тогда каждое разбиение будет задаваться только одной последовательностью, а мы как раз последовательности и будем считать.

Пример (N = 5):
  5 = 1 + 1 + 1 + 1 + 1
  5 = 2 + 1 + 1 + 1
  5 = 2 + 2 + 1
  5 = 3 + 1 + 1
  5 = 3 + 2
  5 = 4 + 1
  5 = 5

Будем строить разбиения, добавляя по одному числу в последовательность:
  Sum = 0                // на какую сумму числа уже выписали --- чтобы в общем получилось N
  Last = N               // все последующие числа должны быть не более Last --- чтобы было неубывание
  while Sum < N:
    choose x in {1, 2, 3, ..., min(Last, N-Sum)}  // выбираем очередное число (ВАЖНО: здесь верхняя граница точная)
    add x to sequence
    Sum += x                                      // общая сумма увеличивается на новое число x
    Last = x                                      // все последующие числа должны быть не больше данного числа x

На основе этого можно написать рекурсивный перебор:
  void Rec(int Sum, int Last) {                 // числа Sum и Last передаём в рекурсию
    if (Sum == N) {
      Answer++;                                 // Sum = N --- конец перебора (построили разбиение)
      return;                                   // просто прибавляем 1 к глобальному счётчику
    }
    for (int x = 1; x <= min(Last, N-Sum); x++) {   // перебираем все допустимые x
      Rec(Sum+x, x);                            // запускаем перебор хвоста последовательности
    }
  }

Время работы: O(A), где A --- ответ (число разбиений)
Интересный факт:
  A ~= 1 / (4 sqrt(3) N) * exp(pi * sqrt(2*N/3))    при больших N
(при N > 100 это очень много)
Источник:
  https://en.wikipedia.org/wiki/Partition_function_(number_theory)#Approximation_formulas

Заметим, наш перебор почти "чистый", то есть он не зависит от глобальных переменных (увеличение Answer --- единственное исключение).
Значит если в ходе перебора запускается Rec(Sum=17, Last=10) два раза, то оба раза перебор обходит одинаковые поддеревья и прибавляет к Answer одинаковое dA.
Было бы неплохо вычислять это dA только один раз для конкретных Sum, Last, а потом использовать уже вычисленный результат.

Сделаем перебор полностью чистым: пусть он возвращает dA как return value, а глобальную переменную Answer уберём.
Все результаты будем запоминать в двойном массиве memo.
  int memo[N][N];
  int Rec(int Sum, int Last) {
    if (memo[Sum][Last] == -1) {                // -1 в memo означает, что значение ещё не вычислено
      int res = 0;
      if (Sum == N)
        res = 1;                                // разбиение построено: один вариант
      else {
        for (int x = 1; x <= min(Last, N-Sum); x++)  // перебираем все допустимые x
          res += Rec(Sum+x, x);                 // запускаем перебор хвоста последовательности
      }
      memo[Sum][Last] = res;                    // запоминаем результат в memo
    }
    return memo[Sum][Last];                     // возвращаем запомненный результат
  }

Это называется: перебор "с мемоизацией".

Время работы:
1) Для конкретных значений Sum и Last вычисление происходит максимум один раз.
2) Код вычисления работает за O(N) --- цикл по x.
Получается время работы O(N^3) --- намного меньше, чем exp(sqrt(N)).


Теперь построим решение методом "динамического программирования".
Сначала определим, что именно возвращает Rec(Sum, Last):
  R[Sum, Last] = количество неубывающих последовательностей (хвостов), таких что:
               1) все числа не превышают Last
               2) сумма чисел равна N - Sum
Внутри Rec написан код, который вычисляет R[Sum, Last] через R[*, *] для других параметров.
Можно переписать его в виде явной формулы (просто смотрим, как вычисляет res код, или думаем), получится:
  (база) R[Sum, Last] = 1                           при Sum = N

                      min(Last, N-Sum)
  (инд)  R[Sum, Last] =  ___SUM___ R[Sum + x, x]    при Sum != N
                           x = 1

Это называется "рекуррентной формулой", т.к. значение R[Sum, Last] зависит только от R[S, L] для S > Sum (т.е. только от "предыдущих значений").
Очевидно, что все значения R[*, *] можно посчитать по этой формуле, если перебирать в порядке уменьшения Sum.

Получается код:
  int res[N][N];
  for (int Sum = N; Sum >= 0; Sum--) {
    for (int Last = 0; Last <= N; Last++) {
      if (Sum == N) {
        res[Sum][Last] = 1;
      }
      else {
        res[Sum][Last] = 0;
        for (int x = 1; x <= min(Last, N-Sum); x++)
          res[Sum][Last] += res[Sum+x][x];
      }
    }
  }
Это работает за O(N^3).

Подобное решение называется решением методом динамического программирования.
Оно работает очень похоже на перебор с мемоизацией, только:
1) В ДП можно обойти все состояния простыми циклами, в переборе нужна рекурсия.
2) В ДП нужно определить порядок вычисления ответов, перебор с мемоизацией определяет его самостоятельно (естественно, циклических зависимостей быть не должно).
3) В ДП вычисляются все ответы, а в переборе с мемоизацией только те, которые реально нужны.
Поэтому перебор с мемоизацией иногда называют "ленивым динамическим программированием".


===================== Задача о рюкзаке ======================

Есть N предметов, у каждого вес w[i] и стоимость c[i].
Есть рюкзак, который выдерживает максимальный вес Wmax (вместимость рюкзака).
Нужно решить, какие предметы взять, так чтобы:
  1) они входили в рюкзак (суммарный вес не больше вместимости)
  2) их стоимость была максимально возможной

Можно построить любое решение, перебирая предметы по очереди:
  sumW = 0, sumC = 0
  for k = 0..N-1:
    choose Xk in {take, skip}           // выбираем: взять k-ый предмет или нет
    if Xk = take and sumW + w[k] <= Wmax:
      take k-th item
      sumW += w[k]
      sumC += c[k]
  choose solution with sumC -> max

Это можно превратить в рекурсивный перебор.
Попробуем сделать рекурсивную функцию "чистой":
1) Заметим, что в переборе нужна информация о параметрах:
     k --- количество предметов, которые мы просмотрел
     sumW --- суммарный вес выбранных предметов среди них
     sumC --- суммарная стоимость выбранных предметов
2) Допустим, среди оставшихся N-k предметов мы наберём на стоимость addC.
  Тогда общая стоимость будет sumC + addC, и sumC больше ни на что не влияет.
  Пусть тогда перебор возвращает оптимальное значение addC как return value.

Код:
  int Rec(int k, int sumW) {
    if (k == N)
      return 0;                             // предметов не осталось => общая стоимость остатка нулевая

    int Cskip = Rec(k+1, sumW);             // пробуем не брать k-ый предмет, определяем

    if (sumW + w[k] <= Wmax) {                  // брать предмет можно, только если он входит в рюкзак
      int Ctake = Rec(k+1, sumW + w[k]) + c[k]; // если предмет возьмём, то надо выбрать оптимальный набор среди
                                                // оставшихся предметов (начиная с k+1-ого), и не забываем
                                                // добавить стоимость k-ого предмета
    }

    return max(Cskip, Ctake);
  }
    
Получается перебор за O(2^N) --- на каждом из N шагов два варианта выбора.

Пусть веса w[i], W целые, и не превышают какого-то числа (например 10000).
Тогда среди перебираемых вариантов sumW будет целым и не более W, а значит будет часто совпадать.

Добавим мемоизацию в перебор:
  memo[k][sumW] --- значение Rec(k, sumW)
Время работы будет O(N W), т.к. столько элементов в memo, и для вычисления каждого нужно O(1) действий.


Как восстанавливать решение (т.е. какие предметы надо брать) ?
Примерно так же, как это делалось в алгоритмах поиска кратчайшего пути в графе.
Нужно запоминать для каждого состояния (k, sumW), какой выбор в нём оптимальный.

То есть когда мы брали максимум в строке:
    return max(Cskip, Ctake);
Нужно записать F[k, sumW] := take, если Ctake был больше, и записать skip иначе.

То есть:
  F[k, sumW] in {take, skip} --- как был получен оптимальный ответ для R[k, sumW]
                                 нужно ли брать k-ый предмет для оптимальности решения?

Заметим, что F[k, sumW] следует запоминать в тот же момент, когда мы вычисляем Rec(k, sumW).
Это легко сделать и для перебора с мемоизацией, и для динамического программирования.

Зная F для всех состояний, можно проследить, как менялось состояние по предметам:
  (0, 0)  -------------->  (1, w[0])  -------------->  (2, w[0])  -------------->  (3, w[0]+w[2])  ---> ...
            F[0,0]=take               F[1,w[0]]=skip              F[2,w[0]]=take                 


===================================================
Дополнительный материал (знать НЕ нужно).

Задача о рюкзаке: Можно определить точно, что хранится в memo:
  R[k, sumW] --- максимальная стоимость предметов, выбранных среди
                 предметов с номерами {k, k+1, k+2, ..., N-1},
                 суммарным весом не более (Wmax - sumW).

Тогда можно написать рекуррентную формулу, посмотрев на код Rec:

  R[k, sumW] = 0     (при k = N)

  R[k, sumW] = min( R[k+1, sumW], R[k+1, sumW+w[k]] + c[k] )
                                  (второй вариант есть только при sumW + w[k] <= Wmax)

Значит можно решить задачу простым динамическим программированием без рекурсии,
если перебирать состояния (k, sumW) в порядке уменьшения k и вычислять ответы по этой формуле.
