======================= Хеширование =======================

>>> Хеш-функция:
  chi: K -> {0, 1, ..., m-1}      (функция)
Здесь:
  K --- множество ключей (например, 32-битные числа или строки)
  m --- размер выходного диапазона (обычно степень двойки или простое число)
Возвращаемое значение хеш-функции для конкретного ключа называется "хешом" этого ключа.
Например, если chi("hello") = 735, то у ключа "hello" будет хеш 735.

1) Хеш-функция должна быть детерминированной (про повторном вызове для того же ключа возвращает тот же хеш):
     a = b => chi(a) = chi(b)
2) Если посмотреть на хеши для любого набора из N различных ключей, то они должны "выглядеть" примерно как последовательность случайных чисел от 0 до m-1:
     chi(x[0]), chi(x[1]), chi(x[2]), ..., chi(x[n-1])  должны распределяться по диапазону {0, ..., m-1} примерно равномерно, и "как бы случайно".

Требование 2 иногда называют "гипотеза случайного равномерного хеширования".
Его не получится определить формально, т.к. как и в случае генераторов псевдослучайных чисел, все хеши строго детерминированные и никакой случайности тут нет.
При использовании этой гипотезы становится возможно теоретически оценивать время работы и прочие величины в алгоритмах хеширования.
При применении хорошей хеш-функции на практике результаты будут очень похожи на те, которые можно предсказать теоретически с помощью этой гипотезы.

Зачем нужны хеш-функции?...

>>> Хеш-таблица.

Заведём массив из m ячеек --- "хеш-таблицу".
Будем хранить элемент с ключом k в ячейке массива под номером chi(k).

Получаем реализацию множества, которая поддерживает операции:
  Добавить элемент X в множество:
    add(X):    T[chi(X.key)] = x
  Найти элемент с ключом K в множестве:
    find(K):   return T[chi(K)]
  Удалить элемент с ключом K из множества:
    delete(K): T[chi(K)] = null
Таким образом все операции легко делаются за O(1), при условии что хеши различных ключей не совпадают.
К сожалению, в реальности нельзя надеяться, что совпадающих хешей не будет.

>>> Коллизии.

Ситуация, когда ключи различны (a != b), но хеши совпадают (chi(a) = chi(b)), называется "коллизией".
Обычно множество ключей K по размеру очень велико, а выходной диапазон m мал, так что коллизии всегда можно найти по принципу Дирихле, если захотеть.
На самом деле, даже если не хотеть, почти наверное они всё равно встретятся.

Допустим, в хеш-таблицу размера m добавляют n различных ключей, при этом хеш-функция хорошая, так что получаемые хеши можно считать случайными.
Можно ли надеяться, что все хеши будут различными (т.е. не будет ни одной коллизии) ?

>> "Парадокс дней рождения":
  Если в классе есть 40 студентов, то скорее всего найдутся двое, родившихся в один и тот же день+месяц (в году 365 дней).

Оцениваем вероятность того, что n случайных чисел от в диапазоне 0 до m-1 будут полностью различными:
  P = m/m * (m-1)/m * (m-2)/m * (m-3)/m * ...  * (m-n+1)/m = 1 * (1 - 1/m) * (1 - 2/m) * ... * (1 - (n-1)/m)
Заметим, что при 0 < x < 1 верно exp(-x) > 1 - x    (более того, эти числа очень близки).
Тогда:
  P < exp(-0) * exp(-1/m) * exp(-2/m) * ... * exp(-(n-1)/m) = exp(- n*(n-1) / (2*m))
Т.е. вероятность отсутствия коллизий примерно равна exp(-K) для K = n^2 / (2*m)    (а на самом деле даже меньше).
Примеры:
  n = 40, m = 365:     K = 40^2 / (2 * 365) = 2.19    =>   P <= exp(-2.19) = 11%
  n = 50, m = 365:     K = 50^2 / (2 * 365) = 3.42    =>   P <= exp(-3.42) = 3.2%
  n = 10^6, m = 10^9:  K = 10^12 / (2 * 10^9) = 500   =>   P <= exp(-500) < 10 ^ -217
Получается, что:
  n >> sqrt(m)    =>   коллизии почти наверное есть, глупо надеяться что их нет
  n << sqrt(m)    =>   коллизий скорее всего нет, можно на это надеяться, но полагаться всё равно опасно

Таким образом, на практике нельзя игнорировать коллизии.
Если хочется записать n = 10^6 элементов в таблицу, то нужно m >> 10^12 ячеек в таблице, чтобы не было коллизий с заметной вероятностью.
Из-за парадокса дней рождения требуется m >> n^2 ячеек в таблице, чтобы не было коллизий, и это обычно неприемлемо.

>>> Разрешение коллизий.

Таким образом, при реализации хеш-таблицы необходимо обрабатывать коллизии.
Есть две известных стратегии разрешения коллизий.

I) Разрешение коллизий цепочками (separate chaining).

Будем хранить в каждой ячейке j таблицы не один элемент, а набор всех элементов, для которых хеш равен j.
Этот набор можно записывать по-разному, но чаще всего для хранения используют связный список (отсюда название стратегии).

Картинка:

   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
   | . |   |   |   | . |   |   | . | . |   |   |   |   | . |   |   |
   +-|-+---+---+---+-|-+---+---+-|-+-|-+---+---+---+---+-|-+---+---+
     V               V           V   V                   V 
    +-+             +-+         +-+ +-+                 +-+
    |A|             |Q|         |W| |C|                 |Y|
    +-+             +-+         +-+ +-+                 +-+
     |                           |                       | 
     V                           V                       V 
    +-+                         +-+                     +-+
    |G|                         |R|                     |Z|
    +-+                         +-+                     +-+
                                 | 
                                 V 
                                +-+
                                |T|
                                +-+

При выполнении любой операции с хеш-таблицей необходимо просмотреть все элементы в списке у той ячейки, куда указывает хеш-функция.
Если в таблице m ячеек и n элементов, то в среднем в конкретной ячейке n/m элементов.
Число n/m называется "load factor" таблицы (коэффициент загруженности).
Получается, что все операции работают за время O(n/m) в среднем.

Обычно размер таблицы m выбирают пропорционально количеству ключей.
Например, если брать m = max(n), то load factor <= 1, и все операции работают в среднем за время O(1).

Следует заметить, что в худшем случае любая операция над хеш-таблицей работает за O(n) времени --- то есть очень долго.
Это может случиться на практике при использования очень плохой хеш-функции. Например, когда chi(k) = 0 для любого ключа k

II) Открытая адресация (open addressing).

Если нужно добавить элемент в ячейку, а ячейка занята, то добавляем элемент в следующую ячейку.
Если и она занята, то выбираем следующую... и т.д. пока не найдём сводобную ячейку.

Пример:
     0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15 
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
   |   |   | A | P | Q | X |   |   |   | T | Y |   |   | W |   | Y |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

   chi(A) = 2  chi(P) = 2  chi(Q) = 3  chi(X) = 4
   chi(T) = 9  chi(Y) = 9
   chi(W) = 13  chi(Y) = 15

При выполнении любой операции сначала вычисляется хеш-функция j = chi(k).
Далее нужно просмотреть все занятые ячейки начиная с j-ой и заканчивая первой пустой ячейкой после неё.

Таким образом, вся таблица разбивается на "отрезки" (runs) подряд идущих занятых клеток.
Время работы каждой операции определяется длиной такого отрезка.
При n/m <= C < 1 длина отрезка в среднем константная (без доказательства).
Например, можно поддерживать n/m <= 2/3, тогда отрезки в среднем будут очень короткие.
В таком случае время выполнения любой операции равно O(1) в среднем.

Замечание: что делать, если в нарисованную выше таблицу надо добавить новый элемент с хешом 15 ?
Обычно массив хеш-таблицы зацикливают, и новый элемент попадёт в ячейку 0.
Благодаря зацикливанию, в таблицу всегда можно добавить элемент, если в ней есть хотя бы одна свободная ячейка (хотя если свободных ячеек мало, то это будет небыстро).

Как доказать, что хеш-таблица с открытой адресацией верно работает?
Дело в том, что всегда выполняется следующее условие ("инвариант"):
  Если в j-ой ячейке таблицы лежит элемент с ключом k и chi(k) = i, то все ячейки в отрезке от i-ой до j-ой должны быть заняты.
Легко убедиться, что этот инвариант сохраняется в процессе работы (от добавлений не может нарушиться).

Удаление --- отдельная проблема.
Нельзя просто взять и сделать клетку с удаляемым элементов пустой --- тогда нарушится инвариант для элемента, идущего сразу после.
Вместо этого ячейку таблицы помечают специальным элементом-"гробиком" (tombstone) --- такие элементы занимают клетки и участвуют в образовании отрезков.
Естественно, при накоплении большого количества tombstone приходится что-то делать.

Например, можно реаллоцировать хеш-таблицу:
  создаём новую таблицу, возможно большего размера  (можно даже выбрать новую хеш-функцию, хотя не обязательно)
  перебираем все элементы в старой таблице, и каждый из них добавляем в новую таблицу (как обычно)
Реаллокации необходимы, например, для растущей таблицы (хотя гораздо проще заранее создать таблицу достаточного размера).

>>> Зачем нужна хеш-таблица?
1) Хорошее время работы в среднем. Например, можно удалить дубликаты за O(N) в среднем (а с сортировкой нужно O(N log N)).
2) В отличие от комбинации "сортировка и бинарный поиск", можно добавлять/удалять элементы и искать элементы вперемешку.

>>> Примеры хеш-функций:

1) Хеш-функция Дженкинса:
  uint32_t jenkins(const uint8_t* key, size_t len) {
    uint32_t hash = 0;
    for (size_t i = 0; i < len; i++) {
      hash += key[i];
      hash += hash << 10;
      hash ^= hash >> 6;
    }
    hash += hash << 3;
    hash ^= hash >> 11;
    hash += hash << 15;
    return hash;
  }
Считает хеш от любого заданного массива байтов.
Можно передавать как целые числа, так и строки.

Важный момент: эта хеш-функция возвращает хеш в диапазоне от 0 до 2^32-1.
Чтобы применять её в хеш-таблице, надо сократить выходной диапазон до m --- размера хеш-таблицы.
Проще всего это делать так:
  int cell = jenkins(&key, sizeof(key)) % m;

Почему в таблице смесь сложений и XOR-ов? --- лучше не будем об этом.
Почему много сдвигов влево/вправо? --- это чтобы улучшить "avalanche behavior".

Чтобы хеши выглядели как случайные, при любом изменении ключа наперёд заданный бит хеша должен измениться с вероятностью 50%.
В частности, это должно быть верно при изменении одного бита в ключе.
"avalanche effect" описывает, насколько каждый бит ключа сам по себе влияет на каждый бит хеша.
Чтобы оценить влияние i-ого бита ключа на j-ый бит хеша, можно посмотреть, с какой вероятностью в хеше изменяется j-ый бит при изменении i-ого бита в случайно выбранном ключе.
По идее, это число должно быть близко к 50% для всех i и j. Если оно близко к 0% или 100%, то дело плохо.
Если в хеше Дженкинса убрать сдвиги, то старшие биты ключа не будут влиять на младшие биты хеша, а младшие биты ключа почти не будут влиять на старшие биты хеша.

2) Хеш-функция Кнута (ключи = целые числа).

Рассмотрим отрезок [0..1] на координатной прямой, разделённый на m равных ячеек. Выберем вещественное число phi.
Для вычисления хеш-функции для целого k, вычисляем x = (phi * k) mod 1 (целая часть отбрасывается).
Теперь ставим точку в координате x и смотрим, в какую из m ячеек она попала --- это и есть вычисленный хеш для ключа k.
  
Понятно, что при увеличении k на 1 координата x смещается на phi (при этом отрезок зациклен на себя).
Чтобы не было повторов, следует взять иррациональное число phi --- тогда для всех k точки будут в разных местах.
Более того, внешне положение x будет зависеть от ключа k "примерно случайно".
Обычно берут золотое сечение: phi = (sqrt(5) - 1) / 2.
Кроме того, количество ячеек берут степенью двойки: m = 2^s.

Для реализации phi заранее домножают на 2^32:
  uint32_t KnuthHash(uint32_t k) {
    const uint32_t A = 2654435769U;     //округлённое до целого phi * 2^32
    uint32_t x = (A * k);               //умножаем по модулю 2^32 (за счёт переполнения)
    return x >> (32 - s);               //берём старшие s битов --- получаем номер ячейки
  }

3) Полиномиальный хеш.
Вычисляется по последовательности цифр/символов/байтов:
  chi(x) = ( sum B^i * x_i ) mod p
Здесь:
  B > 1 --- выбирается произвольно (случайно или похоже на то)
  p --- большое простое число

В отличие от хеша Дженкинса, полиномиальный хеш является "rolling hash".
То есть:
  Если в массиве рассмотреть окно [l..r) и посчитать его полиномиальный хеш,
  то зная его можно вычислить хеш для окна [l+1..r+1) за время O(1), т.е. очень быстро.


================== Указатель на функцию ===================

Виртуальная память программы:
  сегмент .text: содержит машинный код
  остальные сегменты: содержат данные

Машинный код состоит из функций, записанных подряд.
У каждой функции есть адрес начала, который нужно знать, чтобы её вызвать.
При обычном вызове адрес знает компилятор, и вставляет его в место вызова:
  call  000000014002E800        ; видимо, это адрес какой-то функции

Вопрос: можно ли сохранить в переменной адрес функции, так чтобы потом вызвать её по этому адресу?
Можно: указатель на функцию = адрес начала функции + тип функции.
Тип функции --- это типы параметров и тип возвращаемого значения.

Объявление переменной с типом "указатель на функцию":
  int (*pfunc)(int, int);
Удобнее использовать typedef:
  typedef int (*IntBinFunc)(int, int);
  IntBinFunc pfunc;
Замечание:
  1) имя переменной заключается в скобки, перед именем ставится звёздочка.
  2) у параметров имена можно не указывать: важны только типы.

Запись адреса функции в указатель:
  int sum(int a, int b) { return a+b; }     //обычная функция
  ...
  pfunc = &sum;                             //записали адрес
  pfunc = sum;                              //то же самое, амперсанд не обязателен
Вызов функции по указателю:
  int r = (*pfunc)(3, x);                   //разыменовываем в скобках, потом вызываем как обычно
      r = pfunc(3, x);                      //можно даже не разыменовывать
Машинный код генерируется только при компиляции, дальше его нельзя ни копировать, ни генерировать, ни изменять.
Поэтому нет смысла различать значение функции и указатель на функцию --- в языке C может быть только указатель на функции, "значения" функции нет.

>>> Основное применение указателей на функцию --- это callback.
Когда мы передаём кому-то указатель на нашу функцию, скорее всего он у себя в коде её будет вызывать.
При этом управление будет временно передаваться обратно в наш код --- отсюда название CallBack.

Канонический пример --- функция qsort из стандартной библиотеки:
  void qsort(void *arr, int n, int size, int (*comp)(const void*, const void*));
Эта функция работает с элементами любого типа (поэтому void* всюду в типах).
Она перемещает элементы с помощью memcpy, а вот чтобы их сравнивать, ей абсолютно необходимо использовать код вызывающего.
Поэтому функция принимает comp (компаратор) --- указатель на нашу функцию, вызывая которую, qsort может сравнивать элементы.

С сигнатурой qsort есть серьёзная проблема.
Допустим, есть N элементов, и у каждого элемента есть имя. Все имена хранятся в отдельном массиве:
  char *names[1<<20];               //names[k] --- имя k-ого элемента
В другом массиве у нас лежат индексы элементов от 0 до N-1:
  int indices[1<<20] = {0, 1, 2, 3, 4, ..., N-1};
Мы хотим отсортировать массив индексов indices по имени элемента:
  int comp(const void *a, const void *b) {
    return strcmp(names[*(int*)a], names[*(int*)b]);
  }
  qsort(indices, n, sizeof(int), comp);
В данном случае компаратор обращается к names как к глобальной переменной.
Однако в реальном программировании глобальные переменные очень не любят, а сохранить в локальную никак не получается.

Выход: использование callback with context (с контекстом).
Вызывающий передаёт дополнительное значение, которое функция qsort_s "как есть" протаскивает в наш компаратор.
  void qsort_s(void *arr, int n, int size, int (*comp)(const void*, const void*, void*), void *context) {
    ...
    int res = comp(((char*)arr) + i * size, ((char*)arr) + j * size, context);
    ...
  }
  ...
  int comp(const void *a, const void *b, void *context) {
    char **names = (char**)context;                         //достаём указатель на names из контекста
    return strcmp(names[*(int*)a], names[*(int*)b]);
  }
  qsort_s(indices, n, sizeof(int), comp, names);            //передаём указатель на массив names как контекст


=============================================================================================================================
=============================================================================================================================
   Ниже идёт дополнительный материал!
   1) Его не было на лекции.
   2) Его не будет на экзамене.
   3) Кому не интересно, лучше НЕ читать
=============================================================================================================================
=============================================================================================================================


Указатель на функции можно конвертировать явно, как любой другой указатель.
В том числе стирать тип, преобразуя в void*:
  void *codeptr = (void*)pfunc;                 //сохраняем указатель на ф-ию без типа
  int codeargs = 2;
  ...
  if (codeargs == 2) {
    IntBinFunc pfunc = (IntBinFunc)codeptr;     //т.к. codeargs == 2, вызываем как бинарную функцию
    res = pfunc(a[0], a[1]);
  }
Можно обращаться к функции как к данным (это весело, но смысла в этом нет):
  pfunc = sum;
  printf("%p %s", (void*)pfunc, (char*)pfunc);       //печатаем адрес и машинный код pfunc (до первого нулевого байта)



Следует заметить, что в современных ОС по умолчанию области памяти имеют разные разрешения:
  .text (машинный код): read + execute      (нельзя писать! иначе при случайной перезаписи своего кода отладчик будет в шоке)
  остальное (данные): read + write          (Data Execution Prevention: запрещено выполнять данные, чтобы усложнить работу хакерам)
Так что вписать в машинный код свои байты так просто не получится =)


Важно, чтобы функцию одного типа не вызывали как функцию другого типа.
Помимо типов параметров и возращаемого значения, также в тип функции входит соглашение о вызовах.
Соглашение о вызовах (calling convention) для функции определяет:
  1) Куда и в каком порядке складываются параметры функции перед вызовом? Куда кладётся возвращаемое значение?  (обычно: стек и/или регистры)
  2) Кто создаёт и удаляет: стековый кадр, параметры функции, адрес возврата?   (обычно: стековый кадр на совести вызываемой ф-ии, адрес возврата пополам, параметры --- где как)
  3) Какие регистры функция может свободно изменять, а какие нужно вернуть в исходное состояние к концу вызова?  (обычно: часть регистров разрешается изменять свободно)

Доступные calling conventions определяются конкретной платформой, и являются частью ABI операционной системы (Application Binary Interface).
Естественно, они отсутствуют в стандарте языка C.

Некоторые конвенции в Visual C 32-bit:
  __cdecl: по умолчанию все функции на C используют её
  __stdcall: основное использование --- функции WinAPI
  __fastcall: попытка ускорить __cdecl, сделав передачу некоторых параметров через регистры
Подробности (__cdecl и __stdcall):
  1) Все параметры записываются на стек перед вызовом в порядке справа налево (т.е. самый последний параметр записывается первым).
     Возвращаемое значение записывается в регистр eax при выходе из функции.
  2) Стековый кадр создаёт и удаляет вызываемая функция. Параметры записывает на стек вызывающий.
     Параметры удаляет со стека: вызывающий в __cdecl / вызываемая ф-ия в __stdcall.
  3) В функции разрешено изменять регистры eax, ecd, edx как угодно.
     Остальные регистры использовать можно, но функция должна сохранить их значения на стеке и восстановить перед возвратом.
Пример:
  int sum(int a, int b) { return a+b; }     //обычная функция
  ...
  sum(3, 12);
Ассемблер:
    __cdecl                        __stdcall
  sum:                           sum:                       ; (функция sum -- просто метка в ассемблере)
    push ebp                       push ebp                 ; сохраняем начало предыдущего стекового кадра
    mov ebp, esp                   mov ebp, esp             ; создаём новый стековый кадр
    mov eax, [ebp+8]               mov eax, [ebp+8]         ; загружаем со стека первый параметр
    mov edx, [ebp+12]              mov edx, [ebp+12]        ; загружаем со стека второй параметр
    add eax, edx                   add eax, edx             ; суммируем два параметра в eax (там и оставляем)
    pop ebp                        pop ebp                  ; восстанавливаем предыдущий стековый кадр
    ret                            ret 8                    ; переходим по адресу возврата туда, откуда был сделан call
  ...                            ...                        ;   в случае __stdcall: дополнительно удаляем 8 байт со стека
  ...                            ...                 
    push 12                        push 12                  ; записываем на стек второй параметр
    push 3                         push 3                   ; записываем на стек первый параметр
    call sum                       call sum                 ; вызываем функцию
    add esp, 8                                              ; в случае __cdecl: удаляем 8 байт со стека

Важно: в тип функции входит её calling convention!
Обычно это не важно, т.к. все функции __cdecl. Но если использовать WinAPI, то может быть путаница.
Нетрудно понять, что если явно сконвертировать функцию и насильно вызвать её с неправильной calling convention, то всё может сломаться неожиданным образом =)


>>> Дополнительный пример хеш-функции

2) Линейная хеш-функция по модулю (целые числа).
  chi(x) = [(a * x + b) mod p] mod m
Здесь:
  a != 0, b --- произвольные числа (случайные или похожие на таковые)
  p --- БОЛЬШОЕ простое число (например 1000000007)
В конце стоит сокращение "mod m" --- оно нужно только когда нужен маленький выходной диапазон хеш-функции (например для хеш-таблицы).

3) Линейная комбинация (последовательности/строки).
  x = <x_0, x_1, ..., x_{l-1}> --- ключ, который является последовательностью длины l
  chi(x) = [( sum a_i * x_i ) mod p] mod m
Здесь:
  a_i != 0 --- произвольные числа (случайные или похожие на таковые)
Всё остальное как в предыдущей хеш-функции.
