============== Динамическое выделение памяти ===============

Мотивационный пример: массив размера ровно n
  int *arr = malloc(4 * n);     //выделяем блок 4*n байтов
  for (int i = 0; i < n; i++)
    arr[i] = i;
  ...                           //работаем с массивом
  free(arr);                    //освобождаем память
Получаем (на примере n = 100):
  +--+--+--+--+--+--+--+--+--+--+
  |0 |1 |2 |3 |4 | ...  ...  |99|     блок расположен в куче (heap)
  +--+--+--+--+--+--+--+--+--+--+

В начале программы:
  #include <stdlib.h>           //подключаем стандартную библиотеку
Функция выделения памяти:
  void *malloc(int bytes);      //bytes на самом деле имеет другой (целочисленный) тип
  (выделяет блок памяти размером bytes байтов, возвращает адрес начала блока)
Функция освобождения/удаления памяти:
  void free(void *ptr);
  (принимает адрес начала блока, освобождает блок)
Пока блок выделен, но ещё не удалён, он полностью в распоряжении программиста. 
После удаления, эти байты памяти могут быть переиспользованы для будущих malloc (или хранить внутренние данные) --- пользоваться им нельзя!

Специальные типы:
  void  --- "пустое" значение, нет значения  (обычно используется как возвращаемый тип функции)
  void* --- нетипипизированный указатель, т.е. просто адрес без типа
    нельзя разыменовывать (*ptr), индексировать (ptr[0]), делать арифметику (ptr + 5)
    malloc возвращает void*, так как он не знает, какого типа элементы будет хранить пользователь

Нюансы:
  1) Блок после выделения содержит произвольный мусор (см. calloc).
  2) При удалении в free нужно передавать адрес !начала! блока, указатель на середину передавать нельзя.
  3) malloc(0) --- писать можно, может вернуть 0 или не 0; в любом случае, нужно его освобождать через free.
  4) free(0) --- писать можно, гарантированно ничего не делает.
Типичные ошибки:
  1) malloc(k) для k < 0 или очень большого k --- может приводить к crash или выделению огромного количества памяти
  2) использование блока после его освобождения через free (в том числе повторное удаление) --- может случиться что угодно
  3) выделенный блок памяти выделяется, но не освобождается; приводит к необратимому росту потребления памяти (memory leak)


=============== sizeof и mem-функции =================

Можно узнать размер в байтах:
  sizeof(тип)                       //например, int x = sizeof(int);
  sizeof(выражение)                 //например, int szPtr = sizeof(malloc(2000000000));   --- вернёт 4 или 8 !
ВАЖНО: выражение НЕ вычисляется!    //например, sizeof(x++);    --- переменная x НЕ увеличится!

В том числе для структуры:
  typedef struct Pair {
    int key;
    double value;
  } Pair;
  printf("%d\n", sizeof(Pair));             //скорее всего напечатает 16
  Pair *arr = malloc(n * sizeof(Pair));

Работает и для массива, но с этим лучше быть осторожным:
  int arr[100];
  int sz(const int *ptr) { return sizeof(ptr); }
  printf("%d %d\n", sizeof(arr), sz(arr));      //400 и 4|8

Функции для работы с памятью (нужно написать #include <stdlib.h>)
  void memset(void *dst, int val, int bytes);
    заполняет bytes байтов начиная с адреса dst значением val
    пример:
      memset(arr, 0, n * sizeof(arr[0]));       //зануляем массив
  void memcpy (void *dst, const void *src, int bytes);
  void memmove(void *dst, const void *src, int bytes);
    копирует bytes байтов из адреса src в адрес dst
    разница: memcpy требует, чтобы куски памяти НЕ перекрывались
    примеры:
      memcpy(otherArr, arr, n * sizeof(arr));   //копируем в ДРУГОЙ блок памяти
      memmove(arr, arr+1, (n-1) * sizeof(arr)); //смещаем все элементы кроме первого влево на один элемент


====================== Связные списки ======================

Связный список состоит из последовательности узлов, связанных в цепь.
Каждый узел = значение и "ссылка" на следующий узел.

Массив:
  +---+---+---+---+---+
  |val|val|val|val|val|
  +---+---+---+---+---+
    ^   ^   ^   ^   ^
   [0] [1] [2] [3] [4]
  все элементы одного размера и записаны в памяти подряд
  плюсы:
    можно обращаться к k-ому элементу за O(1)
    использовать легко, работает быстро
  минусы:
    вставить/удалить элемент в середине занимает O(N) времени
    сложности с изменением размера массива

Связный список:
         +------+   
         | val  |   +------+
  head-->|      |   | val  |   +------+ 
         | next---->|      |   | val  |
         +------+   | next---->|      |
                    +------+   | next----> NULL
                               +------+                             
  элементы рабросаны по памяти, связаны в цепочку указателями
  плюсы:
    можно вставлять в любое место списка за O(1) времени
    просто изменять размер --- можно всегда добавить новый узел, создав его с помощью malloc
  минусы:
    индексация работает за O(N)
    сложнее и медленнее

>> Три варианта реализации:

I) Массив узлов и номер следующего в качестве ссылки:
  typedef struct Node {
    double value;           //значение узла
    int next;               //номер следующего узла в массиве arr (или -1 если его нет)
  } Node;
  Node arr[1000000];        //все узлы должны лежать в этом массиве
  int cnt;                  //сколько узлов в массиве arr использовано (инкрементируем каждый раз при добавлении узла, никогда не уменьшаем)
  int first;                //номер первого узла
Обход списка:
  for (int x = first; x >= 0; x = arr[x].next)      //next или first = -1, если следующего нет
    printf("%lf\n", arr[x].value);
Вставка нового узла в начало списка:
  int q = cnt++;
  arr[q].value = 666.666;
  arr[q].next = first;
  first = q;
Этот вариант самый простой и удобный для отладки программы.
Весь список можно посмотреть, раскрыв массив arr в отладчике.

II) Массив узлов, в качестве ссылки используется указатель:
  typedef struct Node {
    double value;           //значение узла
    struct Node *next;      //указатель на следующий элемент (или 0 если его нет)
  } Node;
  Node arr[1000000];        //все узлы должны лежать в этом массиве
  int cnt;                  //количество использованных узлов массива
  Node *first;              //указатель на первый узел
Обход списка:
  for (Node *p = first; p; p = p->next)             //next или first = 0 (NULL), если следующего нет
    printf("%lf\n", p->value);
Это переходный вариант между I и III, лучше его НЕ писать.
Он ближе к реальной жизни и сложнее при отладке (в указателях --- какие-то мутные адреса).

III) Узлы выделяются отдельными блоками в куче, ссылка = указатель:
  typedef struct Node {
    double value;           //значение узла
    struct Node *next;      //указатель на следующий элемент (или 0 если его нет)
  } Node;
  Node *first;              //указатель на первый узел
Обход списка:
  for (Node *p = first; p; p = p->next)
    printf("%lf\n", p->value);
Вставка нового узла в начало списка:
  Node *nn = malloc(sizeof(Node));  //новый блок памяти для каждого добавляемого узла
  nn->value = 666.666;
  nn->next = first;
  first = nn;
Этот вариант обычно используется в реальной жизни/индустриальной практике, но его сложнее всего отлаживать.

>> Операции над связным списком: идея реализации (на доске со стрелочками)

1) Вставка нового узла после заданного.
  (здесь должна быть картинка с узлами и стрелочками-ссылками)
  Нюансы:
    а) вставить узел перед заданным проблематично, т.к. нельзя ходить назад
    б) если нужно вставить в начало списка, то нужно изменять first --- возможно специальный случай
      void insertAfter(Node *where, double value);      //придётся передавать where = 0 и разбирать частный случай для вставки в начало
      void insert(Node **ptr, double value);            //*ptr --- это указатель next внутри узла, после которого надо вставить новый (позволяет избежать спец. случая)

 2) Удаление узла после заданного.
  (здесь должна быть картинка с узлами и стрелочками-ссылками)
  Нюансы:
    a) нельзя удалить заданный узел, т.к. нужно изменить next предыдущего узла, а добраться до него нельзя
    б) удаление первого элемента списка требует изменения first, и возможно специального случая
      void eraseAfter(Node *where);                     //придётся передавать where = 0 и разбирать частный случай для удаления первого элемента
      void erase(Node **ptr);                           //*ptr --- это указатель next внутри узла, нужно удалить следующий узел (позволяет избежать спец. случая)

>> Различные виды связных списков

1) Односвязный / двусвязный  (ранее все списки были односвязными)
  В двусвязном списке в каждом узле хранится две ссылки: на следующий и на предыдущий узлы (и две ссылки снаружи: first и last)
  Позволяет ходить вперёд/назад, а значит можно удалять элемент по указателю, а также вставлять новый узел перед заданным.
  Из минусов: больше всяких ссылок, а значит больше возможностей ошибиться.

2) (цепочка) / кольцевой
  В кольцевом списке последний элемент указывает (через next) на первый узел --- список является кольцом / циклом.
  Сам по себе кольцевой список лучше НЕ использовать, если только это не вызвано требованиями задачи.
  

3) (обычный) / со всмопогательным узлом (sentinel)
  Во вспомогательном узле значение не важно (его нет), важна только ссылка на первый элемент.
  Вспомогательный элемент можно выделять точно так же, как все нормальные узлы (на куче/из общего массива), либо можно записывать в локальной переменной.
  Пример:
    Node list;                          //здесь вспомогательный узел --- локальная переменная
    list.next = malloc(sizeof(Node));   //добавляем один нормальный элемент
    list.next->value = 666.0;
    list.next->next = 0;
  Тогда можно писать метод:
    void insertAfter(Node *where, double value);
  и его можно использовать даже для вставки в начало:
    insertAfter(&list, 7.6);
  тогда внутри не будет никакого особого случая =)


!Наиболее гибкий/удобный вид!: двусвязный кольцевой список с вспомогательным элементом
(да, это звучит странно, но так на самом деле есть)
Позволяет избежать всевозможных случаев вообще --- все операции работают одинаково, даже при работе с началом/концом или с пустым списком.

                 +-+-----+-+
       --------->|*|sent.|*|<-------------------          (при желании можно даже хранить в локальной переменной, или как 0-ой элемент массива узлов)
      /          +-+-----+-+                    \
     V                                           V
    +-+-----+-+      +-+-----+-+        +-+-----+-+
    |*|  3  |*|<---->|*|  7  |*|<------>|*|  6  |*|
    +-+-----+-+      +-+-----+-+        +-+-----+-+

Например, удаление заданного элемента:
  void erase(Node *ptr) {
    ptr->prev->next = ptr->next;
    ptr->next->prev = ptr->prev;
    //опционально: free(ptr);
  }
Если брать обычный двусвязный список, то придётся рассмотреть случаи, когда ptr->prev = NULL, ptr->next = NULL, и когда оба.
Кода будет сильно больше, и вероятность ошибиться тоже.

============================================================

>> Небольшой пояснение по задачам на списки: как работать с ID.

В задачах набора во входном файле узел списка никогда не задаётся по указателю, т.к. заранее адрес узла неизвестен, а значит мы не можем положить адреса в input.txt.
Вместо этого узел всегда задаётся через ID (идентификатор): порядковый номер операции добавления, которая создала этот узел.

Если хранить узлы в массиве (варианты I и II), то это работает само собой: ID --- это просто индекс в массиве узлов.
Если хранить узлы в куче, то это сложнее.
В задаче "7. Список с указателями" требуется хранить узлы в куче, а операции всё равно задаются через ID.

Чтобы получить указатель (или позицию) узла по ID, нужен массив, отображающий ID в указатели:
  Node *idToNode[1000000];
  int idCnt = 0;                    //сколько уже выдано ID-шников
Тогда операцию вставки можно делать так:
  int id;                           //читаем из файла ID узла, после которого надо вставить новый
  double val;                       //также читаем значение нового узла
  scanf("%d%lf", &id, &val);
  Node *ptr = idToNode[id];         //получаем по ID-шнику указатель на узел (зарегистрирован ранее)
  Node *nn = insertAfter(ptr, val); //вызываем функцию вставки узла после ptr, она возвращает указатель на новый узел
  idToNode[idCnt++] = nn;           //регистрируем новый узел по его ID-шнику, увеличиваем k
Замечание:
  idToNode --- это необходимый костыль, нужный чтобы подружить связные списки на куче с системой nsuts.
  В реальной жизни этот костыль писать НЕ надо!
