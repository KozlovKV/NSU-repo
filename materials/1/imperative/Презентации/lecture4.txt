====================== Строки ============================

Символ (char) --- это одновременно:
  целое число (код символа), например 32, 48, 65
  символ, например ' ', '0', 'A'

ASCII-таблица определяет соответствие символов кодам/числам от 0 до 127.
Например:
  0 = '\0'          : нулевой символ
  32 = ' '          : пробел
  10 = '\n'         : символ перевода строки
  48-57 = '0'-'9'   : цифры
  97-122 = 'a'-'z'  : маленькие буквы
  65-90 = 'A'-'Z'   : большие буквы
Пример:
  int isDigit(char ch) { return ch >= '0' && ch <= '9'; }
  char lowerToUpper(char ch) { return ch + 'A' - 'a'; }


Строка в C = последовательность символов в памяти, заканчивающаяся на нулевой символ.

                             строка "Hello, World!" в памяти
                    /-----------------------------------------------\
                  |/                                                 \
  ----------------|--------------------------------------------------------------------------
  ... | § | ¿ | À | H | e | l | l | o | , |   | W | o | r | l | d | ! | \0 | õ | Û | » | ...
  ----------------|--------------------------------------------------------------------------
                  | ^                                                   ^
                    |                                                   |
                    |                                                   |
               указатель на начало строки (char*)            нулевой символ завершает строку

В C нет волшебного типа string, который сам знает, как копироваться, складываться, и т.д. и т.п.
Любая последовательность байтов в памяти, заканчивающаяся нулём --- это строка.
Программист сам отвечает за то, где и как размещать символы строки в памяти! (подсказка: используйте массивы char[])

Примеры:
  char *hello = "Hello, World!";            //в hello запоминается адрес строки, сама строка хранится в волшебном месте =)
  char hello[32] = "Hello, World!";         //в массив символов hello записываются символы строки
  char hello[] = "Hello";                   //в массив hello длиной 6 символов записываем символы строки, включая ноль на конце
  char hello[8];  hello[0] = 'H';           //можно записать в массив символы по одному
  hello[1] = 'i'; hello[2] = 0;

Дополнительно:
  printf("%s", hello);              //распечатать строку hello
  scanf("%s", hello);               //прочитать строку и записать её по адресу hello
                                    //внимание: здесь нет амперсанда!
                                    //программист должен гарантировать, что в hello хватит места
Альтернатива:
  gets(hello);                      //читает полностью всё до следующего перевода строки в hello (НЕ пропускает пробелы)


Запись (printf):
  printf(строкаформата, какие значения подставлять в строку);
Пример удобного форматированного вывода
  printf("Sum of %d and %d is %d\n", a, b, a + b);

Чтение (scanf):
  int cnt = scanf("%d%d%d", &a, &b, &r);
В строкаформата пишем, что надо прочитать, далее адреса переменных, куда это надо сохранить.
Возращает cnt --- сколько параметров удалось успешно прочитать.
Можно ещё делать так:
  int cnt = scanf("Sum of %d and %d is %d", &a, &b, &r);

Варианты sprintf / sscanf:
  char buff[256];
  sprintf(buff, "%d + %d = %d\n", a, b, a + b);     //записать в buff
  sscanf (buff, "%d + %d = %d", &a, &b, &r);        //прочитать из buff


Полезные функции для работы со строками из string.h:
    int strcmp(const char *, const char *) --- лексикографически сравнивает строки,
                                               возвращает "0", если строки одинаковые,
                                               положительное, если первая строка больше,
                                               и отрицательное, если меньше

    char *strcpy(char *dest, const char *src) --- копирует строку из src в dest
    
    char *strcat(char *dest, const char *src) --- дописывает строку src в конец dest 

    size_t strlen(const char *) --- возвращает длину строки (работает за время, пропорциональное её длине)

====================== Про документацию ============================

Когда используете готовую библиотечную функцию в своей программе, вы должны знать о ней следующее:
    * что функция делает;
    * какие аргументы она принимает;
    * что она возвращает, в частности, что она вернёт в случае возникновения ошибки;
    * при каких условиях работает, в частности, какие значения аргументов функции допустимы, а какие - нет;
    * какова её сложность по времени и по памяти.

Кроме того в некоторых случаях требуется знать некоторые дополнительные особенности используемых функций,
например, является ли функция потокобезопасной, но такие вопросы уже выходят за рамки нашего курса.

Такую информацию о библиотечных функциях вы можете прочитать в документации к ним.
Документацию вы можете найти в интернете.

Если вы используете Linux, то чтобы посмотреть документацию об интересующей вас функции,
вы можете пользоваться командой
    man имя_функции
    например man strcpy
Или чтобы посмотреть, какие функции есть в библиотеке
    man имя_библотеки
    например man string
