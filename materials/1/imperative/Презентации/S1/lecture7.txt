================ Макросы и препроцессор =================

Препроцессор обрабатывает исходный код ДО компилятора.
Он ничего не понимает о языке C, а лишь делает простые текстовые замены.
Кроме того, он обрабатывает "директивы препроцессора": строки, начинающиеся с решётки/диеза.

>>> Директива include:
  #include <somefile.h>                         //подключить стандартную библиотеку somefile.h
                                                //(физически вставляет текст указанного файла вместо этой строки)
Пока что нужна только для того, чтобы подключать части стандартной библиотеки (stdio.h, stdlib.h)

>>> Директива define (константы):
  #define INF 1000000000                        //можно объявлять макро-константы
  #define SIZE 100010                           //это константы "времени компиляции"
  int arr[SIZE];                                //можно даже использовать их для размера массива
После директивы define все слова INF и SIZE заменяются (как текст) на 1000000000 и 100010 соответственно.

>>> Директива define (функции):
  #define MAX(a, b) ((a) > (b) ? (a) : (b))     //можно писать макро-функции
  int arr[MAX(SIZE, 1)];                        //массив размера SIZE, но хотя бы с одним элементом

Внимание: препроцессор просто делает текстовые замены, он не знает языка C!
Осторожнее со скобками!

Плохо:
  #define SUM(a, b) a + b                       //макро-функция для суммы
  printf("%d\n", SUM(3, 5) * 10);               //печатает 53
  printf("%d\n", SUM(10==5, 5));                //печатает 1
Хорошо:
  #define SUM(a, b) ((a) + (b))                 //каждый параметр окружается скобками
                                                //всё выражение тоже окружается скобками

=============== Преобразования типов =================

Типы преобразований:
  1) Явные (приведения)
  2) Неявные
  3) Арифметические

>> Явное преобразование (приведение типа, cast).
Синтаксис:
  (новыйтип)значение                //осторожнее со скобками!
Явно говорим компилятору превратить значение одного типа в значение другого типа
Примеры разрешённых явных приведений:
  char ch = 'a';
  int num = (int)ch;                //целое => целое
  int ch2 = (char)num;              //  если новый тип меньше по размеру и значение не влезает, то оно будет обрезано
  int idx = (int)(real + 0.5);      //вещ => целое      (внимание: значение округляется в сторону нуля!)
  printf("%lf", (double)idx);       //целое => вещ
  int *arr = (int*)malloc(4*n);     //указ => указ      (в том числе не-void в не-void)
  int address = (int)arr;           //указ <=> целое    (осторожно! адрес не всегда влезает в int!)

>> Неявное преобразование.
В большинстве случаев компилятор преобразует несовпадающий тип сам, и явно писать приведение не нужно.
В каких ситуациях это происходит:
  1) кудазаписать = новоезначение;      (присваиваем значение другого типа)
  2) myfunc(значение, ...)              (передаём в функцию значение другого типа)
Какие приведения выполняются неявно:
  1) между целыми типами (char, int, long long, ...)
  2) между вещественными типами (double, float, ...)
  3) между вещественными и целыми типами (int <-> double и т.п.)
  4) типизированный указатель в нетипизированный и обратно (void* <-> type*)
  5) константа 0 в указатель (int *x = 0)
  6) массив в указатель (int[SIZE] -> int*)
Кроме того, Visual C ошибочно разрешает неявные преобразования:
  7) между указателями разных типов (int* <-> double*)
  8) между указателями и целыми числами (int* <-> int)
Совет:
  внимательно читайте все warning-и!  (кроме "scanf is unsafe, deprecated, blah blah blah =)")

>> Арифметическое преобразование.
Возникает при выполнении операции над аргументами разных типов.

Обычно в C арифметические операции выполняются над значениями одного типа, и результат получается того же типа.
Если надо, у одного из значений преобразуется тип.
Например:
  1) double + int -> double + DOUBLE = double         
       (если есть вещественный аргумент, то результат вещественный)
  2) char + int -> INT + int = int       
       (среди целых типов для берётся тип макс. размера)
  3) type[] + int -> type* + int = type* 
       (массив почти всегда преобразуется в указатель)
