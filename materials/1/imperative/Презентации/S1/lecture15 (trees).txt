======================== Деревья ==========================

Понятие дерева (точнее, корневого дерева = rooted tree).
Вершины/узлы в дереве.
Отец и сыновья вершины, корень и листья дерева.
Поддеревья.
Глубина вершины, высота дерева.

Простые примеры деревьев:
1) Дерево директорий на диске.
2) Генеалогическое дерево: только мужчины (или только женщины).
    
Рекуррентное определение:
  Дерево --- это одно из: а) пустое дерево  (без вершин)
                          б) дерево, состоящее из корня, к которому прикреплено K отдельных поддеревьев (каждое из них --- дерево)

Бинарное/двоичное дерево --- дерево, в котором у любой вершины не более двух сыновей.
Более того, у каждого узла определяется левый сын и правый сын (хотя один из них или оба могут отсутствовать).
В коде:
  struct Node {         //тип вершины бинарного дерева
    ...                 //любая информация, хранимая в вершинах
    Node *l, *r;        //ссылки на левого и правого сына вершины (могут быть NULL)
  };
  Node *root;           //ссылка на корень дерева (может быть NULL для пустого дерева)

Замечания:
1) Иногда нужно уметь перемещаться по дереву вверх: тогда нужно дополнительно хранить и поддерживать
   ссылку на отца для каждой вершины ("Node *p;").
2) Ссылки можно хранить в различном виде, так же как в случае связных списков.
   Можно хранить указатели, а можно хранить номера вершин в одном глобальном массиве.
3) Указатель на отсутствующую вершину обычно хранится как NULL.
   Однако можно вместо этого хранить указатель на вспомогательную вершиину (sentinel), если так удобнее.


===================== Бинарная куча =======================

В контексте сортировки и поиска:
  Элемент = "ключ" + "значение"
    "значение" --- это балласт, который надо перемещать вместе с ключом (может отсутствовать)
    "ключ" --- определяет, как элементы сравниваются между собой, используется алгоритмом

Внимание: есть два совершенно разных понятия кучи (heap):
  1) куча --- область памяти, в которой выделяются блоки через malloc/free
  2) куча --- структура данных, позволяющая быстро находить минимум
Желательно не путать.


>>> Бинарная/двоичная куча (binary heap) --- структура данных,
в которой хранится набор элементов, и которая позволяет выполнять операции:
* Insert(X): добавляет новый элемент X в кучу.
* ExtractMin(): возвращает минимальный элемент в куче, и сразу же удаляет его.

Дополнительные операции:
* Delete(?): удаляет заданный элемент из кучи.
* UpdateKey(?, nK): изменяет ключ у элемента X в куче на nK  (также есть DecreaseKey --- им можно ключ только уменьшать).


>> Бинарная куча --- это бинарное дерево, в котором в каждой вершине хранится один элемент.
При этом выполняется условие (инвариант):

  p <= l, p <= r     для l, r --- сыновей p                     |
                      (p --- любая вершина)                     p
Пример:                                                        / \
                                                              l   r
      ____1____  
     /         \ 
    2           3
   / \         / \             Заметим, что в корне автоматически минимальный элемент.
  4   3       7   5            Получается, что его и искать не надо.
 / \   \         /
5   4   5       10
       / \     /  \
      7   6   12  12
             /  \
            13  14

Несмотря на то, что бинарная куча --- это идейно дерево, в программе элементы хранят в обычном массиве.
Благодаря этому:
  1) Реализация становится сильно проще.
  2) Гарантируется маленькая высота дерева в любой момент времени.
   (это важно, потому что время работы операции пропорционально высоте).
Дальше разбираемся, как это делается.

Будем поддерживать кучу в виде Почти Полного Бинарного Дерева.
Бинарное дерево высоты H называется почти полным, если:
1) На любой глубине h < H присутствуют все 2^h вершин.
2) На максимальной глубине H все присутствующие вершины расположены максимально "слева".
Заметим, что почти полное бинарное дерево можно построить с любым количество вершин, причём единственным образом.

Пронумеруем вершины кучи по увеличению глубины, а на каждой глубине слева направо:

        ____0____           (глубина h = 0, всего 1 вершина)
       /         \
     _1_         _2_        (глубина h = 1, всего 2 вершины)
    /   \       /   \
   3     4     5     6      (глубина h = 2, всего 4 вершины)
  / \   / \   /
 7   8 9  10 11 .. .. ..    (глубина h = 3, всего 5 <= 8 вершин)

Заметим, что у вершины с номером v левый сын всегда имеет номер 2*k+1, а правый --- 2*k+2:
   
   _ k _              Это называется "нумерация кучи".
  /     \             Отец вершины v имеет номер (v-1)/2
 2k+1  2k+2

Тогда можно сохранить все вершины дерева прямо в массиве согласно вышеопределённым номерам.
При этом не нужно хранить ссылки на сыновей и отца, т.к. их можно легко посчитать по формулам.
  int k;                //текущий размер кучи
  Elem heap[SIZE];      //массив элементов, в котором хранится куча

Заметим, что для почти полного двоичного дерева:  2^H <= N <= 2 * 2^H - 1
Из этого следует, что H = log2(N) + константа, то есть H = O(log N).


>> Как можно реализовать операции кучи:
  Add(X):
    Добавляем X в дерево в качестве нового ЛИСТА.
    Для этого добавляет элемент в конец массива --- он автоматически становится новым листом.
    Восстанавливаем инвариант вызовом SiftUp от добавленного листа.
  ExtractMin():
    В качестве минимума возвращает элемент, изначально расположенный в корне.
    Далее меняем его местами с последним ЛИСТОМ дерева, после чего этот лист удаляем.
    Теперь восстанавливаем инвариант, запуская SiftDown от корня.

SiftUp --- операция просеивания вверх.
Запускается для вершины, если она может быть меньше отца, а в других местах инвариант выполняется.
Если вершина меньше отца, меняем её с отцом и запускаем SiftUp для отца рекурсивно. Иначе не делаем ничего.

SiftDown --- операция просеивания вниз.
Запускается для вершины, если она может быть больше своих сыновей, а в других местах инвариант выполняется.
Сначала выбираем наименьшего из двух сыновей, потом сравниваем с ним текущую вершины.
Если текущая вершина больше, меняем её местами с наименьшим сыном и запускаем SiftDown для него рекурсивно. Иначе не делаем ничего.

Время работы операций: O(H) = O(log N)

Реализация операций:
  Add(X):
    heap[k++] = X;              //добавляем элемент новым листом в конец массива
    SiftUp(k-1);                //поскольку инвариант с отцом добавленного листа может нарушиться,
                                //просеиваем вверх от листа
  ExtractMin():
    res = heap[0];              //корень всегда имеет номер 0
    swap(&heap[0], &heap[k-1]); //меняем корень с самым правым листом (он является последним)
    k--;                        //удаляем этот лист
    SiftDown(0);                //инвариант от корня к сыновьям может нарушаться, запускаем просеивание вниз


>> Приложения.

1) Сортировка кучей:
  Складываем все элементы из массива в кучу.
  Потом достаём по очереди элементы из кучи (ExtractMin) и записываем их обратно в массив по порядку.
  Время O(N log N).

2) Минимум в скользящем окне.
  * Как удалить элемент: пишем в него ключ -infinity, делаем ему SiftUp, а когда он становится корнем, удаляем через ExtractMin.
  * Нужно поддерживать соответствие между номером элемента во входном массиве и номером вершины в куче (в обе стороны).
     int heap2idx[...], idx2heap[...];
     void swap(int a, int b) {  //a и b --- номека В КУЧЕ
       //подправляем heap2idx и idx2heap для двух элементов
     }


===================== Дерево поиска =======================

>>> Дерево поиска --- структура данных,
в которой хранится набор элементов, и которая позволяет выполнять операции:
  * Add(X): добавляет элемент X в дерево (обычно если элемент с таким ключом уже есть, добавление НЕ выполняется).
  * Find(K): находит элемент в дереве, у которого ключ равен K (если такой есть).

>> Бинарное дерево поиска --- это бинарное дерево, в котором в каждой вершине хранится один элемент.
При этом выполняется условие (инвариант):

   a < p < b   для любых:  l, r --- левый и правый сыновья вершины p соответственно
                           a в поддереве l, b в поддереве r
            __(p)__
           /   |   \
     +--(l)--+ | +--(r)--+         
     |    .  | | | .   . |        квадраты --- это поддеревья у сыновей l и r
     | a  . .| | |  . .  |        внутри них вершины a и b
     |   .   | | | b   . |
     +-------+ | +-------+
               |
-----|=======|-|-|=======|------->   (ось ключей)
               ^
Если спроецировать дерево на ось, по которой откладываются ключи, то:
  всё левое поддерево расположено левее ключа p
  всё правое поддерево расположено правее ключа p

Благодаря этому инварианту, можно быстро реализовать Find(K):
  Сравниваем K с v->key:
    K == v->key    => нашли вершину v, можно больше ничего не делать
    K  < v->key    => если элемент с ключом K есть, он точно в левом поддереве -> запускаем поиск рекурсивно от левого сына
    K  > v->key    => если элемент с ключом K есть, он точно в правом поддереве -> запускаем поиск рекурсивно от правого сына
    v == NULL      => элемента с ключом K нет

Операция Add(X) выполняется так же, как Find(X.key).
В самом конце при переходе к пустому поддереву нужно вставить вместо пустого поддерева новую вершину X.

Обе операции выполняются за O(H) --- хочется минимизировать высоту H.
Заметим, что если в дерево поиска добавить N элементов в порядке возрастания, то они выстроятся в цепочку и будет H = N (очень плохо).

Решение проблемы: вставлять элементы в случайном порядке.
Тогда высота дерева будет H = O(log N) в среднем.
К сожалению, это можно сделать только тогда, когда все элементы заданы заранее, и нет разницы, в каком порядке их вставлять.

random_shuffle --- перемешивание элементов в случайном порядке.
  for (int i = 0; i < n; i++) {
    int pos = myrandom() % (i+1);
    swap(&arr[i], &arr[pos]);
  }

На любой итерации arr[0..i-1] случайно перемешано: на каждой позиции с равной вероятностью находится каждый элемент.
Мы выбираем элементу arr[i] случайную позицию в диапазоне [0..i], и ставим его туда.
В результате массив arr[i] становится случайно перемешанным.

Время работы shuffle: O(N)

Заметим, что дерево поиска неявно хранит элементы в отсортированном порядке.
Чтобы их в этом порядке перебрать, надо запустить инфиксный обход дерева:
  Traverse(v):                                        struct Node { 
    if (v == Null) return;                              int key;
    Traverse(v->l);                                     Node *l, *r;
    Print(v->key);                                    };            
    Traverse(v->r);                                   Node *root;   
При запуске из корня дерева:
  Traverse(root);
печатает все ключи в порядке возрастания.


>> Приложения.

1) Сортировка деревом поиска: вставляем все элементы в дерево поиска, потом делаем инфиксный обход.
Важно: нужно решить проблемы с элементами, у которых совпадают ключи!
Варианты:
  a) Ослабляем инвариант: a <= p <= b.
     Если при вставке элемента X в дерево с корнем v получается X.key == v->key,
     то рекурсивно вставляем в СЛУЧАЙНОГО из двух сыновей.
     Если вставлять всегда в левого, то если когда все элементы равны, дерево выстроится в цепочку высоты N.
  b) Храним в каждом узле не один элемент, а список элементов.
     Таким образом, в вершине v хранится один ключ K и список всех элементов, имеющих этот ключ.
  с) Дописываем к каждому ключу уникальный номер элемента (например во входных данных).
    Сравниваем равные ключи по номеру --> теперь все расширенные ключи различны.

2) Можно реализовать множество элементов, в котором можно быстро искать элемент по ключу.
Можно использовать вместо хеш-таблицы. Хотя пока неявно зачем, и непонятно, как контролировать высоту H.
