=================== Целочисленные типы =====================

Бит --- ячейка памяти, хранящая 0 или 1 (нельзя обращаться к биту напрямую!)
Байт --- минимально адресуемая часть памяти = 8 бит (можно прочитать/записать, брать адрес отдельно от остальных байтов)

  (старш)       (младш)
   +-+-+-+-+-+-+-+-+
   |1|0|1|0|0|1|1|1|     = 0xA7 = 167
   +-+-+-+-+-+-+-+-+

Целочисленный тип определяется двумя параметрами:
1) Знаковость: signed или unsigned
2) Размер: 1, 2, 4 или 8 байт   (может быть и больше)


>> Представление беззнаковых чисел.

 (старш)                                                        (младш)
   +-+-+-+-+-+-+-+-#-+-+-+-+-+-+-+-#-+-+-+-+-+-+-+-#-+-+-+-+-+-+-+-+
   |1|0|1|0|0|1|1|1|0|1|1|0|1|0|0|1|0|0|1|0|0|1|0|0|0|1|1|1|0|1|0|1|   = 0xA7692475 = 2808685685
   +-+-+-+-+-+-+-+-#-+-+-+-+-+-+-+-#-+-+-+-+-+-+-+-#-+-+-+-+-+-+-+-+

Беззнаковые числа записываются в двоичной системе исчисления "как есть".
Например, если x[k] --- это k-ый бит в представлении числа (k=0 для младшего, k=31 для старшего)
Тогда значение целого числа равно:

    X = x[0] + 2 x[1] + 4 x[2] + 8 x[3] + ... + 2^31 x[31] = sum_{i=0..31} ( x[i] * 2^i )

Переполнение арифметических операций (сложение и умножение) над беззнаковыми числами.
При этом не входящие старшие разряды просто выбрасываются:

      |10100111|                |10100111|     
  add |01110100|            mul |01010100|
    --+--------+              --+--------+
     .|00011011|              10|100111  |
                            1010|0111    |
                          101001|11      |
                          ------+--------+
                          ......|11001100|

В языке C арифметические операции всегда получают результат того же размера, что и операнды.
Фактически, сложение, вычитание и умножение работает по модулю 2^32.
Т.е. беззнаковые целые числа работают в точности как кольцо вычетов по модулю 2^32   (это остатки от деления на 2^32 с операциями сложения/умножения по модулю).

Можно нарисовать беззнаковые числа не на числовой прямой, на числовом "круге":
Обычно после числа k идёт число k+1 однако после числа 2^32 - 1 идёт число 0 --- круг замыкается в цикл.
Можно считать, что каждое число --- это некоторое смещение по часовой.
При выполнении умножения a * b, например, нужно a раз сдвинуться на b позиций по часовой: на какой числе остановимся, такой и будет результат.


>> Представление знаковых чисел (дополнительный код).

Основные свойства дополнительного кода:
1) Если знаковое число неотрицательное, то оно представляется в битовом виде точно так же, как беззнаковое число с тем же значением.
2) Операции сложения, вычитания и умножения на битовом уровне работают одинаково со знаковыми и беззнаковыми числами.
   На ассемблере нет отдельных инструкция для сложения со знаком и без знака.
   (при перемножении двух чисел длины W обычно получается результат длины 2 W --- в этом случае знаковость влияет на СТАРШУЮ половину результата, так что в x86 asm две инструкции умножения)

Пусть X  --- это значение битовой записи x[k=0..31], если рассматривать её как БЕЗзнаковое число,
     [X] --- это значение битовой записи x[k=0..31], если рассматривать её как знаковое число.

Из свойств можно понять, что:
* Если [X] < 0, то X и [X] должны совпадать по модулю 2^32. Разумно сделать, чтобы [X] = X - 2^32.
* Чтобы диапазон знаковых чисел был непрерывным:
    Если нарисовать круг для беззнакового числа X, то:
       все X < A должны давать неотрицательное [X],
       все X >= A должны давать отрицательное [X].
* Чтобы положительных и отрицательных чисел было примерно поровну, надо выбрать раздел A между отрицательными и неотрицательными примерно посередине круга.
В дополнительном коде A = 2^31.

Получается такое правило интерпретирования знаковых целых чисел:
  Если X <  2^31, то [X] = X            (старший бит = 0, неотр.)
  Если X >= 2^31, то [X] = X - 2^32     (старший бит = 1, отр.)
То есть вторая половина круга беззнаковых чисел "объявлена отрицательной", математическое значение чисел в ней смещается на 2^32 в минус:
  (беззнаковое) 2^31 ... 2^32 - 1   =>   -2^31 ... -1

Поскольку X и Y по модулю 2^32 совпадают с [X] и [Y], то можно легко проверить, что операции работают одинаково независимо от знаковости.

Примеры:
  0             = 0x00000000
  2^31-1 (max)  = 0x7FFFFFFF
  -2^31 (min)   = 0x80000000
  -1 = 2^32 - 1 = 0xFFFFFFFF

Замечание: дополнительный код отлично работает в 10-ичной системе исчисления (см. задачу "Числа со знаком").



>> Зоопарк целых чисел в С.

Некоторые слова у некоторых типов можно опускать (например signed и int) --- они заключены в скобки.

   имя типа              знак. размер     диапазон
-------------------------------------------------------
 (signed) char              S    1        -128..127
 unsigned char              U    1           0..255
 (signed) short (int)       S    2      -32768..32767
 unsigned short (int)       U    2           0..65535
 (signed) int               S    4     -2*10^9..2*10^9
 unsigned (int)             U    4           0..4*10^9
 (signed) long (int)        S   4/8        ?????????
 unsigned long (int)        U   4/8        ?????????
 (signed) long long (int)   S    8    -9*10^18..9*10^18
 unsigned long long (int)   U    8           0..18*10^18

Дополнительные полезные типы:
                ptrdiff_t   S   4/8     
                size_t      U   4/8 
Размер этих типов всегда совпадает с размером указателя / адреса:    (программы сегодня есть 32-битные и 64-битные)
           ???  void*       ?   4/8  ???

Кроме того, в stdint.h определены типы фиксированного размера:
               int8_t       S    1
              uint8_t       U    1
               int16_t      S    2
              uint16_t      U    2
               int32_t      S    4
              uint32_t      U    4
               int64_t      S    8
              uint64_t      U    8

Замечания:
 1) Тип long использовать крайне НЕ рекомендуется! т.к. размер зависит не только от битности, но и от платформы (Windows/Linux)
 2) Тип int по стандарту имеет размер 2 байта или больше, но сегодня можно смело считать, что он везде размера 4 байта (он был 2 байта на 16-битных платформах).
 3) Примерно такую же таблицу можно найти здесь: https://en.cppreference.com/w/cpp/language/types
Рекомендации по выбору типа:
 1) Использовать по умолчанию знаковые типы.
    Использовать беззнаковые переменные ТОЛЬКО для: манипуляций с битами, работой с сырыми бинарными данными.
 2) Использовать для целых чисел int по умолчанию.
    Если не хватает диапазона --- использовать long long.
 3) Для символов использовать char.
 4) Для хранения адресов и смещений использовать size_t и ptrdiff_t.
 5) Если нужны числа фиксированного размера, лучше использовать intXX_t и uintXX_t.


>> В хедере limits.h определены макро-константы, например:
  INT_MAX = 2^31 - 1
  INT_MIN = -2^31
 UINT_MAX = 2^32 - 1
LLONG_MIN = -2^63
и т.п.


Как читать/писать целые числа?
  "%d" / "%u" / "%x"  --- int
  "%lld" / "%llu" / "%llx" --- long long
  "%zd" / "%zu" / "%zx" --- ptrdiff_t / size_t
Последняя буква означает:
  'd' (Decimal) --- знаковое
  'u' (Unsigned) --- беззнаковое
  'x' (heX) --- беззнаковое шестнадцатиричное

==================== Битовые операции ======================

>> Есть логические операции (работают на уровне истина/ложь, есть сокращённое вычисление выражений):
  x && y --- "и"   логическое
  x || y --- "или" логическое
  !x     --- "не"  логическое
А есть аналогичные побитовые операции:
  x & y  --- "и"   побитовый
  x | y  --- "или" побитовый
  ~x     --- "не"  побитовый
  x ^ y  --- "xor" побитовый  ("исключающее или", "сложение по модулю два", "логическое не-равно")

Все побитовые операции работают так:
  перебираем номер бита k от 0 до 31:
    смотрим на k-ый бит x и на k-ый бит y
    выполняем над этими битами логическую операцию
    записываем ответ в k-ый бит числа-результата

Примеры:
  10100111  a
  11001010  b
  01011000  ~a
  10000010  a & b
  11101111  a | b
  01101101  a^b

>> Битовые сдвиги:

     (старш)        (младш)
       |1|0|1|0|0|1|1|1|      X
        \         \
(пустые) ---       --- (на выброс)
            \         \
       |0 0 0|1|0|1|0|0|      X >> 3  (сдвиг вправо на 3 бита)
   

       |1|0|1|0|0|1|1|1|      X
            /         /
(выброс) ---       --- (пустые)
        /         /    
       |0|0|1|1|1|0 0 0|      X << 3  (сдвиг влево на 3 бита)

Заметим, что:
1) Биты, которые после сдвига не входят в число, отбрасываются.
2) Пустые биты обычно заполняются нулями.

Исключения:
  unsigned xu = 0xF0F0F0F0;
       int xs = 0xF0F0F0F0;
  unsigned yu = xu >> 8;    //0x00F0F0F0
       int ys = xs >> 8;    //0xFFF0F0F0
При сдвиге вправо знакового числа пустота заполняется старшим битом.
Это называется "арифметический сдвиг" (и, строго говоря, не гарантируется стандартом)

Ещё один нюанс: нельзя сдвигать на полный размер числа или больше:
  unsigned x = 1375;
  unsigned y = x >> 32;     //скорее всего, оба числа
  unsigned z = x << 32;     //y и z равны 1375, а не нулю =(

Связь сдвига с умножением:
    (X << k)  равно  X * 2^k
    (X >> k)  равно  X / 2^k    (округление вниз --- даже для отрицательных)

Замечание: у битовых операций довольно неожиданные приоритеты!
Поэтому лучше ставить побольше скобок и проверять, в каком порядке делает операции компилятор.

>> Битовая маска --- целое число, которое воспринимается как массив битов, математическое значение которого не имеет никакого значения.
Позволяют оптимизировать по времени/памяти работу с набором булевых значений, обычно маска хранится в unsigned типе.

Операции с битовыми масками обычно используют (1<<k) = 2^k --- маску, у которой k-ый бит единичный, остальные нулевые.
Стандартные приёмы:
* if (X & (1<<k)) { ... }       //условие верно, если k-ый бит в X равен 1
* int b = (X >> k) & 1;         //возвращает k-ый бит X как число 0 или 1
* X |= (1<<k);                  //устанавливает в k-ый бит X значение 1
* X &= ~(1<<k);                 //устанавливает в k-ый бит X значение 0
* X ^= (1<<k);                  //переключает k-ый бит X на противоположное значение


======================= Сортировка =========================

Задача сортировки:
  Дан массив элементов A[i] для i = 0..n-1.
  Требуется поменять порядок элементов в массиве так, чтобы они шли по неубыванию.


Сортировка выборкой (промежуточное состояние):

        | 0               | k                                     | n
        +-----------------+---------------------------------------+--
        |#################|.......................................|
        +-----------------+---------------------------------------+--
        \                /            (остальные элементы)
         \              /
 k самых маленьких элементов массива A
     (упорядочены по неубыванию)

Идея:  1) находим среди оставшихся n-k элементов минимальный
       2) ставим его на k-ое место (меняя с ним местами)
       3) k++, повторяем
Изначально k = 0, после N итераций становится k = N и весь массив отсортирован.

Время работы: O(N^2) в худшем случае


===================== Бинарный поиск =======================

>> Идея: как за минимальное кол-во вопросов на да/нет угадать целое число от 0 до 1000 ?
Ответ: бинарный поиск (10 вопросов):
               1) верно ли, что X < 500 ?
            (да)                     (нет)
       2) X < 250 ?                     2) X < 750 ?
      (да)      (нет)                 (да)      (нет)
  3) X < 125?     3) X < 375?     3) X < 675?  3) X < 875? 
     ...              ...              ...         ...

Мы поддерживаем отрезок, в которой точно есть ответ.
На каждой итерации:
  смотрим на середину отрезка, и определяем: ответ слева или справа
  переходим в отрезку длины примерно в два раза меньше


  (применение бинарного поиска в мат. анализе: доказательство того,
что у ограниченной последовательности есть сходящаяся подпоследовательность)


>> Типично программистская задача на бинарный поиск:
Есть упорядоченный по возрастанию массив чисел A[0..n-1], нужно найти позицию числа X в этом массиве (если оно есть).

Будем поддерживать подотрезок, в котором должно быть число X.
Каждый раз будем выбирать число A[m] примерно посередине отрезка, и спрашивать:
  верно ли, что X < A[m] ?
В зависимости от этого выбираем одну половину отрезка.

Пример (X = 31):
   0   1   4   6   8   9   15  20  21  23  31  37  39  40  42  43  44  87  99         (массив A)
  [LL ................................ MM ................................ RR]        (итерация 0)
                                      [LL ............ MM ................ RR]        (итерация 1)
                                      [LL .... MM .... RR]                            (итерация 2)
                                      [LL  MM  RR]                                    (итерация 3)
                                          [LL  RR]                                    (итерация 4)
                                          [!!]                                        (одно число)

Псевдокод:
  L = 0, R = n-1;
  while (R > L) {
    M = (L + R) / 2;
    if (X < A[M])
      R = M-1;
    else
      L = M;
  }
  check(A[L] == X?)

Время работы одного поиска: O(log N)

А если влоб перебором, то нужно O(N) времени --- намного больше.


===================== Поддержание инварианта цикла =====================

Чтобы корректно реализовать алгоритм, полезно его сперва формализовать, и писать код, основываясь на такой формализации.
При формализации можно доказать, что код корректен, как доказываются математические теоремы.

На первый взгляд кажется, что алгоритм бинарного поиска тривиален, и не составляет труда написать код, реализующий его.
На практике оказывается, что многие, кто идейно знаком с этим алгоритмом,
не могут с первого раза написать его реализацию, так, чтобы она корректно обрабатывала все случаи.

Чтобы написать корректный код для такого алгоритма, полезно использовать такое понятие, как инвариант цикла.
Инвариант - это некий предикат (то есть условие), который должен всегда выполняться.
В случае инварианта цикла, наш инвариант должен выполняться перед каждой итерацией цикла и после неё.
Код цикла должен быть написан так, что в результате его выполнения истинность инварианта сохраняется.

Перед запуском цикла мы проверяем инвариант для входных данных, и если на этом этапе он истинен,
то по индукции он будет истинен и после того, как мы выйдем из цикла.

Если инвариант не выполняется перед запуском цикла, то цикл запускать нельзя,
поскольку в таком случае мы не можем гарантировать корректность его работы.
При невыполнении инварианта нужно обработать входные данные каким-то иным методом.
Например, это может быть частный случай, для которого цикл как таковой не нужен,
поскольку мы можем сказать, какой в этом случае будет ответ.

Инвариантом для алгоритма бинпоиска может быть, например, такое условие: A[L] <= X && X < A[R].
