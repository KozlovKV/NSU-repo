```c
=================== Реинтерпретирование ====================

Реинтерпретирование --- обращение к участку памяти под переменной как к значению другого (не связанного) типа.
Пример: мы хотим посмотреть, как на битовом уровне устроен тип double.

           (8 байт)
      +-----------------+
      |     double      |        (два взгляда на конкретные 8 байт памяти)
      +--------+--------+
      |  int   |  int   |
      +--------+--------+
        4 байта  4 байта

Способ 1: указатели
Пример:
  double x = 17.3;
  int *ptr = (int*)&x;                  //конвертируем указатель: адрес остаётся тем же, а тип мы меняем насильно
  int low = ptr[0], high = ptr[1];      //по указателю можно считать ту же память как int-ы

Способ 2: union
  union dbl2int {
    double d;
    int i[2];
  };
  union dbl2int u;
  u.d = 17.3;                           //записываем в поле d вещественное число
  int low = u.i[0], high = u.i[1];      //обращаемся к той же памяти через поле i

union работает ровно так же, как struct, за одним важным исключением:
  В struct все поля размещаются в памяти друг с другом, в каждом поле хранятся независимые данные
  В union все поля размешаются в памяти под одинаковому адресу (начало union-а), то есть они дают разные способы обращаться к одной памяти


============== Память: размещение данных ==================

>> Взаимное расположение отдельных блоков памяти может произвольно меняться от запуска к запуску и от сборки к сборке --- нельзя на него полагаться!
Блок памяти: а) выделенный с помощью malloc кусок данных
             б) хранилище под локальной/глобальной переменной

Например:
  int base[256];        //base --- блок памяти размером 1 KB
  int arr[256];         //arr --- другой блок памяти
  ...
  int x = -100;
  printf("arr[%d] = %d\n", x, arr[x]);
Если бы base и arr были расположены в памяти подряд в этом порядке, то arr[-100] совпадало бы с base[156].
Однако это может оказаться так, а может быть и НЕ так: компилятор может поменять порядок или вставить что-то между.

Тем не менее: расположение данных внутри одного блока памяти всегда можно определить! --- см. ниже

>> Порядок байтов (endianness).

Пример:
  int x = 0xABCD1235;
  char *b = (char*) &x;
Возможно два варианта, в каком порядке будут храниться в b байты числа x:
  b[0] b[1] b[2] b[3]     b[0] b[1] b[2] b[3]
  0xAB 0xCD 0x12 0x35     0x35 0x12 0xCD 0xAB
  (старш)      (младш)    (младш)      (старш)
      big-endian              little-endian

У процессоров больше популярен little-endian:
  x86, ARM --- little-endian
Однако об endianness забыть не получится:
  Cell (Playstation 3), network order --- big-endian

endianness десятичных чисел у людей = ?
У нас это big-endian, однако арабы пишут справа налево (правда индусы кажется пишут слева направо).
Вопрос не однозначный =)

>> Массивы.

Пример:
  X arr[N];
  char *bytes = (char*)arr;

Элементы располагаются в памяти подряд, нумеруются по порядку, пропусков между соседними элементами нет.
Адрес k-ого элемента:
  &(arr[k]) == bytes + k * sizeof(X)


>> Структуры: упаковка и выравнивание.

Пример:
  struct Temp {
    char name[3];
    double val;
    char isAlive;
    int idx;
    char isLast;
  };

Наиболее вероятное размещение в памяти (упаковка/packing):

  | (name)        |     (val)     |(isAlive)      |(isLast)     
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |A|A|A| | | | | |B|B|B|B|B|B|B|B|C| | | |D|D|D|D|E| | | | | | | |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |               |               |         (idx) |               
Пустые места = padding. Общий размер структуры 32 байта, из них 15 байтов --- это padding.

Причина в выравнивании (alignment).
Когда мы выполняем инструкцию по работе с памятью вроде:
  mov eax, DWORD PTR [esp-1Ch]       (загружает 4 байта из памяти в регистр eax)
обычно предполагается, что адрес в памяти (esp-1Ch) делится на размер загружаемого слова (т.е. на 4).
В таком случае доступ к памяти называется выровненным (aligned).
Невыровненный доступ приводит к одному из:
а) Слабое ухудшение производительности --- если есть поддержка на аппаратном уровне (например x86).
б) Сильное ухудшение производительности --- есть поддержка только на программном уровне (например double на PowerPC).
в) Падение программы --- если нет поддержки (очень старые PowerPC, MIPS без ОС).

Согласно стандарту, язык C делает так, чтобы все обращения в память были корректно выровнены.
Для этого:

1) Для каждого типа компилятор знает/определяет его "выравнивание" (alignment), точно так же, как он знает размер.
  Обычно alignment равен 1, 2, 4 или 8, и тип должен размещаться в памяти так, чтобы его адрес делился на alignment.
     *) примитивный тип или указатель: alignment = size     (адрес делится на размер: называется self-aligned)
     *) массив: alignment(T[N]) = alignment(T)              (выравнивание у массива такое же, как у его элемента)
     *) struct X: alignment(X) = max(alignment(поле))       (выравнивание как у самого выровненного поля структуры)

2) В структурах добавляется padding --- пустоты между соседними полями.
  Обычно добавляется минимальное количество байт padding-а, так чтобы адрес следующего поля был выровнен.
  В конце структуры добавляется padding, чтобы вторая структура в массиве была верно выровнена (вообще, размер всегда делится на выравнивание).

3) Все глобальные и локальные переменные автоматически размещаются компилятором так, чтобы их адрес делился на их выравнивание.
  Результат вызова malloc гарантированно достаточно выровнен для того, чтобы записать туда любой кросс-платформенный тип:
       обычно для malloc: адрес делится на 8 в 32-битном режиме, и делится на 16 в 64-битном режиме

Как жить в условиях padding-а неопределённого размера?
Во-первых, есть встроенная псевдофункция offsetof, которая определяет, на сколько байтов поле структуры смещено относительно её начала:
  offsetof(Temp, val) == 8
  offsetof(Temp, idx) == 20
Во-вторых, можно заставить компилятор убрать весь padding:
  #pragma pack(push, 1)                 // #pragma --- нестандартная директива
  struct Temp {                         // (большая тройка компиляторов MSVC, GCC и Clang поддерживает её)
    ...
  };
  #pragma pack(pop)                     //теперь sizeof(Temp) == 17
Это приводит в невыровненному доступу к памяти, но на большинстве распространённых архитектур это не сильно страшно (в т.ч. на x86).
Очень удобно для чтения структурированных бинарных данных в структуру целиком, одним куском.
Необходимо, чтобы гарантировать одинаковое бинарное представление структуры на разных платформах (сеть/сохранение в файл).


================ Файлы (в т.ч. бинарные) ===================

>> Чтобы открыть файл, нужно написать:
  #include <stdio.h>
  FILE *f = fopen("путькфайлу", "режимоткрытия");
Здесь:
  fopen --- функция, объявленная где-то в stdio.h
  FILE* --- указатель на что-то непонятное: служит handle-ом (ручкой) для работы с файлом

Режим открытия обычно состоит из двух символов, например "rt" или "wb".
Символ 0 определяет доступ:
  'r' --- на чтение (можно только читать, только если файл существует)
  'w' --- на запись (можно только писать, если файла нет --- он будет создан)
Символ 1 определяет формат:
  't' --- текстовый режим (?)
  'b' --- бинарный режим (?)
(есть и другие буквы, но нам они не нужны)

>> Чтобы закрыть файл, нужно написать:
  fclose(f);
При нормальном завершении программы файлы закрываются автоматически (а если программа падает --- то нет).

>> Как читать/писать из/в открытый файл.

1) Текст:
  int x;
  fprintf(f, "my int is %d\n", x);
  fscanf(f, "%d", &x);
Заметим добавленную букву f в имена функций и добавленный первый аргумент.

2) Бинарные данные:
  int arr[100];
  fwrite(arr, sizeof(int), 100, f);
  fread(arr, sizeof(int), 100, f);

У fread/fwrite:
  первый аргумент --- адрес блока, куда надо читать / откуда надо писать
  второй аргумент sz --- размер одного элемента
  третий аргумент cnt --- количество элементов
Функция читает/пишет (sz*cnt) байтов, и возвращает количество успешно прочитанных/записанных элементов.
Кроме возвращаемого значения, разбиение размера на множители sz и cnt ни на что не влияет.
Заметим, что fread/fwrite --- примерно как memcpy между памятью и файлом: просто копирует заданный блок байтов, независимо от того, что там лежит.


>> Режим открытия файла: текстовый/бинарный
В бинарном формате ваша программа видит в точности те байты, которые лежат в файле.
Текстовый формат отличает от бинарного только нормализацией переводов строк.

Переводы строк представляются по-разному в разных ОС:
  Windows:    \r\n  --- два символа 0x0D и 0x0A, они же 13, 10
  Linux:      \n    --- один символ 0x0A, или 10   (символ перевода строки)
  старый Mac: \r    --- один символ 0x0D, или 13   (символ возврата каретки)

При открытии файла в текстовом режиме библиотека stdio автоматически конвертирует все переводы строк.
Когда вы читаете из текстового файла, все переводы строк автоматически заменяются на один символ '\n'.
Когда вы пишите в файл, каждый символ '\n' заменяется на перевод строк, принятый в вашей системе.

Разумеется, при работе с бинарными данными эта коррекция что-нибудь наверняка испортит --- поэтому нужно использовать бинарный режим.
А вот текст в бинарном режиме читать/писать можно --- надо просто аккуратно разбираться с переводами строк.

Забавный факт: в Linux бинарный и текстовый режимы ничем не отличаются.


>> Буферизация
Если бы каждый байт сразу писался в файл на жёсткий диск, запись работала бы ОЧЕНЬ медленно.
Чтобы этого не было, при записи в файл есть буфер внутри FILE*, и всё данные попадают в него, а он пишется в файл только когда заполнится.
Из-за этого последние записи в незакрытый файл могут потеряться при ненормальном завершении программы.

Вызов fflush(f) форсирует запись содержимого буфера в файл --- то есть всё записанное в файл f до этого момента точно окажется на диске, даже если программа упадёт.
Например, желательно делать fflush в конце отладочного вывода.
Разумеется, fclose (и как следствие нормальное завершение программы) форсирует запись буфера автоматически.


>> Как работают printf/scanf?
У консольной программы есть три встроенных потока ввода/вывода
  stdin: стандартный поток ввода   (обычно ввод с клавиатуры)
  stdout: стандартный поток вывода (пишет в консоль на экран)
  stderr: стандартный поток ошибок (пишет в консоль на экран)
Все эти названия (stdin/stdout/stderr) являются переменными в C, имеющими тип FILE*.

Функция printf всегда пишет в stdout, то есть "printf(str, args)" эквивалентно "fprintf(stdout, str, args)".
Функция scanf всегда читает в stdin, то есть "scanf(str, args)" эквивалентно "fscanf(stdin, str, args)".

При желании можно закрыть или изменить stdin/stdout/stderr.
Например, можно использовать функцию freopen:
  freopen("имяфайла", "режим", ручкафайла);
  freopen("input.txt", "rt", stdin);
Она берёт заданный FILE*, и привязывает к нему другой файл, который открывает по первым двум аргументам.
```