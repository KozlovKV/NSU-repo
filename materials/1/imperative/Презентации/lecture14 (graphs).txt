=================== Представления графа ====================

>>> Граф:  G = <V, E>
  V --- вершины (города/развилки)
  E --- рёбра (дороги)

Важен только факт соединения вершин ребром, положение ребра не важно.
Если считать рёбра дорогами, то дороги можно проводить "по туннелям"

Пример: в пентограмме 5 вершин и 10 рёбер, без пересечений она не рисуется.

Графы бывают:
  неориентированные: рёбра без направления, можно ходить в обе стороны
  ориентированные: каждое рёбро смотрит в определённом направлении, "односторонние дороги"

Кратные ребра --- когда пара вершин соединена двумя или более рёбрами
(в ориентированном случае: когда из вершины u в вершину v идёт два или больше ребра)
Петля --- ребро, из вершины в саму себя (концы ребра совпадают)


>>> Способы хранения графа.

Все вершины нужно пронумеровать, обычно подряд от 0 до n-1.

> I. Список рёбер.

В коде:
  struct Edge {
    int s, e;           //начальная и конечная вершины
    int weight;         //вес --- если граф взвешенный
  };
  Edge edges[...];      //список всех рёбер
(пример)

Расходы:
  Память: O(E)
  Время обхода * -> *: O(E)         //обходим рёбра из всех вершин во все

Главная проблема: нельзя быстро перебрать все рёбра, выходящие из заданной вершины.
Список рёбер очень редко используется: только когда алгоритму не нужно обходить рёбра нетривиальным образом.


> II. Матрица смежности.

В коде:
  int matr[...][...];               //matr[u][v] --- есть ли ребро из u в v, или: количество рёбер из u в v

Если граф неориентированный, то матрица симметричная (каждое ребро попадает в две симметричные ячейки).

Расходы:
  Память: O(V^2)
  Время обхода * -> *: O(V^2)       //обходим рёбра из всех вершин во все
               u -> *: O(V)         //обходим рёбра из заданной вершины во все
               * -> v: O(V)         //все рёбра в заданную вершину
               u -> v: O(1)         //смотрим на ребро от заданной вершины до заданной

Плюс: можно обходить все рёбра, инцидентные заданной вершине, за O(V) вместо O(E).
Огромный минус: расход памяти O(V^2).
Используется только для работы с плотными графами и для решения задач, когда ограничения позволяют.

> Разреженные и плотные графы.

Если игнорировать кратные рёбра (в большинстве задач это можно сделать), то 0 <= E <= V^2.
В худшем случае рёбер намного больше, чем вершин.
Можно также в оценках полагать, что E >= V, т.к. иначе в графе много изолированных вершин (такие графы редко нужны).

Граф плотный, если E = Theta(V^2).                 //на самом деле, для конкретного графа нельзя писать асимптотически оценки
                                                   //асимптотика работает только в пределе. Можно строго говорить о них для семества графов, например
Если в графе E = Theta(V), или Theta(V * sqrt(V)), или Theta(V^1.5) и т.п., то граф называется разреженным.

На практике чаще всего встречаются линейно разреженные графы, т.е. E = O(V).
Например, нарисованный на плоскости без пересечений рёбер граф (плоский/планарный) всегда такой.
Всевозможные карты реальных дорог тоже подходят под это определение.

Для графов с E = O(V) использовать матрицу смежности нецелесообразно из-за затрат памяти.
Если взять V ~= 10^6 вершин, то список рёбер будет занимать несколько мегабайт, а матрица смежности --- терабайты.


> III. Списки инцидентности/смежности.

Для каждой вершины u храним список всех рёбер, которые выходят из u (или "инцидентны" u).

Обычно список --- это одно из:
  1) Связный список
  2) Растущий массив
В списках можно хранить сами рёбра (Edge), номера рёбер в едином списке (int), или номера вершин на другом конце рёбер (int).

Расходы:
  Память: O(E + V) ~= O(E)
  Время обхода * -> *: O(E)         //обходим рёбра из всех вершин во все
  Время обхода u -> *: O(deg(u))    //обходим рёбра из заданной вершины u во все
Здесь deg(u) --- степень вершин u (размер её списка).

Списки инцидентности являются предпочтительным способом хранения графа для большинства алгоритмов.
Исключение --- работа с плотными графами, для них матриц смежности быстрее (хотя такие графы редко нужны в реальной жизни).

В случае неор. графа обычно каждое ребро раздваивается на ориентированные рёбра в обе стороны.

=============== Алгоритм Флойда-Уоршалла ================

Идея:
Пусть D[u,v] --- длина какого-то пути (текущего наилучшего) из u в v.
Тогда можно улучшить D[u,v] через пром. вершину w:                   D[u,v]
  if D[u,v] > D[u,w] + D[w,v]:                               u ---------------> v
    D[u,v] = D[u,w] + D[w,v]                                  \                /
                                                               \----- w ------/
                                                             D[u,w]       D[w,v]

Если сделать достаточно улучшений в правильном порядке, все пути D[*,*] станут оптимальными.

Изначально в D помещается матрица смежности: D[u,v] --- длина ребра из u в v (если есть кратные рёбра, то минимальное среди таких).
Кроме того, обычно делают D[u,u] = 0, чтобы эти же нули стояли потом в ответе.

Алгоритм:
  D = M                     //копируем матрицу смежности в матрицу D
  for w in V:               //ВНИМАНИЕ: очень важно, чтобы промежуточная вершина перебиралась во ВНЕШНЕМ цикле!
    for u in V:
      for v in V:
        if D[u,v] > D[u,w] + D[w,v]:
          D[u,v] = D[u,w] + D[w,v]
          I[u,v] = w

Замечания:

2) Алгоритм работает при любых весах рёбер, хотя циклов отрицательного веса быть не должно.

3) Время работы O(V^3).
  Способ хранения графа не важен: т.к. сам алгоритм неизбежно работает на матрице, лучше всего подходит матрица смежности.

4) Как найти сам путь из u в v:
  I[u,v] --- это некоторая вершина w на кратчайшем пути из u в v.
  Тогда можно написать рекурсивную функцию, которая выписывает путь из u в v.
  Сначала она достаёт w = I[u,v], потом запускает выписывание пути от u до w и от w до v рекурсивно.

5) Алгоритм поиска транзитивного замыкания для отношения является частным случаем алгоритма Флойда-Уоршалла.
  Можно рассмотреть отношение как граф, в котором каждая пара uv задаёт ребро нулевого веса.


=================== Обход в глубину =====================

Обход графа посещает вершины графа, переходя по рёбрам от одной вершины к другой.
Это позволяет определить, до каких вершин можно добраться из заданной стартовой.

Есть два классических обхода: в глубину (depth-first search, DFS) и в ширину (breadth-first search, BFS).
> Идея DFS --- рекурсивный обход.

void traverse(int u) {
visit(v);
for uv in E:            //перебираем рёбра из вершины u
  traverse(v);
}

Проблема: если в графе есть цикл, то вдоль него будет бесконечная рекурсия.
Если граф ориентированный, то может работать очень долго даже если циклов нет.
(кстати, здесь вполне уместна аналогия с причиной появления #include guard)

Решение: будем отмечать посещённые вершины, и запретим заходить в вершину второй раз:
  void DFS(int u) {
    visited[u] = true;         //отмечаем, что мы посетили v
    for uv in E:
      if (!visited[v])  //запускаем DFS только для ранее непосещённых вершин
        DFS(v);
  }

Для обсуждения того, как работает DFS, нам уточнить пару деталей:
1) Будем хранить пометку mark трёх видов:
    mark[u] == white --- DFS(u) для вершины u ещё не запускался
    mark[u] == gray  --- DFS(u) для вершины u был запущен, но ещё не закончился
    mark[u] == black --- DFS(u) запускался и уже закончился
  В большинстве алгоритмов не нужно различать gray и black пометки,
  поэтому обычного булевого флага visited[u] хватает (как в коде выше).
2) Будем отмечать моменты времени, когда запускается и когда завершается DFS(u).
  Эти моменты времени называются времением входа и выхода (tin[u] и tout[u]) соответственно.
  В момент tin[u] пометка изменяется с white на gray, а в момент tout[u] --- с gray на black.
  Заметим, что время здесь абстрактное: важно лишь, как эти моменты времени сравниваются между собой на больше/меньше.
  Время входа/выхода используется в алгоритмах и при их анализе.

Расширенный DFS выглядит так:
  int T = 0;
  void DFS(int u) {
    tin[u] = T++;
    mark[u] = gray;
    for uv in E:
      if mark[v] == white:
        DFS(v);
    mark[u] = black;
    tout[u] = T++;
  }

================ Топологическая сортировка ===============

Задача топологической сортировки:
  Дан ориентированный граф: вершины = задачи, рёбра = зависимости.
  Если есть ребро uv, то задачу v можно делать только после задачи u.
  Циклов в графе нет (иначе выполнить задачи невозможно).
  Требуется определить, в каком порядке можно выполнить все задачи.

Алгоритм топологической сортировки:
1) Запускаем серию DFS по графу.
2) Упорядочиваем вершины по убыванию tout --- это и есть искомый порядок.

Простая реализация (сохраняем tout[*], потом делает сортировку по tout) работает за O(E + V log V).
Вместо этого лучше просто дописывать вершину u в какой-то глобальный список в конце функции DFS(u).
Легко видеть, что заполненный таким образом список вершин будет упорядочен в порядке увеличения времени выхода, надо будет его лишь развернуть.
Такая реализация работает за O(E + V).

Пример: обходим ацикл. граф и выписываем вершины в tout order.
