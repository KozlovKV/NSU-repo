```c
====================== Растущий массив ====================

Мотивация: требуется массив размера k, причём размер не известен заранее и может изменяться.
Простые варианты:
  1) Создаём очень длинный массив:
    int arr[1<<20];
    проблемы: нужно много памяти, не всегда понятно ограничение сверху на k
  2) Выделяем память в куче:
    int arr = malloc(k * sizeof(int));
    проблемы: что делать при необходимости увеличить k ?

Решение: "растущий" массив (или "динамический" массив)
Это вариант 2 + периодическая реаллокация массива.
В C++ он называется std::vector --- используется для хранения большей части данных.


>> Реаллокация --- увеличение размера массива, выделенного с помощью malloc.
Два варианта реализации (k --- старый размер, newK --- новый размер):

а) С переносом данных:
  int *newArr = malloc(newK * sizeof(int));     //выделяем новый буфер в куче
  memcpy(newArr, arr, k * sizeof(int));         //побайтово копируем старые данные в новый массив
  free(arr);                                    //удаляем старый массив (чтобы не было memory leak)
  arr = newArr; k = newK;                       //далее используем новый буфер

б) Без переноса данных (на месте, in-place):

 +--+--+--+--+--+--+--+--+--+--+--+--+    Если в куче достаточно свободного места после конца блока arr,
 |XX|XX|XX|XX|XX|XX|XX|XX|??|??|??|??|    то можно не перемещать массив, а просто запомнить, что блок arr
 +--+--+--+--+--+--+--+--+--+--+--+--+    теперь имеет длину newK * sizeof(int) байтов.
 |    (k элементов)      | удлинение |
 \arr                    | --------> |

С вариантом (б) проблемы:
1) Его может реализовать только тот, кто реализует кучу --- то есть библиотека языка C.
2) Не всегда это возможно: может мешать другой блок памяти.
   Блоки памяти в C никогда не перемещаются, не меняют адрес.
   (в языках с GC, типа C#/Java, блоки памяти могут перемещаться с починкой всех "указателей")

В языке C (stdlib.h) есть функция realloc:
  arr = realloc(arr, newK * sizeof(int));
  k = newK;
Эта функция сначала пробует применить вариант (б).
Если не получается, то выполняет перемещение данных по варианту (а).


>> Структура растущего массива в общем случае:
  struct Vector {
    int *arr;           //указатель на массив, выделенный на куче
    int cnt;            //сколько элементов в массиве реально есть
    int cap;            //на сколько элементов выделено место в блоке памяти arr  (capacity)
  };
Заметим, что в общем случае cnt может не совпадать с cap.
Например, если с конца массива удалили несколько элементов.
(иногда массив также реаллоцируют при удалениях для сокращения потребления памяти --- но мы не будем)

Как выглядит функция добавления элемента в конец:
  void add(Vector *v, int x) {
    if (v->cnt == v->cap) {
      //реаллоцируем v->arr
    }
    v->arr[v->cnt++] = x;
  }


>> Остаётся вопрос: на сколько реаллоцировать?

1) Реаллоцировать на столько, сколько места надо.
То есть при добавлении одного элемента делать реаллокацию на (v->cnt + 1).

Легко видеть, что для роста массива от размера 1 до размера N требуется порядка N*N/2 копирований элементов.
Всего получается время на реаллокации O(N^2)  (точнее Theta(N^2)).
Например, для массива размера 1 млн время роста будет измеряться часами --- слишком плохо.

Вывод: надо реаллоцировать реже.

2) Экспоненциальная схема реаллокации (хорошо).
Когда не хватает места, увеличиваем размер в 2 раза (или в 1.5 раза, или в C>1 раз).
Размер изменяется: 1 -> 2 -> 4 -> 8 -> 16 -> ...
Если взять N = 2^s --- финальный capacity массива, то для роста требуется скопировать элементов:
  1 + 2 + 4 + 16 + ... + N/2 = N - 1 = O(N)
Получается, что время на рост до размера N составляет O(N) --- то есть асимптотически идеальное время.
В случае N = 1 млн это будет порядка 10 миллисекунд (на самом деле даже быстрее).

Перерасход памяти: в худшем случае в 2 раза (т.е. в константу раз).
Точнее:
   N/2 < maxK <= N
где maxK --- это максимальное значение размера cnt за всю жизнь (для простоты мы НЕ реаллоцируем массив при уменьшении размера).


>> Как оценить время работы одной операции добавления в растущий вектор?

                                       ^               X
График:                                |               X
  время работы / номер операции        |               X
                                       |               X
                                       |       X       X
В худшем случае операция добавления    |       X       X
работает за O(N) (при реаллокации)     |   X   X       X
                                       | X X X X X X X X
                                       +------------------>

Однако если считать время одного добавления O(N), то все оценки на время работы алгоритмов станут излишне пессимистичными.

Выход: амортизированное время работы (amortized time).
Пусть T(N) --- время, затрачиваемое на выполнение N операций над структурой данных (в худшем случае)
Тогда каждая операция работает за:
  O( T(N) / N )   в амортизированном смысле

В случае в растущим массивом быстрые добавления "амортизируют" более медленные но редкие случаи реаллокаций.
Выше показано, что T(N) = O(N), значит амортизированное время одной операции равно O(1).


=========== Структуры данных: последовательности ==========

Последовательность --- структура данных, в которой элементы идут в каком-то порядке, их порядок важен и обычно не изменяется.
Известные структуры данных:

               (1) Массив                                  (2) Связный список
+ произвольный доступ за O(1)                      - произвольный доступ за O(N)
- вставка/удаление в середину за O(N)              + вставка/удаление в середину за O(1) 
+ легко использовать, быстрый по константе         - сложнее использовать, медленный по константе
- при изменении размера нужны реаллокации          + нет проблем с изменениями размера
     (рекомендуется по умолчанию)

Абстрактные структуры данных последовательностей:

>>> stack (стек) = LIFO (last-in first-out)           | |
Работает как стопка очень тяжёлых книг:               +-+  <-- все операции выполняются сверху
                                                      |X|
 |                                                    |X|
 +-+-+-+-+-+-+-+-                                     |X|
 |X|X|X|X|X|X|X|                                      |X|  <-- сюда залезть нельзя, не снимая всё что выше
 +-+-+-+-+-+-+-+-                                     |X|
 |            ^                                     ==+=+==
        конец/вершина --- только здесь можно что-то делать

Операции:
1) push(X) --- добавление X в конце (на вершину) стека.
2) X = pop() --- получение и удаление X с вершины стека --- "извлечение".
  (X = top() --- получение вершины стека без удаления)

Пример применения:
  стек вызовов, в котором лежат стековые кадры (разного размера)

>>> queue (очередь) = FIFO (first-in first-out)
Добавляются элементы в конец, а извлекаются из начала:

               --+-+-+-+-+-+-+-+--
 извлечения <--- |X|X|X|X|X|X|X| <---- добавления
               --+-+-+-+-+-+-+-+--

Операции называются enqueue и dequeue.

Пример применения:
  pipe --- труба для общения между двумя программами (процессами), обычно есть в ОС.

  +~~~+      (pipe)     +~~~+
  (   )-----------------(   )     W --- программа, которая пишет в pipe (например через fwrite)
  ( R )<<go jump exit<<<( W )     R --- программа, которая читает из pipe (например через fread)
  (   )-----------------(   )    
  +~~~+                 +~~~+

Программы пишут/читают либо параллельно, либо последовательно (1 ядро), так что в pipe нужен буфер, куда складывает данные OS.
Этот буфер работает как очередь байтов.
Обычно он фиксированного размера и хорошо реализуется с помощью кольцевого буфера (см. ниже).

>>> deque (дек).
Можно добавлять и удалять элементы как с начала последовательности (pushFront, popFront), так и с конца (pushBack, popBack).
Обобщение стека и очереди (доступ в середину по-прежнему запрещён).

>>> Как реализовывать стек, очередь и дек в программе?

1) На двусвязном списке.
  Есть указатели на начало и конец, так что все операции дека работают за O(1).

2) На массиве.
  Стек:
    int arr[1<<20];     //при желании можно использовать растущий массив
    int cnt;
    push(X): arr[cnt++] = X;
    pop(): return arr[--cnt];
  Очередь:
    int arr[1<<20];
    int beg, end;       //чтобы не сдвигать весь массив влево после удаления, просто запоминаем, где реально начинается очередь
    push(X): arr[end++] = X;
    pop(): return arr[beg++];

С реализацией очереди есть проблема: нужен массив размера K, где K --- общее количество операций добавления за всё время жизни очереди.
Во многих задачах это K легко оценить, так что так очередь реализовывать чаще всего можно.

Пример: в игре на всесибирской 2019 программа игрока и игра общались через пайп.
Каждый кадр игра высылала программе игрока даныне об игровом мире через пайп (примерно 1 МБ) --- 60 кадров в секунду.
Если очередь в таком пайпе делать как описано выше, то размер массива будет постоянно расти, через 5 минут нужно будет 18 ГБ памяти =)
В этом случае через очередь прокачивается огромный объём данных, хотя "живых" элементов в ней всегда мало.

3) Кольцевой буфер (в принципе, тоже на массиве).
Решение проблемы с очередью: давайте зациклим конец массива на начало.
Тогда вместо массива у нас будет кольцо элементов, и это полностью устраняет проблему.

Реализация:
  int arr[1<<20];
  int beg, end;             //может быть beg > end --- тогда последовательность переходит через край массива

  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |8|9|A| | | | | | |1|2|3|4|5|6|7|
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         ^           ^
       (end)       (beg)

При выполнении операций нужно не забывать циклически переносить счётчики beg и end, когда это нужно.

Кольцевой буфер размера N достаточен, пока количество живых элементов меньше N.
Кольцевой буфер реализует все операции дека за O(1), в т.ч. добавления в начало.


================= Стандартная библиотека =================

Схема работы программы:              +-------------+
                                     |  программа  |
                                     |     на C    |
                                     +-------------+
                                fwrite  V       V  fread
                                      ~~~~~~~~~~~~~ 
                                     ( C runtime   )    (также известна как CRT)
                                     (   library   )
                                      ~~~~~~~~~~~~~ 
                  (write или) WriteFile V       V ReadFile (или read)
                                ============================
                               /         OS Library         \
                              /------------------------------\
                             /           OS Kernel            \

Чтобы читать/писать в файл, необходимо просить об этом операционную систему (только она может работать с диском).
Каждую операционную систему нужно просить по-своему.
Поскольку программы на C обычно кросс-платформенные, то просить в программе напрямую операционную систему чаще всего нельзя.
Поэтому между программой и OS обычно стоит стандартная библиотека C --- C runtime library  (библиотека времени исполнения).
Она принимает стандартные вызовы вроде fwrite/fread и общается в операционной системой по мере необходимости.
(кроме того, у CRT есть много других функций)

Интересный факт:
  У Visual C++ библиотека CRT может вставляться прямо в exe-файл, а может загружаться из отдельной dll.
  Когда вы устанавливаете программы, они часто устанавливают "Microsoft VC++ Redistributable" --- в нём как раз содержится dll-версия CRT.
  Если запускать программу не установив его, она будет сразу падать с ошибкой типа "Cannot find msvcp140.dll" --- из этой dll загружается CRT.


Краткий обзор стандартной библиотеки C.
Для подключения пишем директиву:
  #include <имяхедера.h>
Возможности стандартных библиотек легко гуглятся (например http://www.cplusplus.com/reference/)


>> stdlib.h:
  srand / rand --- случайные числа
  malloc / free / calloc / realloc --- работа с динамической памятью (куча)
  exit(0) --- быстрое завершение программы, даже если вызвать не из main
  qsort / bsearch --- быстрая сортировка и бинарный поиск

Как работает qsort:
  int cmp(const void *a, const void *b) {       //функция сравнения должна иметь такую сигнатуру
    int x = *(int*)a;                           //достаём по заданным адресам элементы
    int y = *(int*)b;                           //...
    return (x == y ? 0 : (x < y ? -1 : 1));     //возвращаем одно из:  -1 если a < b
  }                                                                     0 если a = b
  int main() {                                                          1 если a > b
    int arr[1<<20], n;
    ...
    //сортируем arr:
    qsort(
        arr,                                    //адрес начала массива
        n,                                      //количество элементов в массиве
        sizeof(int),                            //размер одного элемента в байтах
        cmp                                     //функция сравнения (подробнее будет позже)
    );
  }
  Аналогично bsearch, но он ещё принимает указатель на элемент, который хочется найти в отсортированном массиве.

>> stdio.h:  функции чтения и записи
  fopen / fclose / freopen --- открытие/закрытие файлов
  fwrite / fread --- бинарный ввод/вывод
  fprintf / fscanf; printf / scanf; sprintf / sscanf --- форматированный текстовый ввод/вывод

>> time.h:
  time(0) --- возвращает текущее время в секундах, начиная с какого-то фиксированного момента
  clock() --- возвращает время в пингвинах начиная с запуска программы
Всего в одной секунде CLOCKS_PER_SEC пингвинов.
Функция clock() удобна для замера времени выполнения секции кода (вызывать "до" и "после").


>> Псевдослучайные числа.
Программы работают детерминированно, и создать в программе случайность нельзя (или очень сложно).
Поэтому обычно используются генераторы ПСЕВДОслучайных чисел.
Такие генераторы работают абсолютно детерминированно, но снаружи выдаваемая последовательность чисел "выглядит как случайная".

Типичная схема работы:

   seed |---> phi(seed) |---> phi^2(seed) |---> phi^3(seed) |---> phi^4(seed) |---> phi^5(seed) |---> ...
                 |               |                 |                 |                 |   
                 V               V                 V                 V                 V   
               rnd[0]          rnd[1]            rnd[2]            rnd[3]            rnd[4]

Здесь:
  seed --- магическое число, которое полностью определяет все генерирующиеся числа (если зафиксировать алгоритм)
  phi --- функция, которая применяется к seed при генерации каждого числа (обычно в программе пишется присваивание: "seed = phi(seed);")
  rnd[0], rnd[1], rnd[2], ... --- последовательность чисел, которую мы видим снаружи, запрашивая псевдослучайные числа у генератора

В общем случае ещё может быть добавлена функция reduce, которая дополнительно применяется к числам, которые выдаются наружу:
  rnd[k-1] = reduce( phi^k(seed) )
Несмотря на то, что задание seed полностью определяет все числа rnd[*],
если хорошо подобрать phi / reduce, то числа rnd[*] будут похожи на случайные (и обычно равномерно распределённые по области значений).

В stdlib.h:
  srand(seed) --- установить текущее значение seed равным заданному числу
  X = rand() --- сгенерировать следующее псевдослучайное число в диапазоне [0 .. RAND_MAX]
Проблема: в stdlib.h значение seed хранится в глобальной переменной --- в мелких программах нормально, в больших реальных программах неудобно.

В случае MSVC:
  RAND_MAX = 32767;                                 //в других компиляторах обычно RAND_MAX = 2^31 - 1
  phi(seed) = (seed * 214013 + 2531011);            //в силу переполнения выполняется по модулю 2^32
  reduce(seed) = (seed >> 16) & 0x7FFF;             //вам возвращаются только старшие 15 битов от seed --- поэтому RAND_MAX = 2^15-1
(это частный пример самого простого генератора, который называется linear congruental generator; если интересно --- почитайте википедию)

Как использовать:
  int randomPercent = rand() % 100;                 //случайное число от 0 до 99 --- примерно равномерно распределено.
Если хочется диапазон больше 30 тыс, то надо комбинировать несколько вызовов rand.

Как вызывать srand:
  srand(12345);         //при повторных запусках rand() будет выдавать одно и то же
  srand(time(0));       //если между запусками проходит хотя бы секунда времени, то rand выдаёт сильно разные последовательности

Дополнительно: пример простейшей программы без CRT можно увидеть в (main_nocrt.c + compile_nocrt.cmd).


>> string.h:
1. Функции работы с памятью:
  memset, memcpy/memmove --- зануление/копирование блока памяти
  memcmp --- лексикографическое сравнение блоков памяти (по байтам), возвращает: -1 (a < b), 0 (a == b) или 1 (a > b).
2. Функции работы со строками:
  strlen --- определяет длину (сколько символов до завершающего нуля)
  strdup --- выделяет для строки буфер в куче и копирует в него содержимое строки (редко нужная функция)
  strcpy --- копирует строку в заданное (другое) место, включая нулевой байт
  strcmp --- сравнивает две строки лексикографически, возвращает -1 / 0 / 1
  strchr --- ищет первое вхождение заданного символа в строку, возвразает указатель на него
  strstr --- ищет первое вхождение заданной подстроки в строке
  strncpy, strncmp --- варианты с ограничением длины строк
  strtok --- выделение слов (token-ов) из строк

Применение strtok:   
  char str[1024] = " .. aba .c.b efg . t .";
  for (char *t = strtok(str, ". "); t; t = strtok(0, ". "))
    printf("(%s) ", t);                                        //печатает: (aba) (c) (b) (efg) (t)
Второй аргумент --- список символов-разделителей.
Первый аргумент --- указатель на строку при первом вызове, и ноль при последующих.
Проблемы strtok:
  1) изменяет строку, которую передали (вставляет туда нулевые символы в конце каждого токена)
  2) хранит в глобальной переменной, откуда продолжать искать слова (чтобы работали вызовы с нулевым первым параметром)

>> assert.h:
  assert(условие) --- падает, если условие не выполнено, и пишет при этом красивое сообщение.
В конфигурации release обычно все assert-ы удаляются (используя макросы препроцессора).
В nsuts assert-ы остаются и проверяются.

>> stdint.h / limits.h:
  типы вроде uint64_t объявлены в stdint.h
  константы вроде INT_MAX объявлены в limits.h

>> math.h: работа с вещественными числами (double)
  fabs --- абсолютное значение
  floor / ceil --- округление вниз/вверх до целого
  fmod --- остаток от деления (например, fmod(5.7, 1.3) = 0.5)
  sqrt --- квадратны корень
  pow, exp, log --- возведение в степень, экспонента с показателем, натуральный логарифм
  sin, cos, tan --- тригонометрические функции
  asin, acos, atan --- обратные тригонометрические функции
  atan2 --- удобный способ вычисления полярного угла.

Если есть вектор V = (x, y), тогда phi = atan2(y, x) --- это его полярный угол в диапазоне [-pi .. pi].
```