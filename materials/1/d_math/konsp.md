- [Лекторы](#лекторы)
- [23.02.13 - лекция](#230213---лекция)
  - [Способы представления графов](#способы-представления-графов)
  - [Изоморфизм](#изоморфизм)
  - [Связные графы](#связные-графы)
  - [Двудольные графы](#двудольные-графы)
- [23.02.13 - семинар](#230213---семинар)
  - [Специальные графы](#специальные-графы)
- [23.02.20 - лекция](#230220---лекция)
  - [Использование матриц смежности для анализа графов](#использование-матриц-смежности-для-анализа-графов)
  - [Деревья](#деревья)
  - [Уровень, высота и баланс деревьев](#уровень-высота-и-баланс-деревьев)
- [23.02.27 - лекция](#230227---лекция)
  - [Деревья выборов](#деревья-выборов)
  - [Префиксные коды и деревья Хаффмана](#префиксные-коды-и-деревья-хаффмана)
  - [Остовные деревья](#остовные-деревья)
  - [Breadth-first search](#breadth-first-search)
  - [Кратчайшее расстояние между вершинами](#кратчайшее-расстояние-между-вершинами)
  - [Алгоритм Прима](#алгоритм-прима)
  - [Алгоритм Краскала](#алгоритм-краскала)
- [23-03-06 - лекция](#23-03-06---лекция)
  - [Depth-first search](#depth-first-search)
- [23.03.13 - лекция](#230313---лекция)
  - [Количество остовных деревьев](#количество-остовных-деревьев)
    - [Алгоритм стягивания ребра](#алгоритм-стягивания-ребра)
    - [Теорема для полного графа](#теорема-для-полного-графа)
    - [Метод Лапласиана](#метод-лапласиана)
  - [Связность](#связность)
- [23.03.13 - семинар](#230313---семинар)
  - [Типы рёбер при DFS](#типы-рёбер-при-dfs)
  - [Ещё раз о счёте остовных деревьев](#ещё-раз-о-счёте-остовных-деревьев)
    - [Ещё немного про стягивание ребра](#ещё-немного-про-стягивание-ребра)
- [23.03.20 - лекция](#230320---лекция)
  - [Продолжаем про связность](#продолжаем-про-связность)
  - [Двусвязность](#двусвязность)
  - [ST-нумерация](#st-нумерация)
- [23.03.27 - лекция](#230327---лекция)
  - [Алгоритм Беллмана-Форда](#алгоритм-беллмана-форда)
- [23.04.03 - лекция](#230403---лекция)
  - [Алгоритм Дейкстры](#алгоритм-дейкстры)
  - [Поиск кратчайшего пути между всеми парами вершин](#поиск-кратчайшего-пути-между-всеми-парами-вершин)
    - [Кратчайшие пути через матричное умножение](#кратчайшие-пути-через-матричное-умножение)
- [23.04.10 - лекция](#230410---лекция)
  - [Флойд-Уоршелл (*снова*)](#флойд-уоршелл-снова)
  - [Флойд-Уоршалл с восстановлением путей на Си](#флойд-уоршалл-с-восстановлением-путей-на-си)
  - [Алгоритм Джонсона](#алгоритм-джонсона)
- [23.04.17 - лекция](#230417---лекция)
  - [Обходы Эйлера и Гамильтона](#обходы-эйлера-и-гамильтона)


# Лекторы
Апанович Зинаида Владимировна

Семинарист - Морозов Дмитрий

# 23.02.13 - лекция
## Способы представления графов
- Перечисление
- Список смежности (для ориентированного графа мы указываем, в какие вершины ведут рёбра из данной)
- Матрица смежности (adjacency matrix) - таблица `n*n`, где (`n` - кол-во вершин в графе). `matrix[i][j] = 1 <=> (i, j) in edges`. Для мультиграфов вместо единички записывается количество рёбер.

Если `|E| >= 0.5|V|` => оптимальнее использовать матрицу смежности. При этом в матрице мы узнаём наличие ребра за `O(1)`, Тогда как в списке за `O(n)` (но ведь можно таблицу представить как массив, тогда тоже будет... *Не, это получается уже почти матрица*)

Матрица инцидентности:
- Вершины - строки
- Рёбра - столбцы
- `matrix[i][j] = 1 <=> v_i in e_j` (для нециклических рёбер в столбце всегда будет 2 единицы)
- *IMO - куда менее удобная форма*
- Для направленного графа точку начала обозначают как `-1`, а конца - `1`

## Изоморфизм
2 простых графа `G1` и `G2` - изоморфны, если существует биекция `f`, сохраняющая отношение смежности для вершин и рёбер графов `G1' = f(G1)` и `G2' = f(G2)`

=> Следующие обязательные условия для изоморфизма:
1. Одинаковое кол-во вершин
2. Одинаковое кол-во рёбер
3. Количество вершин с определёнными степенями одинаково

Выше приведены необходимые, но недостаточные условия изоморфизма.

Если для двух графов можно построить идентичные матрицы смежности, значит между ними существует изоморфизм.

## Связные графы
**О.** Путь - последовательность рёбер, первое из которых содержит начальную точку (для ориентированного графа - на первом месте), а последнее - конечную точку (для ориентированного графа - на втором месте).

Также можно расширить путь до маршрута - перед и после ребра указывать в последовательности вершины.

Можно указывать путь через вершины, если нет кратных рёбер

**О.** Граф называется связным (connected), если существует путь между двумя любыми его вершинами.

**Т.** Для связного графа между двумя любыми вершинами существует простой путь (*Если в пути есть повторяющиеся подпоследовательности, избавляемся от копий и тогда как раз получаем простой путь*)

Максимальный связный подграф - *пояснения излишни*, Связные подграфы называются компонентами связности.

Если в одном графе есть путь длины `n`, а в другом точно нет пути такой же длины => графы точно не изоморфны.

Если же мы возьмём в двух графах пути, включающие все вершины. При этом в обоих путях степени у смежных вершин одинаковы, мы имеем уже куда более крепкие основания говорить об изоморфизме, который можно подтвердить, построив графы

## Двудольные графы
Если в графе есть треугольные подграфы => исходный граф не двудольный.

**Т.** Граф является двудольным, если его можно окрасить в 2 цвета таким образом, что любые смежные вершины имеют разный цвет

**Т.** Граф двудольный тогда и только тогда, когда в нём не существует замкнутого пути нечётной длины (за длину мы считаем кол-во рёбер). Обратное утверждение: если все циклические пути имеют чётную длину, значит граф двудольный

# 23.02.13 - семинар
## Специальные графы
- Циклический - из любой точки есть непересекающийся путь в неё же (листьев быть не должно)
- Колесо - циклический граф с центральной вершиной
- Полный граф - все вершины связаны со всеми
- Гиперкубы

**Л.** "О рукопожатиях". Сумма всех степеней вершин в ненаправленном графе равна `2*|E|`

Для полного графа `|E| = n*(n-1)/2`

Максимальное количество рёбер в двудольном графе ` = (n-1)(n+1)/4`

Либо граф, либо его дополнение обязательно будут связными.

Самодополнительные графы - графы, которые изоморфны своему дополнению.

Любой гиперкуб можно представить как двудольный граф

# 23.02.20 - лекция
## Использование матриц смежности для анализа графов
Матрицы смежности могут использовать для подсчёта количества путей в графе.

Для любого графа G матрица ячейка `(i, j)` матрицы смежности в степени `k` - кол-во путей из `v_i` в `v_j` длины `k`

След матрицы (`trace`) - сумма главной диагонали матрицы смежности в степени `k`. С помощью следа можно вычислять некоторые характеристики графов:
- `t(A^2) = 2|E|` (Для неориентированного графа)
- Кол-во треугольников в графе `trianglesCnt = t(A^3)/6`
- $t(a^4) = 8q - 2E + 2 \sum_{i=1}^{|V|} \deg^2(v_i)$

Графы с `|V| >= 2` связные `<=>` 

Матрица смежности дополнения графа - матрица, где все ячейки изначально равные нулям (не считая диагональных), равны единицам - и наоборот.

`A + A' + I = J`

Если матрица симметрична, то все с.з. будет вещественными, а с.в. будут взаимноортоганальны.

**О.** Характеристический полином матрицы смежности - `det(tI - A)`

**О.** Спектр графа - набор скаляров собственных значений графа.

Любое собственное значение графа не превосходит его максимальную степень.

Регулярный граф - граф, в котором все степени вершин одинаковы. Если будем считать, что степень вершин равна `k`, то это и будет собственное значение.

Спектры изоморфных графов идентичны.

## Деревья
**О.** Деревья - это связные ненаправленные ациклические графы

**О.** Лес - несколько несвязных деревьев

Любая из вершин дерева может быть выбрана как корень, относительно которого мы сориентируем всё дерево.

**О.** Корневое дерево называется `m`-арным дерево, если каждый из его внутренних элементов имеет `<= m` потомков

**О.** Если у каждой внутренней вершины ровно `m` потомков, то это дерево называется полным (`full`) `m`-арным деревом

**О.** Заполненное (`complete`) `m`-арное дерево - подмножество полных деревьев, где до максимальной глубины существуют все вершины.

**Т.** В каждом дереве с `n` вершинами ровно `n-1` рёбер. *Доказывается индукцией с обходом в глубину до листа и его откидыванием (фактически, это будет индукция не по сложению, а по вычитанию)*

Таким образом, мы получаем 3 утверждения

**Т.** `Full` `m`-арное дерево с `i` количеством внутренних вершин. Для него можно вычислить кол-во вершин как `n = mi + 1`

**Т.** Если нам известен один из параметров `full` `m`-арного дерева, мы можем вычслить остальные:
1. Известно количество вершин `n`:
   1. Внутренние вершины `i = (n - 1)/m`
   2. Листья $l = \frac{(m - 1)n + 1}{m}$
2. Известны внутренние вершины `i`:
   1. `n = mi + 1`
   2. `l = (m - 1)i + 1`
3. Листья `l`:
   1. `n = (ml - 1)/(m - 1)`
   2. `i = (l - 1)/(m - 1)`

## Уровень, высота и баланс деревьев
**О.** Уровень вершины в дереве - это длина пути от вершины до корня. (*Соответственно, уровень корня ` = 0`*)

**О.** Высота дерева - максимальный уровень вершин в дереве

**О.** `m`-арное корневое дерево будет **сбалансированным**, если всего его листья находятся на высоте `h` или `h - 1`

**Т.** В `m`-арное дереве высоты `h` количество листьев `l <= m^h`

**С.** Для `m`-арного дерева с количеством листьев `l`: $h \ge ceil(\log_m l)$. Для полного сбалансированного дерева: $h = ceil(\log_m l)$

# 23.02.27 - лекция
## Деревья выборов
**О.** Деревья выборов - деревья, в которых каждая вершина репрезентует выбор одного из вариантов, а листья в поддереве под ней ему соответствуют.

**О.** Пусть от корня до листа в дереве выборов называется **возможным решением**

Дерево выборов можно использовать для поиска наиболее оптимальных вариантов поиска одного отличающегося объекта из множества или для оценки сложности алгоритмов сортировок.

## Префиксные коды и деревья Хаффмана
**О.** Префиксными кодами называются такие коды, каждый из которых не содержит в начале себя другой код, что позволяет нам однозначно понимать, где кончается один код и начинается другой.

Префиксные коды можно изобразить в виде бинарного дерева. Символы будут обозначены названиями листьев, а их коды - пути к ним. Левое ребро обозначается нулём, а правое - единицей.

Для построения максимально экономного дерева (символы, чаще встречающиеся в тексте, будут иметь более короткий код) используется алгоритм Хаффмана:
- Представляем каждый символ как дерево из одной вершины и обозначаем его вес, то есть частоту повторения в тексте
- Берём 2 дерева с наименьшим весом и собираем их в одно. Левым поддеревом становится то, у которого вес больше, а правым - меньше. Весом нового дерева будет считать сумму весов его поддеревьев
- Повторяем прошлый пункт до тех пор, пока все деревья не сольются в одно

**Если мы использует для кодирования не только `0, 1`, то для расчёта количества листьев у самого первого дерева нужно использовать формулу `((N-1) % (m-1)) + 1`, где `N` - количество разных символов для кодирования, а `m` - основание системы счисления**

## Остовные деревья
**О.** Остовное дерево - граф, содержащий все вершины исходного графа и являющийся при этом деревом. **Остовное дерево может быть только у связного графа.** Остовных деревьев у заданного графа может быть много.

**Т.** Простой граф будет связным тогда и только тогда, когда у него есть остовное дерево.

Построить остовное дерево можно удалением рёбер из циклов, но это будет неэффективный алгоритм.

Эффективным алгоритмами будут [**breadth-first search (поиск в ширину)**](#breadth-first-search) и [**depth-first search (поиск в глубину)**](#depth-first-search), а также [алгоритм Прима](#алгоритм-прима) и алгоритм Краскала для взвешенных неориентированных графов

## Breadth-first search
Поиск в ширину заключается в том, что мы выбираем вершину входа (будущий корень остовного дерева), затем подсоединяем к ней все доступные вершины и маркируем их. Далее идём в каждую из вершин и подсоединяем её детей, если они ещё не были промаркированы. Повторяем алгоритм, пока не обойдём все вершины.

**Расширенная версия алгоритма:** добавляем всем вершинам такие параметры, как цвет, расстояние до корня и адрес родителя. Изначально все элементы окрашены в белый, не имеют родителя и расстояние до корня равно бесконечности. Также используем очередь по принципу `FIFO`
- Окрашиваем корневую вершину в серый и присваиваем ей дистанцию `0`. Предка нет.
- Добавляем корень в очередь
- `while queue.notEmpty`:
  - Берём из очереди вершину
  - Обходим все доступные из данной вершины
  - Если вершина белая, помечаем её серым, сохраняя родителем текущую вершину и расстояние до него ` + 1`
  - Добавляем окрашенные серым вершины в очередь
  - Когда с текущей вершиной мы полностью закончили, окрашиваем её в чёрный и берём новую вершину из очереди

Скорость алгоритма - `O(V + E)`

## Кратчайшее расстояние между вершинами
**О.** Кратчайшая длина пути из $s$ в $v$ обозначается как $\delta(s, v)$

**Л.** Если в графе существует путь `(u,v)`, то $\delta(s,v) \le \delta(s,u) + 1$ (*Если `u` достижима из `s`, то мы либо дойдём из `s` до `v` через `u`, либо дойдём до `v` раньше, чем до `u`*)

**Л.** [BFS](#breadth-first-search) позволяет найти все кратчайшие расстояния (**для графов без веса рёбер**) (*доказывается индукцией благодаря очереди типа `FIFO` в алгоритме и прошлой лемме*)

**Т.** Для заданного графа `BFS2` от данной вершины обойдёт все доступные вершины и при том вычислит для них кратчайшее расстояние (*Странная теорема, потому что одно её положение следует из определения алгоритма, а второе - из леммы выше*)

`BFS2` даёт нам **breadth-first tree**

## Алгоритм Прима
Позволяет построить минимально весящее остовное дерево. Из исходного графа берём произвольную вершину, затем смотрим её рёбра и добавляем ребро с наименьшим весом (*и вершину на его конце - ваш кэп*), затем в полученном дереве также проверяем все рёбра, соединяющие вершины дерева с вершинами вне дерева и выбираем минимальное из этих рёбер. Повторяем, пока все вершины не попадут в дерево.

[Демонстрация](https://ru.wikipedia.org/wiki/Алгоритм_Прима#Пример)

*Доказательство минимальности веса остовного графа, полученного алгоритмом Прима: (* Дописать, если не забью *)*

## Алгоритм Краскала
Позволяет построить минимально весящее остовное дерево. Получаем список всех рёбер, затем добавляем минимальное по весу ребро, если оно не вызывает появление цикла. Повторяем до тех пор, пока в списке не останутся лишь рёбра, добавление которых приведёт к возникновению цикла. **PROFIT**

[Демонстрация](https://ru.wikipedia.org/wiki/Алгоритм_Краскала#Пример)

# 23-03-06 - лекция
## Depth-first search
Добавляем корень дерева (*точку входа*) и далее запускаем рекурсивный алгоритм:
1. `while <можем от последней добавленной вершине перейти к ещё не добавленной>`
  1. Добавляем инцидентное последней добавленной вершине ребро с другой вершиной, ещё не добавленной в дерево (*если таковых несколько, берём первую по порядку в нашем представлении графа*)
2. `while <нельзя добавить новых вершин>`
   1. Движемся по добавленным вершинам от конца к началу
3. `if <не дошли до корня>`
   1. Повторяем с пункта `1`
4. `else` - **PROFIT**

Версия на псевдокоде:
```
G - connected graph with vertices v1, ..., vn
T - result tree

visit(v):
  for w that {w adjacent v and w not_in T}:
    add w and edge (v, w) to T
    visit(w)

visit(v1)
```

**Расширенная версия**: предки сохраняются у вершин также, как в BFS2, а окрашивание идёт по следующему принципу: изначально вершины белые, когда мы спускаемся по ним вниз, окрашиваем в серый, когда выходим обратно и покидаем (то есть мы не можем из этой вершины больше перейти ни в какую) - в чёрный. Кроме того, мы храним не только глубину `d`, но и момент обратного выхода `f`, причём хранят они не глубину как таковую, а что-то вроде таймстэмпа. `v.d < v.f`

Псевдокод:
```
for v in G.V:
  v.color = WHITE
  v.pi = NIL

time = 0

for v in G.V:
  if v.color == WHITE:
    visit(G, v)

visit(G, v):
  time++
  v.d = time
  v.color = GRAY
  for u in G.adj[v]:
    if u.color == WHITE
      u.pi = v
      visit(G, u)
  v.color = BLACK
  time++
  v.f = time
```

# 23.03.13 - лекция
## Количество остовных деревьев
### Алгоритм стягивания ребра
Алгоритм для поиска кол-ва остовных деревьев:
- Стягиваем связанные между собой вершины в одну вершину. 
- Количество остовных деревьев исходного графа - сумма кол-ва остовных деревьев со стянутыми вершинами и деревьев, где стянутого ребра нет.
- Пока каждый граф в суммме не будет деревом, продолжаем удаление и стягивание

### Теорема для полного графа
**Формула Келли**: Кол-во остовных деревьев для `n`-дерева = `n^(n-2)`

**Использование на практике:** Выбираем лист с наименьшим номером. Записываем в код Прюфера вершину, смежную с данной, затем удаляем этот лист. Повторяем до тех пор, пока не останется одно ребро (т.е. дерево не будет состоять из двух листьев).

Обладая кодом Прюфера, можно восстановить остовное дерево: в код Прюфера не входят листья, при этом выбирали мы листья с наименьшим номером, поэтому идёт прямо по коду, добавляя к вершинам из кода листья с соответствующими номерами (*номера возрастают с пропуском входящих в код вершин (когда мы добавили лист к коду, мы вычёркиваем эту запись из кода)*)

### Метод Лапласиана
Матрица Лапласа:
- `i == j => a_ij = deg v_i`
- `(i, j) in E => a_ij = -1`
- `otherwise => a_ij = 0`

**Т. Киргоффа о связи матриц и деревьев:** кол-во остовных деревьев в графе можно посчитать как определитель матрицы Лапласа, из которой мы удалили любую строку и столбец.

## Связность
*Повторим:* граф называется связным `<=>` из любой его вершины можно попасть в любую. Имеет одну компоненту связности.

**Cut-vertices (разделяющие вершины)** - вершины, при удалении которых (по одиночке) граф перестаёт быть связным. Существуют также **cut-edge (мосты)**.

Не у всех графов есть cut-vertices и cut-edge. Графы без них называются **nonseparable (ЕДИНЫМИ И НЕДЕЛИМЫМИ!)**.

Число вершинной связности ($\kappa(G)$) - минимальное число вершин, которое нужно удалить для дробления графа на отдельные компоненты связности. Граф называется `k`-вершинно связным, если `k` - число вершинной связности.

Аналогичным образом вводится понятие рёберной связности ($\lambda(G)$). Зачастую рёберная связность больше вершинной.

Для любого графа рёберная связность `<= min deg v` $ = \delta(G)$

$\kappa(G) \le \lambda(G) \le \delta(G)$

# 23.03.13 - семинар
## Типы рёбер при DFS
DFS создаёт 4 типа рёбер:
- Древесные (tree) - простое ребро, по которому мы идём в глубину
- Прямые (forward) - ребро, ведущее из родителя в уже посещённого потомка по другому пути 
- Обратные (back) - ребро, ведущее из потомка в родителя
- Поперечные (cross) - ребро, ведущее из одного поддерева в другое уже посещённое

Из определения следует, что в ориентированном графе есть все виды рёбер, а в неориентированном - только tree и back

## Ещё раз о счёте остовных деревьев
### Ещё немного про стягивание ребра
Дополнение к [этому методу](#алгоритм-стягивания-ребра): если у нас в графе возникает cut-vertex, то мы можем разорвать граф по этой вершине, продублировав её в двух новых графах. Тогда кол-во остовных деревьев в исходном графе будет равно произведению кол-ва остовных в новых двух графах

# 23.03.20 - лекция
## Продолжаем про связность
Разделяющей вершиной называется такая, для которой можно подобрать пару вершин, чтобы путь из одной в другую обязательно проходил через разделяющую вершину.

Любое ребро в связном графе будет либо разделяющим, либо входить в цикл.

Слабо связным графом называется ориентированный граф, который при замене направленных дуг на неориентированные рёбра, станет связным.

Сильно связным графом называется ориентированный граф, в котором можно из любой вершины добраться в любую по направленным дугам.

Ориентированный граф называется связным `<=>` Из любой вершины можно попасть в любую и обратно. Для нескольких сильных или слабых компонент возможны 2 ситуации: компоненты эквивалентны или компоненты не пересекаются

## Двусвязность
Двусвязные графы - графы с $\kappa(G) = 2$, то есть у него нет *cut-vertices*.

**Граф из двух вершин также будет считаться двусвязным, если исходить из определения разделяющих вершин через тройки вершин**

**Л. 2** Для неориентированного графа в его depth-first-tree. Вершина `a` из этого дерева - `cut-vertex`, если:
- `a` - корень => у неё есть несколько потомков 
- `a` - не корень и у неё найдётся такое поддерево `S`, что ни одна из его вершин не будет иметь `back`-рёбер, ведущих в предков `a`. Именно `S` при вырезании `a` в таком случае станет компонентой связности

**Нижняя точка** - наименьший номер вершины, в которую можно попасть по бэк-ребру (при этом переход по бэк-ребру - последний шаг в поиске). (`min(cur.d, {u.low | u in children of cur}, {v.d | v in back-vertices of cur})`). Находится модификацией DFS и сравнением данных при выходе из вершины. **Очень важно отметить, что из-за поля в множестве потомков поиск параметра `.low` будет рекурсивно-хвостовым**

## ST-нумерация
Если граф двусвязный, то можно взять ребро `s-t`. Дать `s` номер 1, а `t` - номер `n = |V|`, а затем дать все остальным связанным с `s` и `t` промежуточные номера из интервала `(1, n)`

# 23.03.27 - лекция
*Кажется тут должно что-то быть про ST-нумерацию и кратчайшие пути через алгоритм Беллмана-Форда*

*Про кратчайшие пути решили повторить)*

**Л.** Подпуть кратчайшего пути также будет кратчайшим путём

## Алгоритм Беллмана-Форда
Позволяет находить кратчайший путь из одной вершины в другую

Вспомогательные функции
```
init(G, s):
for vertex v in G.V:
  v.d = inf
  v.pi = NUL
s.d = 0

# w - функция веса, возвращающая вес ребра между переданными вершинами (гарантируется, что такое ребро существует)

relax(u, v, w):
  if v.d > u.d + w(u, v):
    v.d = u.d + w(u, v)
    v.pi = u
```
Основной алгоритм
```
init(G, s)

for i = 1 to |G.V| - 1:
  for edge (u,v) in G.E:
    relax(u, v, w)

# Проверка на достижимые циклы отрицательного веса
for edge (u,v) in G.E:
  if v.d > u.d + w(u,v):
    return FALSE
return TRUE
```

**Т. О корректности алгоритма Беллмана-Форда**
После запуска алгоритма Беллмана-Форда из вершины `s` графа `G` возможны 2 случая:
1. Если в графе нет циклов отрицательного веса, достижимых из `s`, алгоритм установит в качестве `v.d` кратчайший путь из `s` в `v`, а параметр предка позволит построить дерево кратчайших путей (*Доказывается из вышеозвученной (тут её нет) леммы*)
2. Если в графе есть циклы отрицательного веса, достижимые из `s`, алгоритм вернёт `FALSE` (*Доказывается от противного*)

После этого алгоритма можно проверить граф на связность: если ещё раз пройтись по всем рёбрам и будет найдено ребро, которое 

# 23.04.03 - лекция
## Алгоритм Дейкстры
Работает гораздо быстрее, но только на графах **без отрицательных** рёбер. Вспомогательным будет множество `S`, содержащее те вершины графа, для которых уже определён кратчайший путь.

```
init(G, s)

S = []
Q = G.V

while Q.notEmpty:
  u = extractMin(Q)  # Извлекаем вершину с минимальным .d
  S += [u]
  for vertex v in G.adj[u]
    relax(u, v, w) 
```
Функции `init` и `relax` аналогичный одноимённым функциям из [алгоритма Беллмана-Форда](#алгоритм-беллмана-форда)

**Т. О корректности алгоритма Дейкстры** Алгоритм Дейкстры, запущенный на графе без отрицательных рёбер, даст нам кратчайшие пути из исходной вершины  и построит дерево кратчайших путей (*половина теоремы Беллмана-Форда, в общем*)

Эффективность алгоритма - `O(|V|^2)`

## Поиск кратчайшего пути между всеми парами вершин
*Запись вида $x^(n)$ будет означать состояние $x$ на $n$-й итерации.*

Матрица предществования `P`:
- `p_ij = NIL <=> i = j or no path from i to j`
- `p_ij` -  предок `j` на кратчайшем пути из `i` в `j`

То есть для `P(0)`: `p_ij = i` (если есть ребро)

Благодаря этой матрице мы можем построить подграф предшественников для любой из вершин.

### Кратчайшие пути через матричное умножение
`W` - матрица весов (`w_ij` - путь из `i` в `j`)

`L^m` - матрица длины пути из `m` вершин, где `l_ij` - длина кратчайшего пути. Таким образом, ответ будет в матрице `L^(n-1)`

$$
l^{(m)}_{ij} = min\{l^{(m-1)}_{ik} + w_{kj}\}
$$

# 23.04.10 - лекция
*Продолжаем про кратчайшие пути между всеми парами*
## Флойд-Уоршелл (*снова*)
Последовательно рассматриваем пути для которых вершина `k` не является промежуточной, а все вершины `[1, k-1]` могут быть промежуточными, для каждой вершины из этого множества выполняется то же условие, что и для `k`. Получаем динамический алгоритм расчёта всех путей.

Если действовать руками: для итерации `k` берём `k`-ю строку и `k`-й столбец. Для расчёта `i`-строки берём `k`-ю строку и прибавляем к ней `i`-й элемент `k`-го столбца. В новой матрице путей обновляем в `i`-й строки те ячейки, значения в которых получились меньше, чем на прошлом этапе.

Эффективность `O(|V|^3)`

Матрица с путями длины `n` в таком случае будет обозначаться `D^(n)`.

Если мы заменили `d_ij` на `d_ik + d_kj`, то ячейка матрицы предшествования `p_ij = p_kj`

Для восстановления пути из `i` в `j` мы берём предшественника `v`, равного `p_ij`, добавляем `v` в конце пути и берём `v = p_iv` до тех пор, пока `v != i`

## Флойд-Уоршалл с восстановлением путей на Си
Восстановление пути здесь происходит рекурсивным методом. В матрице "посредников" сохраняется какая-то вершина на пути из `i` в `j`, если вершины там есть, если между `i` и `j` непосредственно ребро, то в матрице будет `-1`
```c
#include "stdlib.h"
#include <stdio.h>
#include <string.h>

#define BIG_INT 400000000
#define STR_BUF_SZ 32768

typedef struct MatrixGraph {
    int n;
    int **matrix;
    int **verticesBetween;
    char *wayBuffer;
    char *bufferFreePtr;
    int wayLen;
} MatrixGraph;

MatrixGraph* initMatrixGraph(int n) {
    MatrixGraph *matrixGraph = (MatrixGraph*) calloc(1, sizeof(MatrixGraph));
    matrixGraph->n = n;
    matrixGraph->matrix = (int**) calloc(n, sizeof(int*));
    matrixGraph->verticesBetween = (int**) calloc(n, sizeof(int*));
    matrixGraph->wayBuffer = (char *) calloc(STR_BUF_SZ, sizeof(char));
    for (int i = 0; i < n; ++i) {
        matrixGraph->matrix[i] = (int *) calloc(n, sizeof(int));
        matrixGraph->verticesBetween[i] = (int *) calloc(n, sizeof(int));
        for (int j = 0; j < n; ++j) {
            matrixGraph->matrix[i][j] = i == j ? 0 : BIG_INT;
            matrixGraph->verticesBetween[i][j] = -1;
        }
    }
    return matrixGraph;
}

void readEdges(MatrixGraph *matrixGraph, int edgesCnt) {
    int a, b, time;
    for (int i = 0; i < edgesCnt; ++i) {
        scanf("%d %d %d\n", &a, &b, &time);
        a--;
        b--;
        if (matrixGraph->matrix[a][b] > time) {
            matrixGraph->matrix[a][b] = time;
        }
    }
}

void freeMatrixGraph(MatrixGraph *matrixGraph) {
    for (int i = 0; i < matrixGraph->n; ++i) {
        free(matrixGraph->matrix[i]);
        free(matrixGraph->verticesBetween[i]);
    }
    free(matrixGraph->matrix);
    free(matrixGraph->verticesBetween);
    free(matrixGraph->wayBuffer);
    free(matrixGraph);
}

void floydWarshall(MatrixGraph *matrixGraph) {
    for (int k = 0; k < matrixGraph->n; ++k)
        for (int i = 0; i < matrixGraph->n; ++i)
            for (int j = 0; j < matrixGraph->n; ++j)
                if (matrixGraph->matrix[i][j] > matrixGraph->matrix[i][k] + matrixGraph->matrix[k][j]) {
                    matrixGraph->matrix[i][j] = matrixGraph->matrix[i][k] + matrixGraph->matrix[k][j];
                    matrixGraph->verticesBetween[i][j] = k;
                }
}

void printToBuffer(MatrixGraph *matrixGraph, int val) {
    char tmpStr[6] = "";
    sprintf(tmpStr, "%d ", val);
    strcpy(matrixGraph->bufferFreePtr, tmpStr);
    matrixGraph->bufferFreePtr += strlen(tmpStr);
}

void printWayToBuffer(MatrixGraph *matrixGraph, int a, int b, int beg, int end) {
    int w = matrixGraph->verticesBetween[a][b];
    if (w == -1) {
        if (a == beg)
            printToBuffer(matrixGraph, a+1);
        if (b == end)
            printToBuffer(matrixGraph, b+1);
        return;
    }
    matrixGraph->wayLen++;
    printWayToBuffer(matrixGraph, a, w, beg, end);
    printToBuffer(matrixGraph, w+1);
    printWayToBuffer(matrixGraph, w, b, beg, end);
}

void shortestWaysProcessing(MatrixGraph *matrixGraph, int shortestWaysResponses, int* responsesDestinations) {
    int a = 0, b;
    for (int i = 0; i < shortestWaysResponses; ++i) {
        b = responsesDestinations[i] - 1;
        matrixGraph->wayLen = 2;
        matrixGraph->bufferFreePtr = matrixGraph->wayBuffer;
        printWayToBuffer(matrixGraph, a, b, a, b);
        printf("%d  %d  %s\n", matrixGraph->matrix[a][b], matrixGraph->wayLen, matrixGraph->wayBuffer);
    }
}
```

## Алгоритм Джонсона
Самый быстрый - `O(V^2 lg V + VE)`

Если в графе нет отрицательных рёбер, мы просто запускаем [алгоритм Дейкстры](#алгоритм-дейкстры) для всех вершин.

Если есть отрицательные рёбра (*но не отрицательные циклы, ясное дело*), то мы пересчитываем все веса по двум следующим правилам:
- Пути, бывшие кратчайшими, должны таковыми и остаться
- Новые веса должны быть позитивными (*весёёёлыми!!11!!!1!!!!1!!*)

Для начала отметим, что преобразование `w'(u,v) = w(u, v) + h(u) - h(v)`, то есть все кратчайшие пути останутся кратчайшими.

Далее добавим к графу вершину `s` с рёбрами нулевого веса и запустим от неё [алгоритм Беллмана-Форда](#алгоритм-беллмана-форда).

Определим `h(v) = path[v]`, рассчитанный Беллманом. Теперь мы можем перевзвесить рёбра так, что они все будут `>= 0`

# 23.04.17 - лекция
## Обходы Эйлера и Гамильтона
**О.** Эйлеровый цикл графа - простой цикл, содержащий все вершины графа

*Пока что не уверен в верности дифиниции*
**О.** Гамильтонов цикл или Эйлеров путь - простой путь, содержащий все вершины графа `G`