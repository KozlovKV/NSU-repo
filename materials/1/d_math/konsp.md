- [Лекторы](#лекторы)
- [23.02.13 - лекция](#230213---лекция)
  - [Способы представления графов](#способы-представления-графов)
  - [Изоморфизм](#изоморфизм)
  - [Связные графы](#связные-графы)
  - [Двудольные графы](#двудольные-графы)
- [23.02.13 - семинар](#230213---семинар)
  - [Специальные графы](#специальные-графы)
- [23.02.20 - лекция](#230220---лекция)
  - [Использование матриц смежности для анализа графов](#использование-матриц-смежности-для-анализа-графов)
  - [Деревья](#деревья)
  - [Уровень, высота и баланс деревьев](#уровень-высота-и-баланс-деревьев)
- [23.02.27 - лекция](#230227---лекция)
  - [Деревья выборов](#деревья-выборов)
  - [Префиксные коды и деревья Хаффмана](#префиксные-коды-и-деревья-хаффмана)
  - [Остовные деревья](#остовные-деревья)
  - [Breadth-first search](#breadth-first-search)
  - [Кратчайшее расстояние между вершинами](#кратчайшее-расстояние-между-вершинами)
  - [Depth-first search](#depth-first-search)


# Лекторы
Апанович Зинаида Владимировна

Семинарист - Морозов Дмитрий

# 23.02.13 - лекция
## Способы представления графов
- Перечисление
- Список смежности (для ориентированного графа мы указываем, в какие вершины ведут рёбра из данной)
- Матрица смежности (adjacency matrix) - таблица `n*n`, где (`n` - кол-во вершин в графе). `matrix[i][j] = 1 <=> (i, j) in edges`. Для мультиграфов вместо единички записывается количество рёбер.

Если `|E| >= 0.5|V|` => оптимальнее использовать матрицу смежности. При этом в матрице мы узнаём наличие ребра за `O(1)`, Тогда как в списке за `O(n)` (но ведь можно таблицу представить как массив, тогда тоже будет... *Не, это получается уже почти матрица*)

Матрица инцидентности:
- Вершины - строки
- Рёбра - столбцы
- `matrix[i][j] = 1 <=> v_i in e_j` (для нециклических рёбер в столбце всегда будет 2 единицы)
- *IMO - куда менее удобная форма*
- Для направленного графа точку начала обозначают как `-1`, а конца - `1`

## Изоморфизм
2 простых графа `G1` и `G2` - изоморфны, если существует биекция `f`, сохраняющая отношение смежности для вершин и рёбер графов `G1' = f(G1)` и `G2' = f(G2)`

=> Следующие обязательные условия для изоморфизма:
1. Одинаковое кол-во вершин
2. Одинаковое кол-во рёбер
3. Количество вершин с определёнными степенями одинаково

Выше приведены необходимые, но недостаточные условия изоморфизма.

Если для двух графов можно построить идентичные матрицы смежности, значит между ними существует изоморфизм.

## Связные графы
**О.** Путь - последовательность рёбер, первое из которых содержит начальную точку (для ориентированного графа - на первом месте), а последнее - конечную точку (для ориентированного графа - на втором месте).

Также можно расширить путь до маршрута - перед и после ребра указывать в последовательности вершины.

Можно указывать путь через вершины, если нет кратных рёбер/

**О.** Граф называется связным (connected), если существует путь между двумя любыми его вершинами.

**Т.** Для связного графа между двумя любыми вершинами существует простой путь (*Если в пути есть повторяющиеся подпоследовательности, избавляемся от копий и тогда как раз получаем простой путь*)

Максимальный связный подграф - *пояснения излишни*, Связные подграфы называются компонентами связности.

Если в одном графе есть путь длины `n`, а в другом точно нет пути такой же длины => графы точно не изоморфны.

Если же мы возьмём в двух графах пути, включающие все вершины. При этом в обоих путях степени у смежных вершин одинаковы, мы имеем уже куда более крепкие основания говорить об изоморфизме, который можно подтвердить, построив графы

## Двудольные графы
Если в графе есть треугольные подграфы => исходный граф не двудольный.

**Т.** Граф является двудольным, если его можно окрасить в 2 цвета таким образом, что любые смежные вершины имеют разный цвет

**Т.** Граф двудольный тогда и только тогда, когда в нём не существует замкнутого пути нечётной длины (за длину мы считаем кол-во рёбер). Обратное утверждение: если все циклические пути имеют чётную длину, значит граф двудольный

# 23.02.13 - семинар
## Специальные графы
- Циклический - из любой точки есть непересекающийся путь в неё же (листьев быть не должно)
- Колесо - циклический граф с центральной вершиной
- Полный граф - все вершины связаны со всеми
- Гиперкубы

**Л.** "О рукопожатиях". Сумма всех степеней вершин в ненаправленном графе равна `2*|E|`

Для полного графа `|E| = n*(n-1)/2`

Максимальное количество рёбер в двудольном графе ` = (n-1)(n+1)/4`

Либо граф, либо его дополнение обязательно будут связными.

Самодополнительные графы - графы, которые изоморфны своему дополнению.

Любой гиперкуб можно представить как двудольный граф

# 23.02.20 - лекция
## Использование матриц смежности для анализа графов
Матрицы смежности могут использовать для подсчёта количества путей в графе.

Для любого графа G матрица ячейка `(i, j)` матрицы смежности в степени `k` - кол-во путей из `v_i` в `v_j` длины `k`

След матрицы (`trace`) - сумма главной диагонали матрицы смежности в степени `k`. С помощью следа можно вычислять некоторые характеристики графов:
- `t(A^2) = 2|E|` (Для неориентированного графа)
- Кол-во треугольников в графе `trianglesCnt = t(A^3)/6`
- $t(a^4) = 8q - 2E + 2 \sum_{i=1}^{|V|} \deg^2(v_i)$

Графы с `|V| >= 2` связные `<=>` 

Матрица смежности дополнения графа - матрица, где все ячейки изначально равные нулям (не считая диагональных), равны единицам - и наоборот.

`A + A' + I = J`

Если матрица симметрична, то все с.з. будет вещественными, а с.в. будут взаимноортоганальны.

**О.** Характеристический полином матрицы смежности - `det(tI - A)`

**О.** Спектр графа - набор скаляров собственных значений графа.

Любое собственное значение графа не превосходит его максимальную степень.

Регулярный граф - граф, в котором все степени вершин одинаковы. Если будем считать, что степень вершин равна `k`, то это и будет собственное значение.

Спектры изоморфных графов идентичны.

## Деревья
**О.** Деревья - это связные ненаправленные ациклические графы

**О.** Лес - несколько несвязных деревьев

Любая из вершин дерева может быть выбрана как корень, относительно которого мы сориентируем всё дерево.

**О.** Корневое дерево называется `m`-арным дерево, если каждый из его внутренних элементов имеет `<= m` потомков

**О.** Если у каждой внутренней вершины ровно `m` потомков, то это дерево называется полным (`full`) `m`-арным деревом

**О.** Заполненное (`complete`) `m`-арное дерево - подмножество полных деревьев, где до максимальной глубины существуют все вершины.

**Т.** В каждом дереве с `n` вершинами ровно `n-1` рёбер. *Доказывается индукцией с обходом в глубину до листа и его откидыванием (фактически, это будет индукция не по сложению, а по вычитанию)*

Таким образом, мы получаем 3 утверждения

**Т.** `Full` `m`-арное дерево с `i` количеством внутренних вершин. Для него можно вычислить кол-во вершин как `n = mi + 1`

**Т.** Если нам известен один из параметров `full` `m`-арного дерева, мы можем вычслить остальные:
1. Известно количество вершин `n`:
   1. Внутренние вершины `i = (n - 1)/m`
   2. Листья $l = \frac{(m - 1)n + 1}{m}$
2. Известны внутренние вершины `i`:
   1. `n = mi + 1`
   2. `l = (m - 1)i + 1`
3. Листья `l`:
   1. `n = (ml - 1)/(m - 1)`
   2. `i = (l - 1)/(m - 1)`

## Уровень, высота и баланс деревьев
**О.** Уровень вершины в дереве - это длина пути от вершины до корня. (*Соответственно, уровень корня ` = 0`*)

**О.** Высота дерева - максимальный уровень вершин в дереве

**О.** `m`-арное корневое дерево будет **сбалансированным**, если всего его листья находятся на высоте `h` или `h - 1`

**Т.** В `m`-арное дереве высоты `h` количество листьев `l <= m^h`

**С.** Для `m`-арного дерева с количеством листьев `l`: $h \ge ceil(\log_m l)$. Для полного сбалансированного дерева: $h = ceil(\log_m l)$

# 23.02.27 - лекция
## Деревья выборов
**О.** Деревья выборов - деревья, в которых каждая вершина репрезентует выбор одного из вариантов, а листья в поддереве под ней ему соответствуют.

**О.** Пусть от корня до листа в дереве выборов называется **возможным решением**

Дерево выборов можно использовать для поиска наиболее оптимальных вариантов поиска одного отличающегося объекта из множества или для оценки сложности алгоритмов сортировок.

## Префиксные коды и деревья Хаффмана
*Дописать*

## Остовные деревья
**О.** Остовное дерево - граф, содержащий все вершины исходного графа и являющийся при этом деревом. **Остовное дерево может быть только у связного графа.** Остовных деревьев у заданного графа может быть много.

**Т.** Простой граф будет связным тогда и только тогда, когда у него есть остовное дерево.

Построить остовное дерево можно удалением рёбер из циклов, но это будет неэффективный алгоритм.

Эффективным алгоритами будут **breadth-first search (поиск в ширину)** и **depth-first search (поиск в глубину)**

## Breadth-first search
Поиск в ширину заключается в том, что мы выбираем вершину входа (будущий корень остовного дерева), затем подсоединяем к ней все доступные вершины и маркируем их. Далее идём в каждую из вершин и подсоединяем её детей, если они ещё не были промаркированы. Повторяем алгоритм, пока не обойдём все вершины.

**Расширенная версия алгоритма:** добавляем всем вершинам такие параметры, как цвет, расстояние до корня и адрес родителя. Изначально все элементы окрашены в белый, не имеют родителя и расстояние до корня равно бесконечности. Также используем очередь по принципу `FIFO`
- Окрашиваем корневую вершину в серый и присваиваем ей дистанцию `0`. Предка нет.
- Добавляем корень в очередь
- `while queue.notEmpty`:
  - Берём из очереди вершину
  - Обходим все доступные из данной вершины
  - Если вершина белая, помечаем её серым, сохраняя родителем текущую вершину и расстояние до него ` + 1`
  - Добавляем окрашенные серым вершины в очередь
  - Когда с текущей вершиной мы полностью закончили, окрашиваем её в чёрный и берём новую вершину из очереди

Скорость алгоритма - `O(V + E)`

## Кратчайшее расстояние между вершинами
**О.** Кратчайшая длина пути из $s$ в $v$ обозначается как $\delta(s, v)$

**Л.** Если в графе существует путь `(u,v)`, то $\delta(s,v) \le \delta(s,u) + 1$ (*Если `u` достижима из `s`, то мы либо дойдём из `s` до `v` через `u`, либо дойдём до `v` раньше, чем до `u`*)

**Л.** [BFS](#breadth-first-search) позволяет найти все кратчайшие расстояния (**для графов без веса рёбер**) (*доказывается индукцией благодаря очереди типа `FIFO` в алгоритме и прошлой лемме*)

**Т.** Для заданного графа `BFS2` от данной вершины обойдёт все доступные вершины и при том вычислит для них кратчайшее расстояние (*Странная теорема, потому что одно её положение следует из определения алгоритма, а второе - из леммы выше*)

`BFS2` даёт нам **breadth-first tree**

## Depth-first search