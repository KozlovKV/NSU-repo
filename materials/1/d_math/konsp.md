- [Лекторы](#лекторы)
- [23.02.13 - лекция](#230213---лекция)
  - [Способы представления графов](#способы-представления-графов)
  - [Изоморфизм](#изоморфизм)
  - [Связные графы](#связные-графы)
  - [Двудольные графы](#двудольные-графы)
- [23.02.13 - семинар](#230213---семинар)
  - [Специальные графы](#специальные-графы)
- [23.02.20 - лекция](#230220---лекция)
  - [Использование матриц смежности для анализа графов](#использование-матриц-смежности-для-анализа-графов)
  - [Деревья](#деревья)
  - [Уровень, высота и баланс деревьев](#уровень-высота-и-баланс-деревьев)
- [23.02.27 - лекция](#230227---лекция)
  - [Деревья выборов](#деревья-выборов)
  - [Префиксные коды и деревья Хаффмана](#префиксные-коды-и-деревья-хаффмана)
  - [Остовные деревья](#остовные-деревья)
  - [Breadth-first search](#breadth-first-search)
  - [Кратчайшее расстояние между вершинами](#кратчайшее-расстояние-между-вершинами)
  - [Алгоритм Прима](#алгоритм-прима)
  - [Алгоритм Краскала](#алгоритм-краскала)
- [23-03-06 - лекция](#23-03-06---лекция)
  - [Depth-first search](#depth-first-search)
- [23.03.13 - лекция](#230313---лекция)
  - [Количество остовных деревьев](#количество-остовных-деревьев)
    - [Алгоритм "влоб"](#алгоритм-влоб)
    - [Теорема для полного графа](#теорема-для-полного-графа)
    - [Метод Лапласиана](#метод-лапласиана)
  - [Связность](#связность)


# Лекторы
Апанович Зинаида Владимировна

Семинарист - Морозов Дмитрий

# 23.02.13 - лекция
## Способы представления графов
- Перечисление
- Список смежности (для ориентированного графа мы указываем, в какие вершины ведут рёбра из данной)
- Матрица смежности (adjacency matrix) - таблица `n*n`, где (`n` - кол-во вершин в графе). `matrix[i][j] = 1 <=> (i, j) in edges`. Для мультиграфов вместо единички записывается количество рёбер.

Если `|E| >= 0.5|V|` => оптимальнее использовать матрицу смежности. При этом в матрице мы узнаём наличие ребра за `O(1)`, Тогда как в списке за `O(n)` (но ведь можно таблицу представить как массив, тогда тоже будет... *Не, это получается уже почти матрица*)

Матрица инцидентности:
- Вершины - строки
- Рёбра - столбцы
- `matrix[i][j] = 1 <=> v_i in e_j` (для нециклических рёбер в столбце всегда будет 2 единицы)
- *IMO - куда менее удобная форма*
- Для направленного графа точку начала обозначают как `-1`, а конца - `1`

## Изоморфизм
2 простых графа `G1` и `G2` - изоморфны, если существует биекция `f`, сохраняющая отношение смежности для вершин и рёбер графов `G1' = f(G1)` и `G2' = f(G2)`

=> Следующие обязательные условия для изоморфизма:
1. Одинаковое кол-во вершин
2. Одинаковое кол-во рёбер
3. Количество вершин с определёнными степенями одинаково

Выше приведены необходимые, но недостаточные условия изоморфизма.

Если для двух графов можно построить идентичные матрицы смежности, значит между ними существует изоморфизм.

## Связные графы
**О.** Путь - последовательность рёбер, первое из которых содержит начальную точку (для ориентированного графа - на первом месте), а последнее - конечную точку (для ориентированного графа - на втором месте).

Также можно расширить путь до маршрута - перед и после ребра указывать в последовательности вершины.

Можно указывать путь через вершины, если нет кратных рёбер/

**О.** Граф называется связным (connected), если существует путь между двумя любыми его вершинами.

**Т.** Для связного графа между двумя любыми вершинами существует простой путь (*Если в пути есть повторяющиеся подпоследовательности, избавляемся от копий и тогда как раз получаем простой путь*)

Максимальный связный подграф - *пояснения излишни*, Связные подграфы называются компонентами связности.

Если в одном графе есть путь длины `n`, а в другом точно нет пути такой же длины => графы точно не изоморфны.

Если же мы возьмём в двух графах пути, включающие все вершины. При этом в обоих путях степени у смежных вершин одинаковы, мы имеем уже куда более крепкие основания говорить об изоморфизме, который можно подтвердить, построив графы

## Двудольные графы
Если в графе есть треугольные подграфы => исходный граф не двудольный.

**Т.** Граф является двудольным, если его можно окрасить в 2 цвета таким образом, что любые смежные вершины имеют разный цвет

**Т.** Граф двудольный тогда и только тогда, когда в нём не существует замкнутого пути нечётной длины (за длину мы считаем кол-во рёбер). Обратное утверждение: если все циклические пути имеют чётную длину, значит граф двудольный

# 23.02.13 - семинар
## Специальные графы
- Циклический - из любой точки есть непересекающийся путь в неё же (листьев быть не должно)
- Колесо - циклический граф с центральной вершиной
- Полный граф - все вершины связаны со всеми
- Гиперкубы

**Л.** "О рукопожатиях". Сумма всех степеней вершин в ненаправленном графе равна `2*|E|`

Для полного графа `|E| = n*(n-1)/2`

Максимальное количество рёбер в двудольном графе ` = (n-1)(n+1)/4`

Либо граф, либо его дополнение обязательно будут связными.

Самодополнительные графы - графы, которые изоморфны своему дополнению.

Любой гиперкуб можно представить как двудольный граф

# 23.02.20 - лекция
## Использование матриц смежности для анализа графов
Матрицы смежности могут использовать для подсчёта количества путей в графе.

Для любого графа G матрица ячейка `(i, j)` матрицы смежности в степени `k` - кол-во путей из `v_i` в `v_j` длины `k`

След матрицы (`trace`) - сумма главной диагонали матрицы смежности в степени `k`. С помощью следа можно вычислять некоторые характеристики графов:
- `t(A^2) = 2|E|` (Для неориентированного графа)
- Кол-во треугольников в графе `trianglesCnt = t(A^3)/6`
- $t(a^4) = 8q - 2E + 2 \sum_{i=1}^{|V|} \deg^2(v_i)$

Графы с `|V| >= 2` связные `<=>` 

Матрица смежности дополнения графа - матрица, где все ячейки изначально равные нулям (не считая диагональных), равны единицам - и наоборот.

`A + A' + I = J`

Если матрица симметрична, то все с.з. будет вещественными, а с.в. будут взаимноортоганальны.

**О.** Характеристический полином матрицы смежности - `det(tI - A)`

**О.** Спектр графа - набор скаляров собственных значений графа.

Любое собственное значение графа не превосходит его максимальную степень.

Регулярный граф - граф, в котором все степени вершин одинаковы. Если будем считать, что степень вершин равна `k`, то это и будет собственное значение.

Спектры изоморфных графов идентичны.

## Деревья
**О.** Деревья - это связные ненаправленные ациклические графы

**О.** Лес - несколько несвязных деревьев

Любая из вершин дерева может быть выбрана как корень, относительно которого мы сориентируем всё дерево.

**О.** Корневое дерево называется `m`-арным дерево, если каждый из его внутренних элементов имеет `<= m` потомков

**О.** Если у каждой внутренней вершины ровно `m` потомков, то это дерево называется полным (`full`) `m`-арным деревом

**О.** Заполненное (`complete`) `m`-арное дерево - подмножество полных деревьев, где до максимальной глубины существуют все вершины.

**Т.** В каждом дереве с `n` вершинами ровно `n-1` рёбер. *Доказывается индукцией с обходом в глубину до листа и его откидыванием (фактически, это будет индукция не по сложению, а по вычитанию)*

Таким образом, мы получаем 3 утверждения

**Т.** `Full` `m`-арное дерево с `i` количеством внутренних вершин. Для него можно вычислить кол-во вершин как `n = mi + 1`

**Т.** Если нам известен один из параметров `full` `m`-арного дерева, мы можем вычслить остальные:
1. Известно количество вершин `n`:
   1. Внутренние вершины `i = (n - 1)/m`
   2. Листья $l = \frac{(m - 1)n + 1}{m}$
2. Известны внутренние вершины `i`:
   1. `n = mi + 1`
   2. `l = (m - 1)i + 1`
3. Листья `l`:
   1. `n = (ml - 1)/(m - 1)`
   2. `i = (l - 1)/(m - 1)`

## Уровень, высота и баланс деревьев
**О.** Уровень вершины в дереве - это длина пути от вершины до корня. (*Соответственно, уровень корня ` = 0`*)

**О.** Высота дерева - максимальный уровень вершин в дереве

**О.** `m`-арное корневое дерево будет **сбалансированным**, если всего его листья находятся на высоте `h` или `h - 1`

**Т.** В `m`-арное дереве высоты `h` количество листьев `l <= m^h`

**С.** Для `m`-арного дерева с количеством листьев `l`: $h \ge ceil(\log_m l)$. Для полного сбалансированного дерева: $h = ceil(\log_m l)$

# 23.02.27 - лекция
## Деревья выборов
**О.** Деревья выборов - деревья, в которых каждая вершина репрезентует выбор одного из вариантов, а листья в поддереве под ней ему соответствуют.

**О.** Пусть от корня до листа в дереве выборов называется **возможным решением**

Дерево выборов можно использовать для поиска наиболее оптимальных вариантов поиска одного отличающегося объекта из множества или для оценки сложности алгоритмов сортировок.

## Префиксные коды и деревья Хаффмана
**О.** Префиксными кодами называются такие коды, каждый из которых не содержит в начале себя другой код, что позволяет нам однозначно понимать, где кончается один код и начинается другой.

Префиксные коды можно изобразить в виде бинарного дерева. Символы будут обозначены названиями листьев, а их коды - пути к ним. Левое ребро обозначается нулём, а правое - единицей.

Для построения максимально экономного дерева (символы, чаще встречающиеся в тексте, будут иметь более короткий код) используется алгоритм Хаффмана:
- Представляем каждый символ как дерево из одной вершины и обозначаем его вес, то есть частоту повторения в тексте
- Берём 2 дерева с наименьшим весом и собираем их в одно. Левым поддеревом становится то, у которого вес больше, а правым - меньше. Весом нового дерева будет считать сумму весов его поддеревьев
- Повторяем прошлый пункт до тех пор, пока все деревья не сольются в одно

**Если мы использует для кодирования не только `0, 1`, то для расчёта количества листьев у самого первого дерева нужно использовать формулу `((N-1) % (m-1)) + 1`, где `N` - количество разных символов для кодирования, а `m` - основание системы счисления**

## Остовные деревья
**О.** Остовное дерево - граф, содержащий все вершины исходного графа и являющийся при этом деревом. **Остовное дерево может быть только у связного графа.** Остовных деревьев у заданного графа может быть много.

**Т.** Простой граф будет связным тогда и только тогда, когда у него есть остовное дерево.

Построить остовное дерево можно удалением рёбер из циклов, но это будет неэффективный алгоритм.

Эффективным алгоритмами будут [**breadth-first search (поиск в ширину)**](#breadth-first-search) и [**depth-first search (поиск в глубину)**](#depth-first-search), а также [алгоритм Прима](#алгоритм-прима) и алгоритм Краскала для взвешенных неориентированных графов

## Breadth-first search
Поиск в ширину заключается в том, что мы выбираем вершину входа (будущий корень остовного дерева), затем подсоединяем к ней все доступные вершины и маркируем их. Далее идём в каждую из вершин и подсоединяем её детей, если они ещё не были промаркированы. Повторяем алгоритм, пока не обойдём все вершины.

**Расширенная версия алгоритма:** добавляем всем вершинам такие параметры, как цвет, расстояние до корня и адрес родителя. Изначально все элементы окрашены в белый, не имеют родителя и расстояние до корня равно бесконечности. Также используем очередь по принципу `FIFO`
- Окрашиваем корневую вершину в серый и присваиваем ей дистанцию `0`. Предка нет.
- Добавляем корень в очередь
- `while queue.notEmpty`:
  - Берём из очереди вершину
  - Обходим все доступные из данной вершины
  - Если вершина белая, помечаем её серым, сохраняя родителем текущую вершину и расстояние до него ` + 1`
  - Добавляем окрашенные серым вершины в очередь
  - Когда с текущей вершиной мы полностью закончили, окрашиваем её в чёрный и берём новую вершину из очереди

Скорость алгоритма - `O(V + E)`

## Кратчайшее расстояние между вершинами
**О.** Кратчайшая длина пути из $s$ в $v$ обозначается как $\delta(s, v)$

**Л.** Если в графе существует путь `(u,v)`, то $\delta(s,v) \le \delta(s,u) + 1$ (*Если `u` достижима из `s`, то мы либо дойдём из `s` до `v` через `u`, либо дойдём до `v` раньше, чем до `u`*)

**Л.** [BFS](#breadth-first-search) позволяет найти все кратчайшие расстояния (**для графов без веса рёбер**) (*доказывается индукцией благодаря очереди типа `FIFO` в алгоритме и прошлой лемме*)

**Т.** Для заданного графа `BFS2` от данной вершины обойдёт все доступные вершины и при том вычислит для них кратчайшее расстояние (*Странная теорема, потому что одно её положение следует из определения алгоритма, а второе - из леммы выше*)

`BFS2` даёт нам **breadth-first tree**

## Алгоритм Прима
Позволяет построить минимально весящее остовное дерево. Из исходного графа берём произвольную вершину, затем смотрим её рёбра и добавляем ребро с наименьшим весом (*и вершину на его конце - ваш кэп*), затем в полученном дереве также проверяем все рёбра, соединяющие вершины дерева с вершинами вне дерева и выбираем минимальное из этих рёбер. Повторяем, пока все вершины не попадут в дерево.

[Демонстрация](https://ru.wikipedia.org/wiki/Алгоритм_Прима#Пример)

*Доказательство минимальности веса остовного графа, полученного алгоритмом Прима: (* Дописать, если не забью *)*

## Алгоритм Краскала
Позволяет построить минимально весящее остовное дерево. Получаем список всех рёбер, затем добавляем минимальное по весу ребро, если оно не вызывает появление цикла. Повторяем до тех пор, пока в списке не останутся лишь рёбра, добавление которых приведёт к возникновению цикла. **PROFIT**

[Демонстрация](https://ru.wikipedia.org/wiki/Алгоритм_Краскала#Пример)

# 23-03-06 - лекция
## Depth-first search
Добавляем корень дерева (*точку входа*) и далее запускаем рекурсивный алгоритм:
1. `while <можем от последней добавленной вершине перейти к ещё не добавленной>`
  1. Добавляем инцидентное последней добавленной вершине ребро с другой вершиной, ещё не добавленной в дерево (*если таковых несколько, берём первую по порядку в нашем представлении графа*)
2. `while <нельзя добавить новых вершин>`
   1. Движемся по добавленным вершинам от конца к началу
3. `if <не дошли до корня>`
   1. Повторяем с пункта `1`
4. `else` - **PROFIT**

Версия на псевдокоде:
```
G - connected graph with vertices v1, ..., vn
T - result tree

visit(v):
  for w that {w adjacent v and w not_in T}:
    add w and edge (v, w) to T
    visit(w)

visit(v1)
```

**Расширенная версия**: предки сохраняются у вершин также, как в BFS2, а окрашивание идёт по следующему принципу: изначально вершины белые, когда мы спускаемся по ним вниз, окрашиваем в серый, когда выходим обратно и покидаем (то есть мы не можем из этой вершины больше перейти ни в какую) - в чёрный. Кроме того, мы храним не только глубину `d`, но и момент обратного выхода `f`, причём хранят они не глубину как таковую, а что-то вроде таймстэмпа. `v.d < v.f`

Псевдокод:
```
for v in G.V:
  v.color = WHITE
  v.pi = NIL

time = 0

for v in G.V:
  if v.color == WHITE:
    visit(G, v)

visit(G, v):
  time++
  v.d = time
  v.color = GRAY
  for u in G.adj[v]:
    if u.color == WHITE
      u.pi = v
      visit(G, u)
  v.color = BLACK
  time++
  v.f = time
```

# 23.03.13 - лекция
## Количество остовных деревьев
### Алгоритм "влоб"
Алгоритм для поиска кол-ва остовных деревьев:
- Стягиваем связанные между собой вершины в одну вершину. 
- Количество остовных деревьев исходного графа - сумма кол-ва остовных деревьев со стянутыми вершинами и деревьев, где стянутого ребра нет.
- Пока каждый граф в суммме не будет деревом, продолжаем удаление и стягивание

### Теорема для полного графа
Кол-во остовных деревьев для `n`-дерева = `n^(n-2)`

**Использование на практике:** Выбираем лист с наименьшим номером. Записываем в код Прюфера вершину, смежную с данной, затем удаляем ребро между этими вершинами. Повторяем до тех пор, пока дерево не будет состоять из двух листьев.

Обладая кодом Прюфера, можно восстановить остовное дерево: в код Прюфера не входят листья, при этом выбирали мы листья с наименьшим номером, поэтому идёт прямо по коду, добавляя к вершинам из кода листья с соответствующими номерами (*номера возрастают с пропуском входящих в код вершин*)

### Метод Лапласиана
*Через матрицы Лапласа (спросить потом у Морозова)*

Матрица Лапласа:
- `i == j => a_ij = deg v_i`
- `(i, j) in V => a_ij = -1`
- `otherwise => a_ij = 0`

**Т. Киргоффа о связи матриц и деревьев:** кол-во остовных деревьев в графе можно посчитать как определитель матрицы Лапласа, из которой мы удалили любую строку и столбец.

## Связность
*Повторим:* граф называется связным `<=>` из любой его вершины можно попасть в любую. Имеет одну компоненту связности.

**Cut-vertices (разделяющие вершины)** - вершины, при удалении которых (по одиночке) граф перестаёт быть связным. Существуют также **cut-edge (мосты)**.

Не у всех графов есть cut-vertices и cut-edge. Графы без нех называются **nonseparable (ЕДИНЫМИ И НЕДЕЛИМЫМИ!)**.

Число вершинной связности ($\kappa(G)$) - минимальное число вершин, которое нужно удалить для дробления графа на отдельные компоненты связности. Граф называется `k`-вершинно связным, если `k` - число вершинной связности.

Аналогичным образом вводится понятие рёберной связности ($\lambda(G)$). Зачастую рёберная связность больше вершинной.

Для любого графа рёберная связность `= min deg v`