- [Лекторы](#лекторы)
- [23.02.13 - лекция](#230213---лекция)
  - [Способы представления графов](#способы-представления-графов)
  - [Изоморфизм](#изоморфизм)
  - [Связные графы](#связные-графы)
  - [Двудольные графы](#двудольные-графы)
- [23.02.13 - семинар](#230213---семинар)
  - [Специальные графы](#специальные-графы)
- [23.02.20 - лекция](#230220---лекция)
  - [Использование матриц смежности для анализа графов](#использование-матриц-смежности-для-анализа-графов)
  - [Деревья](#деревья)
  - [Уровень, высота и баланс деревьев](#уровень-высота-и-баланс-деревьев)
- [23.02.27 - лекция](#230227---лекция)
  - [Деревья выборов](#деревья-выборов)
  - [Префиксные коды и деревья Хаффмана](#префиксные-коды-и-деревья-хаффмана)
  - [Остовные деревья](#остовные-деревья)
  - [Breadth-first search](#breadth-first-search)
  - [Кратчайшее расстояние между вершинами](#кратчайшее-расстояние-между-вершинами)
  - [Алгоритм Прима](#алгоритм-прима)
  - [Алгоритм Краскала](#алгоритм-краскала)
- [23-03-06 - лекция](#23-03-06---лекция)
  - [Depth-first search](#depth-first-search)
- [23.03.13 - лекция](#230313---лекция)
  - [Количество остовных деревьев](#количество-остовных-деревьев)
    - [Алгоритм стягивания ребра](#алгоритм-стягивания-ребра)
    - [Теорема для полного графа](#теорема-для-полного-графа)
    - [Метод Лапласиана](#метод-лапласиана)
  - [Связность](#связность)
- [23.03.13 - семинар](#230313---семинар)
  - [Типы рёбер при DFS](#типы-рёбер-при-dfs)
  - [Ещё раз о счёте остовных деревьев](#ещё-раз-о-счёте-остовных-деревьев)
    - [Ещё немного про стягивание ребра](#ещё-немного-про-стягивание-ребра)
- [23.03.20 - лекция](#230320---лекция)
  - [Продолжаем про связность](#продолжаем-про-связность)
  - [Двусвязность](#двусвязность)
    - [Универсальный (почти) код на Си для поиска cut-vertices](#универсальный-почти-код-на-си-для-поиска-cut-vertices)
  - [ST-нумерация](#st-нумерация)
- [23.03.27 - лекция](#230327---лекция)
  - [ST-ориентация](#st-ориентация)
    - [Алгоритм Тарьяна](#алгоритм-тарьяна)
  - [Кратчайшие пути](#кратчайшие-пути)
  - [Алгоритм Беллмана-Форда](#алгоритм-беллмана-форда)
- [23.04.03 - лекция](#230403---лекция)
  - [Алгоритм Дейкстры](#алгоритм-дейкстры)
  - [Поиск кратчайшего пути между всеми парами вершин](#поиск-кратчайшего-пути-между-всеми-парами-вершин)
    - [Кратчайшие пути через матричное умножение](#кратчайшие-пути-через-матричное-умножение)
- [23.04.10 - лекция](#230410---лекция)
  - [Флойд-Уоршелл (*снова*)](#флойд-уоршелл-снова)
  - [Флойд-Уоршалл с восстановлением путей на Си](#флойд-уоршалл-с-восстановлением-путей-на-си)
  - [Алгоритм Джонсона](#алгоритм-джонсона)
- [23.04.17 - лекция](#230417---лекция)
  - [Обходы Эйлера](#обходы-эйлера)
    - [Эйлеров цикл](#эйлеров-цикл)
    - [Эйлеров путь](#эйлеров-путь)
    - [Зачем оно надо?](#зачем-оно-надо)
  - [Обходы Гамильтона](#обходы-гамильтона)
    - [Условия циклов](#условия-циклов)
    - [Приложение Гамильтоновых обходов](#приложение-гамильтоновых-обходов)
- [23.04.24 - лекция](#230424---лекция)
  - [Потоки](#потоки)
  - [Вычисление максимального значения потока (Алгоритм Форда-Фолкерсона)](#вычисление-максимального-значения-потока-алгоритм-форда-фолкерсона)
  - [ГЛАВНАЯ, МАТЬ ЕГО, ТЕОРЕМА](#главная-мать-его-теорема)
  - [Выбор оптимальных путей в алгоритме Форда-Фолкерсона](#выбор-оптимальных-путей-в-алгоритме-форда-фолкерсона)
- [23.05.15 - лекция](#230515---лекция)
  - [Паросочетание (matchings)](#паросочетание-matchings)
  - [Покрытие](#покрытие)
- [23.05.15 - семинар](#230515---семинар)


# Лекторы
Апанович Зинаида Владимировна

Семинарист - Морозов Дмитрий

# 23.02.13 - лекция
## Способы представления графов
- Перечисление
- Список смежности (для ориентированного графа мы указываем, в какие вершины ведут рёбра из данной)
- Матрица смежности (adjacency matrix) - таблица `n*n`, где (`n` - кол-во вершин в графе). `matrix[i][j] = 1 <=> (i, j) in edges`. Для мультиграфов вместо единички записывается количество рёбер.

Если `|E| >= 0.5|V|` => оптимальнее использовать матрицу смежности. При этом в матрице мы узнаём наличие ребра за `O(1)`, Тогда как в списке за `O(n)` (но ведь можно таблицу представить как массив, тогда тоже будет... *Не, это получается уже почти матрица*)

Матрица инцидентности:
- Вершины - строки
- Рёбра - столбцы
- `matrix[i][j] = 1 <=> v_i in e_j` (для нециклических рёбер в столбце всегда будет 2 единицы)
- *IMO - куда менее удобная форма*
- Для направленного графа точку начала обозначают как `-1`, а конца - `1`

## Изоморфизм
2 простых графа `G1` и `G2` - изоморфны, если существует биекция `f`, сохраняющая отношение смежности для вершин и рёбер графов `G1' = f(G1)` и `G2' = f(G2)`

=> Следующие обязательные условия для изоморфизма:
1. Одинаковое кол-во вершин
2. Одинаковое кол-во рёбер
3. Количество вершин с определёнными степенями одинаково

Выше приведены необходимые, но недостаточные условия изоморфизма.

Если для двух графов можно построить идентичные матрицы смежности, значит между ними существует изоморфизм.

## Связные графы
**О.** Путь - последовательность рёбер, первое из которых содержит начальную точку (для ориентированного графа - на первом месте), а последнее - конечную точку (для ориентированного графа - на втором месте).

Также можно расширить путь до маршрута - перед и после ребра указывать в последовательности вершины.

Можно указывать путь через вершины, если нет кратных рёбер

**О.** Граф называется связным (connected), если существует путь между двумя любыми его вершинами.

**Т.** Для связного графа между двумя любыми вершинами существует простой путь (*Если в пути есть повторяющиеся подпоследовательности, избавляемся от копий и тогда как раз получаем простой путь*)

Максимальный связный подграф - *пояснения излишни*, Связные подграфы называются компонентами связности.

Если в одном графе есть путь длины `n`, а в другом точно нет пути такой же длины => графы точно не изоморфны.

Если же мы возьмём в двух графах пути, включающие все вершины. При этом в обоих путях степени у смежных вершин одинаковы, мы имеем уже куда более крепкие основания говорить об изоморфизме, который можно подтвердить, построив графы

## Двудольные графы
Если в графе есть треугольные подграфы => исходный граф не двудольный.

**Т.** Граф является двудольным, если его можно окрасить в 2 цвета таким образом, что любые смежные вершины имеют разный цвет

**Т.** Граф двудольный тогда и только тогда, когда в нём не существует замкнутого пути нечётной длины (за длину мы считаем кол-во рёбер). Обратное утверждение: если все циклические пути имеют чётную длину, значит граф двудольный

# 23.02.13 - семинар
## Специальные графы
- Циклический - из любой точки есть непересекающийся путь в неё же (листьев быть не должно)
- Колесо - циклический граф с центральной вершиной
- Полный граф - все вершины связаны со всеми
- Гиперкубы

**Л.** "О рукопожатиях". Сумма всех степеней вершин в ненаправленном графе равна `2*|E|`

Для полного графа `|E| = n*(n-1)/2`

Максимальное количество рёбер в двудольном графе ` = (n-1)(n+1)/4`

Либо граф, либо его дополнение обязательно будут связными.

Самодополнительные графы - графы, которые изоморфны своему дополнению.

Любой гиперкуб можно представить как двудольный граф

# 23.02.20 - лекция
## Использование матриц смежности для анализа графов
Матрицы смежности могут использовать для подсчёта количества путей в графе.

Для любого графа G матрица ячейка `(i, j)` матрицы смежности в степени `k` - кол-во путей из `v_i` в `v_j` длины `k`

След матрицы (`trace`) - сумма главной диагонали матрицы смежности в степени `k`. С помощью следа можно вычислять некоторые характеристики графов:
- `t(A^2) = 2|E|` (Для неориентированного графа)
- Кол-во треугольников в графе `trianglesCnt = t(A^3)/6`
- $t(a^4) = 8q - 2E + 2 \sum_{i=1}^{|V|} \deg^2(v_i)$

Графы с `|V| >= 2` связные `<=>` 

Матрица смежности дополнения графа - матрица, где все ячейки изначально равные нулям (не считая диагональных), равны единицам - и наоборот.

`A + A' + I = J`

Если матрица симметрична, то все с.з. будет вещественными, а с.в. будут взаимноортоганальны.

**О.** Характеристический полином матрицы смежности - `det(tI - A)`

**О.** Спектр графа - набор скаляров собственных значений графа.

Любое собственное значение графа не превосходит его максимальную степень.

Регулярный граф - граф, в котором все степени вершин одинаковы. Если будем считать, что степень вершин равна `k`, то это и будет собственное значение.

Спектры изоморфных графов идентичны.

## Деревья
**О.** Деревья - это связные ненаправленные ациклические графы

**О.** Лес - несколько несвязных деревьев

Любая из вершин дерева может быть выбрана как корень, относительно которого мы сориентируем всё дерево.

**О.** Корневое дерево называется `m`-арным дерево, если каждый из его внутренних элементов имеет `<= m` потомков

**О.** Если у каждой внутренней вершины ровно `m` потомков, то это дерево называется полным (`full`) `m`-арным деревом

**О.** Заполненное (`complete`) `m`-арное дерево - подмножество полных деревьев, где до максимальной глубины существуют все вершины.

**Т.** В каждом дереве с `n` вершинами ровно `n-1` рёбер. *Доказывается индукцией с обходом в глубину до листа и его откидыванием (фактически, это будет индукция не по сложению, а по вычитанию)*

Таким образом, мы получаем 3 утверждения

**Т.** `Full` `m`-арное дерево с `i` количеством внутренних вершин. Для него можно вычислить кол-во вершин как `n = mi + 1`

**Т.** Если нам известен один из параметров `full` `m`-арного дерева, мы можем вычслить остальные:
1. Известно количество вершин `n`:
   1. Внутренние вершины `i = (n - 1)/m`
   2. Листья $l = \frac{(m - 1)n + 1}{m}$
2. Известны внутренние вершины `i`:
   1. `n = mi + 1`
   2. `l = (m - 1)i + 1`
3. Листья `l`:
   1. `n = (ml - 1)/(m - 1)`
   2. `i = (l - 1)/(m - 1)`

## Уровень, высота и баланс деревьев
**О.** Уровень вершины в дереве - это длина пути от вершины до корня. (*Соответственно, уровень корня ` = 0`*)

**О.** Высота дерева - максимальный уровень вершин в дереве

**О.** `m`-арное корневое дерево будет **сбалансированным**, если всего его листья находятся на высоте `h` или `h - 1`

**Т.** В `m`-арное дереве высоты `h` количество листьев `l <= m^h`

**С.** Для `m`-арного дерева с количеством листьев `l`: $h \ge ceil(\log_m l)$. Для полного сбалансированного дерева: $h = ceil(\log_m l)$

# 23.02.27 - лекция
## Деревья выборов
**О.** Деревья выборов - деревья, в которых каждая вершина репрезентует выбор одного из вариантов, а листья в поддереве под ней ему соответствуют.

**О.** Пусть от корня до листа в дереве выборов называется **возможным решением**

Дерево выборов можно использовать для поиска наиболее оптимальных вариантов поиска одного отличающегося объекта из множества или для оценки сложности алгоритмов сортировок.

## Префиксные коды и деревья Хаффмана
**О.** Префиксными кодами называются такие коды, каждый из которых не содержит в начале себя другой код, что позволяет нам однозначно понимать, где кончается один код и начинается другой.

Префиксные коды можно изобразить в виде бинарного дерева. Символы будут обозначены названиями листьев, а их коды - пути к ним. Левое ребро обозначается нулём, а правое - единицей.

Для построения максимально экономного дерева (символы, чаще встречающиеся в тексте, будут иметь более короткий код) используется алгоритм Хаффмана:
- Представляем каждый символ как дерево из одной вершины и обозначаем его вес, то есть частоту повторения в тексте
- Берём 2 дерева с наименьшим весом и собираем их в одно. Левым поддеревом становится то, у которого вес больше, а правым - меньше. Весом нового дерева будет считать сумму весов его поддеревьев
- Повторяем прошлый пункт до тех пор, пока все деревья не сольются в одно

**Если мы использует для кодирования не только `0, 1`, то для расчёта количества листьев у самого первого дерева нужно использовать формулу `((N-1) % (m-1)) + 1`, где `N` - количество разных символов для кодирования, а `m` - основание системы счисления**

## Остовные деревья
**О.** Остовное дерево - граф, содержащий все вершины исходного графа и являющийся при этом деревом. **Остовное дерево может быть только у связного графа.** Остовных деревьев у заданного графа может быть много.

**Т.** Простой граф будет связным тогда и только тогда, когда у него есть остовное дерево.

Построить остовное дерево можно удалением рёбер из циклов, но это будет неэффективный алгоритм.

Эффективным алгоритмами будут [**breadth-first search (поиск в ширину)**](#breadth-first-search) и [**depth-first search (поиск в глубину)**](#depth-first-search), а также [алгоритм Прима](#алгоритм-прима) и алгоритм Краскала для взвешенных неориентированных графов

## Breadth-first search
Поиск в ширину заключается в том, что мы выбираем вершину входа (будущий корень остовного дерева), затем подсоединяем к ней все доступные вершины и маркируем их. Далее идём в каждую из вершин и подсоединяем её детей, если они ещё не были промаркированы. Повторяем алгоритм, пока не обойдём все вершины.

**Расширенная версия алгоритма:** добавляем всем вершинам такие параметры, как цвет, расстояние до корня и адрес родителя. Изначально все элементы окрашены в белый, не имеют родителя и расстояние до корня равно бесконечности. Также используем очередь по принципу `FIFO`
- Окрашиваем корневую вершину в серый и присваиваем ей дистанцию `0`. Предка нет.
- Добавляем корень в очередь
- `while queue.notEmpty`:
  - Берём из очереди вершину
  - Обходим все доступные из данной вершины
  - Если вершина белая, помечаем её серым, сохраняя родителем текущую вершину и расстояние до него ` + 1`
  - Добавляем окрашенные серым вершины в очередь
  - Когда с текущей вершиной мы полностью закончили, окрашиваем её в чёрный и берём новую вершину из очереди

Скорость алгоритма - `O(V + E)`

## Кратчайшее расстояние между вершинами
**О.** Кратчайшая длина пути из $s$ в $v$ обозначается как $\delta(s, v)$

**Л.** Если в графе существует путь `(u,v)`, то $\delta(s,v) \le \delta(s,u) + 1$ (*Если `u` достижима из `s`, то мы либо дойдём из `s` до `v` через `u`, либо дойдём до `v` раньше, чем до `u`*)

**Л.** [BFS](#breadth-first-search) позволяет найти все кратчайшие расстояния (**для графов без веса рёбер**) (*доказывается индукцией благодаря очереди типа `FIFO` в алгоритме и прошлой лемме*)

**Т.** Для заданного графа `BFS2` от данной вершины обойдёт все доступные вершины и при том вычислит для них кратчайшее расстояние (*Странная теорема, потому что одно её положение следует из определения алгоритма, а второе - из леммы выше*)

`BFS2` даёт нам **breadth-first tree**

## Алгоритм Прима
Позволяет построить минимально весящее остовное дерево. Из исходного графа берём произвольную вершину, затем смотрим её рёбра и добавляем ребро с наименьшим весом (*и вершину на его конце - ваш кэп*), затем в полученном дереве также проверяем все рёбра, соединяющие вершины дерева с вершинами вне дерева и выбираем минимальное из этих рёбер. Повторяем, пока все вершины не попадут в дерево.

[Демонстрация](https://ru.wikipedia.org/wiki/Алгоритм_Прима#Пример)

*Доказательство минимальности веса остовного графа, полученного алгоритмом Прима: (* Дописать, если не забью *)*

## Алгоритм Краскала
Позволяет построить минимально весящее остовное дерево. Получаем список всех рёбер, затем добавляем минимальное по весу ребро, если оно не вызывает появление цикла. Повторяем до тех пор, пока в списке не останутся лишь рёбра, добавление которых приведёт к возникновению цикла. **PROFIT**

[Демонстрация](https://ru.wikipedia.org/wiki/Алгоритм_Краскала#Пример)

# 23-03-06 - лекция
## Depth-first search
Добавляем корень дерева (*точку входа*) и далее запускаем рекурсивный алгоритм:
1. `while <можем от последней добавленной вершине перейти к ещё не добавленной>`
  1. Добавляем инцидентное последней добавленной вершине ребро с другой вершиной, ещё не добавленной в дерево (*если таковых несколько, берём первую по порядку в нашем представлении графа*)
2. `while <нельзя добавить новых вершин>`
   1. Движемся по добавленным вершинам от конца к началу
3. `if <не дошли до корня>`
   1. Повторяем с пункта `1`
4. `else` - **PROFIT**

Версия на псевдокоде:
```
G - connected graph with vertices v1, ..., vn
T - result tree

visit(v):
  for w that {w adjacent v and w not_in T}:
    add w and edge (v, w) to T
    visit(w)

visit(v1)
```

**Расширенная версия**: предки сохраняются у вершин также, как в BFS2, а окрашивание идёт по следующему принципу: изначально вершины белые, когда мы спускаемся по ним вниз, окрашиваем в серый, когда выходим обратно и покидаем (то есть мы не можем из этой вершины больше перейти ни в какую) - в чёрный. Кроме того, мы храним не только глубину `d`, но и момент обратного выхода `f`, причём хранят они не глубину как таковую, а что-то вроде таймстэмпа. `v.d < v.f`

Псевдокод:
```
for v in G.V:
  v.color = WHITE
  v.pi = NIL

time = 0

for v in G.V:
  if v.color == WHITE:
    visit(G, v)

visit(G, v):
  time++
  v.d = time
  v.color = GRAY
  for u in G.adj[v]:
    if u.color == WHITE
      u.pi = v
      visit(G, u)
  v.color = BLACK
  time++
  v.f = time
```

# 23.03.13 - лекция
## Количество остовных деревьев
### Алгоритм стягивания ребра
Алгоритм для поиска кол-ва остовных деревьев:
- Стягиваем связанные между собой вершины в одну вершину. 
- Количество остовных деревьев исходного графа - сумма кол-ва остовных деревьев со стянутыми вершинами и деревьев, где стянутого ребра нет.
- Пока каждый граф в суммме не будет деревом, продолжаем удаление и стягивание

### Теорема для полного графа
**Формула Келли**: Кол-во остовных деревьев для `n`-дерева = `n^(n-2)`

**Использование на практике:** Выбираем лист с наименьшим номером. Записываем в код Прюфера вершину, смежную с данной, затем удаляем этот лист. Повторяем до тех пор, пока не останется одно ребро (т.е. дерево не будет состоять из двух листьев).

Обладая кодом Прюфера, можно восстановить остовное дерево: в код Прюфера не входят листья, при этом выбирали мы листья с наименьшим номером, поэтому идёт прямо по коду, добавляя к вершинам из кода листья с соответствующими номерами (*номера возрастают с пропуском входящих в код вершин (когда мы добавили лист к коду, мы вычёркиваем эту запись из кода)*)

### Метод Лапласиана
Матрица Лапласа:
- `i == j => a_ij = deg v_i`
- `(i, j) in E => a_ij = -1`
- `otherwise => a_ij = 0`

**Т. Киргоффа о связи матриц и деревьев:** кол-во остовных деревьев в графе можно посчитать как определитель матрицы Лапласа, из которой мы удалили любую строку и столбец.

## Связность
*Повторим:* граф называется связным `<=>` из любой его вершины можно попасть в любую. Имеет одну компоненту связности.

**Cut-vertices (разделяющие вершины)** - вершины, при удалении которых (по одиночке) граф перестаёт быть связным. Существуют также **cut-edge (мосты)**.

Не у всех графов есть cut-vertices и cut-edge. Графы без них называются **nonseparable (ЕДИНЫМИ И НЕДЕЛИМЫМИ!)**.

Число вершинной связности ($\kappa(G)$) - минимальное число вершин, которое нужно удалить для дробления графа на отдельные компоненты связности. Граф называется `k`-вершинно связным, если `k` - число вершинной связности.

Аналогичным образом вводится понятие рёберной связности ($\lambda(G)$). Зачастую рёберная связность больше вершинной.

Для любого графа рёберная связность `<= min deg v` $ = \delta(G)$

$\kappa(G) \le \lambda(G) \le \delta(G)$

# 23.03.13 - семинар
## Типы рёбер при DFS
DFS создаёт 4 типа рёбер:
- Древесные (tree) - простое ребро, по которому мы идём в глубину
- Прямые (forward) - ребро, ведущее из родителя в уже посещённого потомка по другому пути 
- Обратные (back) - ребро, ведущее из потомка в родителя
- Поперечные (cross) - ребро, ведущее из одного поддерева в другое уже посещённое

Из определения следует, что в ориентированном графе есть все виды рёбер, а в неориентированном - только tree и back

## Ещё раз о счёте остовных деревьев
### Ещё немного про стягивание ребра
Дополнение к [этому методу](#алгоритм-стягивания-ребра): если у нас в графе возникает cut-vertex, то мы можем разорвать граф по этой вершине, продублировав её в двух новых графах. Тогда кол-во остовных деревьев в исходном графе будет равно произведению кол-ва остовных в новых двух графах

# 23.03.20 - лекция
## Продолжаем про связность
Разделяющей вершиной называется такая, для которой можно подобрать пару вершин, чтобы путь из одной в другую обязательно проходил через разделяющую вершину.

Любое ребро в связном графе будет либо разделяющим, либо входить в цикл.

Слабо связным графом называется ориентированный граф, который при замене направленных дуг на неориентированные рёбра, станет связным.

Сильно связным графом называется ориентированный граф, в котором можно из любой вершины добраться в любую по направленным дугам.

Ориентированный граф называется связным `<=>` Из любой вершины можно попасть в любую и обратно. Для нескольких сильных или слабых компонент возможны 2 ситуации: компоненты эквивалентны или компоненты не пересекаются

## Двусвязность
Двусвязные графы - графы с $\kappa(G) = 2$, то есть у него нет *cut-vertices*.

**Граф из двух вершин также будет считаться двусвязным, если исходить из определения разделяющих вершин через тройки вершин**

**Л. 2** Для неориентированного графа в его depth-first-tree. Вершина `a` из этого дерева - `cut-vertex`, если:
- `a` - корень => у неё есть несколько потомков 
- `a` - не корень и у неё найдётся такое поддерево `S`, что ни одна из его вершин не будет иметь `back`-рёбер, ведущих в предков `a`. Именно `S` при вырезании `a` в таком случае станет отдельной компонентой связности


**Нижняя точка** - наименьший номер вершины, в которую можно попасть по бэк-ребру (при этом переход по бэк-ребру - последний шаг в поиске). (`min(cur.d, {u.low | u in children of cur}, {v.d | v in back-vertices of cur})`). Находится модификацией DFS и сравнением данных при выходе из вершины. **Очень важно отметить, что из-за поля в множестве потомков поиск параметра `.low` будет рекурсивно-хвостовым**

**Л. *моя собственная (ну чуть-чуть)***: ребро `a-b` будет мостом, если `b.low > a.d` 

### Универсальный (почти) код на Си для поиска cut-vertices
*При небольшой модификации подойдёт и для мостов*

```c
#include "stdlib.h"
#include <stdio.h>

typedef struct {
    int a, b, w, id;
} Edge;

typedef struct ListE {
    Edge val;
    struct ListE* next;
} ListE;

ListE* initList() {
    ListE *head = (ListE*) calloc(1, sizeof(ListE));
    head->next = head;
    return head;
}

void addAfter(ListE* prevElem, Edge value) {
    ListE *newElem = (ListE*) calloc(1, sizeof(ListE)),
            *nextElem = prevElem->next;
    newElem->val = value;
    prevElem->next = newElem;
    newElem->next = nextElem;
}

void freeList(ListE* head) {
    ListE *elemForDel, *elem = head->next;
    while (elem != head) {
        elemForDel = elem;
        elem = elem->next;
        free(elemForDel);
    }
    free(head);
}

#define WHITE 0
#define GREY 1
#define BLACK 2

typedef struct {
    int verticesCnt, edgesCnt;
    ListE **edges;
    int *parents;

    char *colors;
    char *isTreeEdges;
    char *isCutV;
    int cutVCnt;

    int *ups;
    int *inTimes;
    int time;
} GraphData;

void addEdge(ListE **edges, Edge edge) {
    if (!edges[edge.a])
        edges[edge.a] = initList();
    addAfter(edges[edge.a], edge);
}

void readEdges(GraphData *graphData) {
    int a, b;
    Edge newEdge;
    for (int i = 0; i < graphData->edgesCnt; ++i) {
        scanf("%d %d\n", &a, &b);
        newEdge.a = a - 1;
        newEdge.b = b - 1;
        newEdge.id = i;
        addEdge(graphData->edges, newEdge);
        newEdge.a = b - 1;
        newEdge.b = a - 1;
        addEdge(graphData->edges, newEdge);
    }
}

GraphData *initGraphData(int n, int m) {
    GraphData *graphData = (GraphData*) calloc(1, sizeof(GraphData));
    graphData->verticesCnt = n;
    graphData->edgesCnt = m;
    graphData->cutVCnt = 0;
    graphData->colors = (char*) calloc(n, sizeof(char));
    graphData->isTreeEdges = (char*) calloc(m, sizeof(char));
    graphData->isCutV = (char*) calloc(n, sizeof(char));
    graphData->ups = (int*) calloc(n, sizeof(int));
    graphData->inTimes = (int*) calloc(n, sizeof(int));
    graphData->parents = (int*) calloc(n, sizeof(int));

    graphData->edges = (ListE**) calloc(n, sizeof(ListE*));

    return graphData;
}

void freeGraphData(GraphData* graphData) {
    for (int i = 0; i < graphData->verticesCnt; ++i)
        if (graphData->edges[i])
            freeList(graphData->edges[i]);
    free(graphData->edges);
    free(graphData->colors);
    free(graphData->isCutV);
    free(graphData->ups);
    free(graphData->inTimes);
    free(graphData->parents);
    free(graphData);
}

// returns min up
void dfs(GraphData *graphData, int v) {
    graphData->colors[v] = GREY;
    graphData->ups[v] = graphData->time;
    graphData->inTimes[v] = graphData->time;
    graphData->time++;
    int childrenCnt = 0;
    ListE *head = graphData->edges[v];
    if (head) {
        ListE *elem = head->next;
        int u;
        while (elem != head) {
            u = elem->val.b;
            if (!graphData->isTreeEdges[elem->val.id] &&
                graphData->colors[u] != WHITE && graphData->inTimes[u] < graphData->ups[v])
                graphData->ups[v] = graphData->inTimes[u];
            if (graphData->colors[u] == WHITE) {
                childrenCnt++;
                graphData->isTreeEdges[elem->val.id] = 1;
                graphData->parents[u] = v;
                dfs(graphData, u);
                if (graphData->ups[u] < graphData->ups[v])
                    graphData->ups[v] = graphData->ups[u];
                if (
                    graphData->parents[v] != -1 && !graphData->isCutV[v]
                    && graphData->ups[u] >= graphData->inTimes[v]
                ) {
                    graphData->cutVCnt++;
                    graphData->isCutV[v] = 1;
                }
            }
            elem = elem->next;
        }
    }
    if (graphData->parents[v] == -1 && childrenCnt > 1) {
        graphData->cutVCnt++;
        graphData->isCutV[v] = 1;
    }
    graphData->colors[v] = BLACK;
}

void printCutEdges(GraphData *graphData) {
    printf("%d\n", graphData->cutVCnt);
    for (int i = 0; i < graphData->verticesCnt; ++i)
        if (graphData->isCutV[i])
            printf("%d ", i+1);
}

int main() {
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);

    int n, m;
    scanf("%d %d\n", &n, &m);
    GraphData *graphData = initGraphData(n, m);
    readEdges(graphData);

    graphData->time = 0;
    for (int i = 0; i < graphData->verticesCnt; ++i)
        if (graphData->colors[i] == WHITE) {
            graphData->parents[i] = -1;
            dfs(graphData, i);
        }

    printCutEdges(graphData);

    freeGraphData(graphData);
    return 0;
}
```

## ST-нумерация
Если граф двусвязный, то можно взять ребро `s-t`. Дать `s` номер 1, а `t` - номер `n = |V|`, а затем дать все остальным связанным с `s` и `t` промежуточные номера из интервала `(1, n)`

# 23.03.27 - лекция
## ST-ориентация
ST-ориентация строится при помощи ST-нумерации - такая нумерация, что выполняется условие `i-j in E <=> i < j`

Таким образом, мы берём неориентированный граф, располагаем вершины в ряд, проводя между ними рёбра, а затем нумеруем и ориентируем рёбра в соответствии с правилом выше.

### Алгоритм Тарьяна
- Нумеруем вершину `s` как 1, `t` как 2
- Запускаем `DFS(s)`, считая `.d`, `.parent` и `.low` и раздавая номера вершинам
- *дальше магия с sign(v), которую опишу потом*

## Кратчайшие пути
**Л.** Подпуть кратчайшего пути также будет кратчайшим путём

## Алгоритм Беллмана-Форда
Позволяет находить кратчайший путь из одной вершины в другую

Вспомогательные функции
```
init(G, s):
for vertex v in G.V:
  v.d = inf
  v.pi = NUL
s.d = 0

# w - функция веса, возвращающая вес ребра между переданными вершинами (гарантируется, что такое ребро существует)

relax(u, v, w):
  if v.d > u.d + w(u, v):
    v.d = u.d + w(u, v)
    v.pi = u
```
Основной алгоритм
```
init(G, s)

for i = 1 to |G.V| - 1:
  for edge (u,v) in G.E:
    relax(u, v, w)

# Проверка на достижимые циклы отрицательного веса
for edge (u,v) in G.E:
  if v.d > u.d + w(u,v):
    return FALSE
return TRUE
```

**Т. О корректности алгоритма Беллмана-Форда**
После запуска алгоритма Беллмана-Форда из вершины `s` графа `G` возможны 2 случая:
1. Если в графе нет циклов отрицательного веса, достижимых из `s`, алгоритм установит в качестве `v.d` кратчайший путь из `s` в `v`, а параметр предка позволит построить дерево кратчайших путей (*Доказывается из вышеозвученной (тут её нет) леммы*)
2. Если в графе есть циклы отрицательного веса, достижимые из `s`, алгоритм вернёт `FALSE` (*Доказывается от противного*)

После этого алгоритма можно проверить граф на связность: если ещё раз пройтись по всем рёбрам и будет найдено ребро, которое 

# 23.04.03 - лекция
## Алгоритм Дейкстры
Работает гораздо быстрее, но только на графах **без отрицательных** рёбер. Вспомогательным будет множество `S`, содержащее те вершины графа, для которых уже определён кратчайший путь.

```
init(G, s)

S = []
Q = G.V

while Q.notEmpty:
  u = extractMin(Q)  # Извлекаем вершину с минимальным .d
  S += [u]
  for vertex v in G.adj[u]
    relax(u, v, w) 
```
Функции `init` и `relax` аналогичный одноимённым функциям из [алгоритма Беллмана-Форда](#алгоритм-беллмана-форда)

**Т. О корректности алгоритма Дейкстры** Алгоритм Дейкстры, запущенный на графе без отрицательных рёбер, даст нам кратчайшие пути из исходной вершины  и построит дерево кратчайших путей (*половина теоремы Беллмана-Форда, в общем*)

Эффективность алгоритма - `O(|V|^2)`

## Поиск кратчайшего пути между всеми парами вершин
*Запись вида $x^(n)$ будет означать состояние $x$ на $n$-й итерации.*

Матрица предществования `P`:
- `p_ij = NIL <=> i = j or no path from i to j`
- `p_ij` -  предок `j` на кратчайшем пути из `i` в `j`

То есть для `P(0)`: `p_ij = i` (если есть ребро)

Благодаря этой матрице мы можем построить подграф предшественников для любой из вершин.

### Кратчайшие пути через матричное умножение
`W` - матрица весов (`w_ij` - путь из `i` в `j`)

`L^m` - матрица длины пути из `m` вершин, где `l_ij` - длина кратчайшего пути. Таким образом, ответ будет в матрице `L^(n-1)`

$$
l^{(m)}_{ij} = min\{l^{(m-1)}_{ik} + w_{kj}\}
$$

# 23.04.10 - лекция
*Продолжаем про кратчайшие пути между всеми парами*
## Флойд-Уоршелл (*снова*)
Последовательно рассматриваем пути для которых вершина `k` не является промежуточной, а все вершины `[1, k-1]` могут быть промежуточными, для каждой вершины из этого множества выполняется то же условие, что и для `k`. Получаем динамический алгоритм расчёта всех путей.

Если действовать руками: для итерации `k` берём `k`-ю строку и `k`-й столбец. Для расчёта `i`-строки берём `k`-ю строку и прибавляем к ней `i`-й элемент `k`-го столбца. В новой матрице путей обновляем в `i`-й строки те ячейки, значения в которых получились меньше, чем на прошлом этапе.

Эффективность `O(|V|^3)`

Матрица с путями длины `n` в таком случае будет обозначаться `D^(n)`.

Если мы заменили `d_ij` на `d_ik + d_kj`, то ячейка матрицы предшествования `p_ij = p_kj`

Для восстановления пути из `i` в `j` мы берём предшественника `v`, равного `p_ij`, добавляем `v` в конце пути и берём `v = p_iv` до тех пор, пока `v != i`

## Флойд-Уоршалл с восстановлением путей на Си
Восстановление пути здесь происходит рекурсивным методом. В матрице "посредников" сохраняется какая-то вершина на пути из `i` в `j`, если вершины там есть, если между `i` и `j` непосредственно ребро, то в матрице будет `-1`
```c
#include "stdlib.h"
#include <stdio.h>
#include <string.h>

#define BIG_INT 400000000
#define STR_BUF_SZ 32768

typedef struct MatrixGraph {
    int n;
    int **matrix;
    int **verticesBetween;
    char *wayBuffer;
    char *bufferFreePtr;
    int wayLen;
} MatrixGraph;

MatrixGraph* initMatrixGraph(int n) {
    MatrixGraph *matrixGraph = (MatrixGraph*) calloc(1, sizeof(MatrixGraph));
    matrixGraph->n = n;
    matrixGraph->matrix = (int**) calloc(n, sizeof(int*));
    matrixGraph->verticesBetween = (int**) calloc(n, sizeof(int*));
    matrixGraph->wayBuffer = (char *) calloc(STR_BUF_SZ, sizeof(char));
    for (int i = 0; i < n; ++i) {
        matrixGraph->matrix[i] = (int *) calloc(n, sizeof(int));
        matrixGraph->verticesBetween[i] = (int *) calloc(n, sizeof(int));
        for (int j = 0; j < n; ++j) {
            matrixGraph->matrix[i][j] = i == j ? 0 : BIG_INT;
            matrixGraph->verticesBetween[i][j] = -1;
        }
    }
    return matrixGraph;
}

void readEdges(MatrixGraph *matrixGraph, int edgesCnt) {
    int a, b, time;
    for (int i = 0; i < edgesCnt; ++i) {
        scanf("%d %d %d\n", &a, &b, &time);
        a--;
        b--;
        if (matrixGraph->matrix[a][b] > time) {
            matrixGraph->matrix[a][b] = time;
        }
    }
}

void freeMatrixGraph(MatrixGraph *matrixGraph) {
    for (int i = 0; i < matrixGraph->n; ++i) {
        free(matrixGraph->matrix[i]);
        free(matrixGraph->verticesBetween[i]);
    }
    free(matrixGraph->matrix);
    free(matrixGraph->verticesBetween);
    free(matrixGraph->wayBuffer);
    free(matrixGraph);
}

void floydWarshall(MatrixGraph *matrixGraph) {
    for (int k = 0; k < matrixGraph->n; ++k)
        for (int i = 0; i < matrixGraph->n; ++i)
            for (int j = 0; j < matrixGraph->n; ++j)
                if (matrixGraph->matrix[i][j] > matrixGraph->matrix[i][k] + matrixGraph->matrix[k][j]) {
                    matrixGraph->matrix[i][j] = matrixGraph->matrix[i][k] + matrixGraph->matrix[k][j];
                    matrixGraph->verticesBetween[i][j] = k;
                }
}

void printToBuffer(MatrixGraph *matrixGraph, int val) {
    char tmpStr[6] = "";
    sprintf(tmpStr, "%d ", val);
    strcpy(matrixGraph->bufferFreePtr, tmpStr);
    matrixGraph->bufferFreePtr += strlen(tmpStr);
}

void printWayToBuffer(MatrixGraph *matrixGraph, int a, int b, int beg, int end) {
    int w = matrixGraph->verticesBetween[a][b];
    if (w == -1) {
        if (a == beg)
            printToBuffer(matrixGraph, a+1);
        if (b == end)
            printToBuffer(matrixGraph, b+1);
        return;
    }
    matrixGraph->wayLen++;
    printWayToBuffer(matrixGraph, a, w, beg, end);
    printToBuffer(matrixGraph, w+1);
    printWayToBuffer(matrixGraph, w, b, beg, end);
}

void shortestWaysProcessing(MatrixGraph *matrixGraph, int shortestWaysResponses, int* responsesDestinations) {
    int a = 0, b;
    for (int i = 0; i < shortestWaysResponses; ++i) {
        b = responsesDestinations[i] - 1;
        matrixGraph->wayLen = 2;
        matrixGraph->bufferFreePtr = matrixGraph->wayBuffer;
        printWayToBuffer(matrixGraph, a, b, a, b);
        printf("%d  %d  %s\n", matrixGraph->matrix[a][b], matrixGraph->wayLen, matrixGraph->wayBuffer);
    }
}
```

## Алгоритм Джонсона
Самый быстрый - `O(V^2 lg V + VE)`

Если в графе нет отрицательных рёбер, мы просто запускаем [алгоритм Дейкстры](#алгоритм-дейкстры) для всех вершин.

Если есть отрицательные рёбра (*но не отрицательные циклы, ясное дело*), то мы пересчитываем все веса по двум следующим правилам:
- Пути, бывшие кратчайшими, должны таковыми и остаться
- Новые веса должны быть позитивными (*весёёёлыми!!11!!!1!!!!1!!*)

Для начала отметим, что преобразование `w'(u,v) = w(u, v) + h(u) - h(v)`, то есть все кратчайшие пути останутся кратчайшими.

Далее добавим к графу вершину `s` с рёбрами нулевого веса и запустим от неё [алгоритм Беллмана-Форда](#алгоритм-беллмана-форда).

Определим `h(v) = path[v]`, рассчитанный Беллманом. Теперь мы можем перевзвесить рёбра так, что они все будут `>= 0`

# 23.04.17 - лекция
## Обходы Эйлера
**О.** Эйлеров цикл графа - цикл, единожды проходящий по всем рёбрам графа

**О.** Эйлеров путь - простой путь, содержащий все рёбра графа `G`

### Эйлеров цикл
Эйлеров цикл существует <=> степени всех вершин в графе чётные.

Основной алгоритм поиска - проходимся по графу, собирая простой цикл, удаляем из графа все пройденные рёбра и ищем цикл в оставшейся части. Когда в графе не останется рёбер, склеиваем получившиеся циклы по общим вершинам.

Алгоритм Флюри - как только проходим по ребру, удаляем его. Стараемся избегать мостов, но если нет альтернативы - проходим по ним.

### Эйлеров путь
**Т.** Эйлеров путь существует <=> в графе ровно 2 вершины нечётной степени (*причём вершины с нечётными степенями будут располагаться на концах пути*)

### Зачем оно надо?
На практике построение Эйлерова цикла и пути служит для построения маршрутов при условии необходимости посещения всех вершин (развозка почты, сбор мусора и т.п.). Отдельная интересная задача - восстановление цепочек РНК и ДНК

## Обходы Гамильтона
Гамильтонов цикл - простой цикл, единожды проходящий через все вершины

Гамильтонов путь - простой путь, единожды проходящий через все вершины

### Условия циклов
Если в графе есть листья, цикла Гамильтона точно не будет.

При наличии вершин `deg = 2` оба инцидентных этой вершине ребра должны принадлежать циклу.

Цикл Гамильтона не может содержать подциклы.

**Т. Дирака** Если есть простой граф с `n >= 3` вершин и у каждой вершины `deg >= n / 2`, тогда граф имеет Гамильтонов цикл.

*Доказывается от противного через взятие максимального негмаильтонова графа с `n >= 3` и `deg >= n/2`, а затем разбиение его вершин на 2 непересекающихся множества. Взятый граф точно не будет полным, а значит в нём нет как минимум одного ребра, приходим к противоречию суммы степеней, так как сумма степеней двух вершин даст нам `< n`, хотя должно быть `>= n`*

**Т. Оре** Для графа из `n >= 3` вершин, если для любых двух несмежных вершин `u`, `v`: `deg(u) + deg(v) >= n`, тогда граф имеет Гамильтонов цикл

Обе теоремы показывают достаточное, но не необходимое условие для существования Гамильтонова цикла. Например, `C5` не удовлетворяет условию теорем, но имеет Гамильтонов цикл.

### Приложение Гамильтоновых обходов
Одним из примеров будет задача коммивояжёра - пройти через все точки и вернуться в начальную за минимальную цену. Решается **только перебором**, но есть некоторые эвристические алгоритмы.

CLA - Cheapest link algorithm: добавляем все рёбра с минимальным весом, если они не:
- замыкают маленький Гамильтонов цикл
- выходят из вершины, степень которой уже `= 2`
Завершаем, когда был получен полный Гамильтонов путь. **Так как алгоритм эвристический, мы не можем гарантировать, что Гамильтонов цикл будет найден.**

NNA - Nearest Neighbor Algorithm: выбираем какую-то начальную вершину и далее добавляем минимальное из неё исходящее, преходим в следующую. Добавление ребра будет происходить при тех же условиях, что CLA.

# 23.04.24 - лекция
## Потоки
Поток из истока `s` в сток `t` - это отображение каждого ребра в вещетсвенное число

Вес ребра называется пропускной способностью.

Значение потока меньше пропускной способности ребра.

Для всех вершин кроме `s` и `t` сумма потоков входа = сумме потоков выхода

Значение потока - сумма всех потоков, исходящих из вершины

## Вычисление максимального значения потока (Алгоритм Форда-Фолкерсона)
Берём какой-то путь `s-t` и выбираем как поток на всём этом пути минимальное значение пропускной способности рёбер в этом пути.

Далее строим обратный граф, в котором:
- Рёбра, для которых поток не был вычислен, остаются неизменными.
- Рёбра с вычисленным потоком могут разделиться на 2:
  - Обратное - имеет пропускную способность, равную вычисленному потоку
  - Прямое = пропускная способность минус вычисленный поток (если значение = 0, ребра не будет)

Также вводятся следующие обозначения и функции:
- `P` - простой путь из `s` в `t`
- `G` - исходный граф
- `G_f` - обратный граф
- `bottleneck(P, f)` - возвращает максимально возможное значение потока на пути `P`
- `augment(f, P)` - обновляет поток, возвращая ему новые значения

**Алгоритм повторяется до тех пор, пока значение потока `s` > 0**

**Л. 3** На каждом этапе алгоритма Форда-Фолкерсона поток строго увеличивается

**Л. 4** Предполагая, что все пропускные способности и потоки целые, мы можем утверждать, что алгоритм Форда-Фолкерсона будет исполнен за не больше, чем `C` итераций (`C = sum c_e` - сумма пропускных способностей всех рёбер)

**Л. 6** Для любого `s-t` потока и любого (`A`, `B`) разреза: `v(f) = f_out(A) - f_in(A)`

**Л. 7** Для любого `s-t` потока любого (`A`, `B`) разреза: `v(f) = f_in(B) - f_out(B)`

**Л. 8** Для любого потока и разреза значение потока не будет больше пропускной способности любого разреза.

## ГЛАВНАЯ, МАТЬ ЕГО, ТЕОРЕМА
`f` - поток, полученный алгоритмом Форда-Фолкерсона.

Мы хотим подобрать такой разрез, чтобы его пропускная способность в точности равнялась значению потока.

**Л. 9** Если мы нашли такой поток `f`, что больше нет путей `s-t` в остаточном графе (алгоритм Форда-Фолкерсона завершился), тогда найдётся такой разрез `(A*, B*)`, что `v(f) = c(A*, B*)` (*То есть пропускная спосбность разреза будет минимально возможной, а поток - максимальным*)

*Докажем через следующее разбиение:*
- `A` - все вершины, достижимые из `s`
- `B` - все остальные вершины

**Л. 10** Поток, выдаваемый алгоритмом Форда-Фолкерсона, будет наибольшим

**Л. 11** Алгоритм Форда-Фолкерсона позволяет находить разре наименьшей пропускной способности

**Л. 12** В любой потоковой сети существуют такие потоки и разрезы, что будет поток, равный

**MAX-FLOW, MIN-CUT Theorem:** для любой потоковой сети пропускная максимальное значение потока в точности будет равняться минимальной пропускной способности разреза

## Выбор оптимальных путей в алгоритме Форда-Фолкерсона
**Уивепдление Эдманса-Карпа:** на каждом этапе алгоритма Форда-Фолкерсона мы хотим выбирать сокращающий путь из минимального количества рёбер (например, используя BFS)

**Т.** Если запустить алгоритм Эдманса-Карпа, то он выполнится за `O(VE^2)`

Итоговый алгоритм получается следующий:
1. Находим путь из `s` в `t` = `P`, используя BFS
2. Получаем значение `b = bottleneck(f, P)`
3. Увеличиваем значение на `b` потока для всех рёбер пути и уменьшаем остаточную ёмкость на это же значение

# 23.05.15 - лекция
## Паросочетание (matchings)
**О.** Паросочетание - такое подмножество рёбер графа, в котором каждая вершина появляется единожды

**О.** Совершенное паросочетание - содержит рёбра со всеми вершинами. У графа с нечётным количеством вершин точно не может быть паросочетаний.

Matchatble graph (паросочетаемый) - граф, в котором существует совершенное паросочетание.

**О.** Наибольшее (maximum) паросочетание - паросочетание с максимально возможным для данного графа количества рёбер

**О.** Максимальное (maximal) паросочетание - паросочетание, к которому больше нельзя добавить рёбер.

**О.** Полное паросочетание - паросочетание для двудольного графа, где все вершины меньшей доли содержатся на концах его рёбер.

**Найти полное (либо наибольшее) паросочетание очень легко через алгоритм поиска максимального потока:**
1. Подсоединяем ко всем вершинам одной доли исток, к другой - сток. Всем рёбрам задаём пропускную способность 1
2. Ориентируем рёбра из первой доли во вторую
3. Запускаем поиск потока
4. Все рёбра исходного графа, по которым в итоге будет проходить поток - рёбра, входящие в паросочетание

**О.** Чередующийся путь (альтерниррующий путь) - путь, в котором для паросочетания взято частть рёбер (очевидно, не смежных). Увеличивающим путём будет такой, у которого оба конца не принадлежат рёбрам паросочетания (то есть количество рёбер в паросочетании при взятии альтернирующего пути возрастёт)

На основании этого определения строится ещё один алгоритм (интернирующих путей), который по сути своей работает аналогично Форду-Фолкерсону, просто без подсоединения истока и стока.

**Т. Берджа:** найдено наибольшее паросочетание, если в графе больше нет увеличивающих путей. *Прямое доказательство:* Если есть увеличивающий путь, значит мы можем увеличить кол-во рёбер в паросочетании, а значит текущее паросочетание не наибольшее. *В обратную сторону через XOR нескольких различных паросочетаний*

**Т. Холла** Двудольный граф (X, Y) содержит полное паросочетание для доли X $\hArr$ `|N(S)| >= |S|` для любого подмножества S из X.

## Покрытие
Вершинное покрытие графа - подмножество вершин, для которого каждое ребро исходного графа инцедентно (**Не обязательно, чтобы оба конца ребра входили в покрытие**)

Мощность наибольшего паросочетания меньше или равно мощности минимального покрытия. Для двудольных графов будет строгое равенство.

**Алгоритм поиска наименьшего вершинного покрытия для двудольного графа:**
1. Строим паросочетания. Если паросочетание содержит рёбра, инцидентные всем вершинам. Покрытием будет любая доля
2. Иначе берём не вошедшую вершину и строим из неё альетрнирующий путь. Берём из доли, которой принадлежала начальная вершина, не вошедшие в путь вершины, а из другой доли - вошебшие. Из объединение будет минимальным покрытием

# 23.05.15 - семинар
Хроматический индекс (хи штрих) - кол-во максимальных цветов, в которые можно покрасить граф. = $\Delta$ или $\Delta + 1$. Для двудольных равна только первая оценка

**Алгоритм покраски рёбер двудольного графа (составление расписания):**
1. Отзеркалить граф
2. Посчитать дэльту
3. Дополнить каждую вершину рёбрами к её зеркальной версии, чтобы у всех вершин была степень дэльта
4. Мы полачили дэльта-регулярный двудольный граф, у которого гарантированно есть совершенное паросочетание. Строим это сочетание. Попавшие рёбра из исходного графа окрашиваем в первый цвет. Убираем все попавшие в паросочетание рёбра. Повторяем дэльта раз

Хроматическое число (хи) - число цветов для покраски вершин.

**Т. Брукса:** `хи <= delta` (кроме K_n и C_n при n % 2 != 0).

Жадный алгоритм для покраски вершин - берём произвольную вершину и красивым в минимально допустимый цвет. Гарантированно окрашивает граф в `<= delta + 1` цветов

Гарантированный алгоритм - перебор по алгоритму **connection contraction**