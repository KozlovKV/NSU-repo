# 1. Понятие степени вершины в ориентированном и неориентированном графе. Теоремы о степенях вершин в неориентированном и ориентированном графе
Степень вершины графа в неориентированном графе — количество ребер графа, инцидентных вершине. При подсчете степени ребро-петля учитывается дважды. Степень обозначается deg(v). Вершина степени 0 – изолированная. Отсюда следует, что изолированная вершина не смежна с какой-либо вершиной. Вершина степени 1 –  висячая. Следовательно, висячая вершина смежна ровно с одной другой вершиной.

**Теорема о рукопожатиях**. Пусть G = (V, E) - неориентированный граф с m ребрами.
Тогда $2m=\sum \deg(v), v∈V$

**Теорема о вершинах с нечётной степенью в неориентированном графе**:
Неориентированный граф имеет четное число вершин нечетной степени.
Доказательство:
Пусть V1 - множество вершин четной степени, а V2 - множество вершин нечетной
степени в неориентированном графе G = (V, E) с m ребрами. 
$$
2m = \sum_{v \in V} \deg(v) = \sum_{v \in V1} \deg(v) + \sum_{v \in V2} \deg(v)
$$
Тогда:
Поскольку deg(v) четно для v ∈ V1, первое слагаемое в правой части последнего
равенства четное.
Кроме того, сумма двух слагаемых в правой части последнего равенства четна, потому
что эта сумма равна 2m.
Следовательно, второе слагаемое в сумме также является четным.
Поскольку все слагаемые в этой сумме нечетны, таких слагаемых должно быть четное
число.
Таким образом, существует четное количество вершин нечетной степени.

В ориентированном графе полустепень захода v, обозначаемая $\deg_-(v)$, представляет собой число ребер с v в качестве их конечной вершины. Полустепень исхода v, обозначаемая $\deg_+(v)$, представляет собой число ребер с v в качестве начальной вершины. (Обратите внимание, что ребро-петля в вершине вносит 1 как в полустепень захода, так и в полустепень исхода этой вершины).

**Теорема о степенях входа и выхода**. В ориентированном графе с m рёбрами:
$$
m = \sum_{v \in V} \deg_-(v) = \sum_{v \in V} \deg_+(v)
$$
Доказывается из определения степеней вершин для орграфа. В частности, того факта, что каждое ребро будет для одной вершины давать +1 к $\deg_-$, а для другой - +1 к $\deg_+$

Основание - неориентированный граф, полученный при игнорировании направления рёбер в орграфе. Имеет такое же количество рёбер и используется потому, что для многих свойств графа направление рёбер не играет роли.

# 2. Понятие изоморфизма. Способы установления наличия или отсутствия изоморфизма
2 простых графа `G1 = (V1, E1)` и `G2 = (V2, E2)` - изоморфны, если существует биекция `f`, сохраняющая отношение смежности для вершин и рёбер графов: для любых $\forall a, b \in V1 : (a,b) \in E1 \hArr (f(a),f(b)) \in E2$. Отношение изоморфизма для простых графов будет отношением эквивалентности

Из определения мы получаем следующие обязательные условия для изоморфизма (их также называют инвариантами графов):
1. Одинаковое кол-во вершин
2. Одинаковое кол-во рёбер
3. Количество вершин с определёнными степенями одинаково

Выше приведены **необходимые, но недостаточные** условия изоморфизма.

Если для двух графов можно построить идентичные (после перестановок столбцов и/или строк) матрицы смежности, значит между ними существует изоморфизм. Другие алгоритмы для точного установления изоморфизма являются NP-полными.

# 3. Понятие пути, цикла, простого пути и простого цикла. Теорема о существовании простого пути между парой различных вершин связного неориентированного графа
**О.** Путь - последовательность рёбер, первое из которых содержит начальную вершину, а последнее - конечную вершину. Для орграфа, что очевидно, мы должны указывать рёбра строго в порядке следования от начала пути к концу.

Также можно расширить путь до маршрута - перед и после ребра указывать в последовательности вершины. Если граф простой, путь можно указывать просто как последовательность вершин.

**О.** Цикл (circuit) - путь ненулевой длины, начинающийся и заканчивающийся в одной и той же вершине

**О.** Простой путь/цикл не содержит одних и тех же рёбер более одного раза.

**О.** Граф называется связным (connected), если существует путь между двумя любыми его вершинами.

**Т. о существовании простого пути между парой различных вершин связного неориентированного графа**. Для связного неориентированного графа между двумя любыми вершинами существует простой путь. *Доказательство:* Из связности графа следует существование пути. Возьмём путь из `u` в `v` минимальной длины. Такой путь будет простым. Предположим обратное: тогда среди вершин `{x_1, ..., x_n}` найдутся такие `x_i`, `x_j`, что `x_i = x_j` (`0 <= i < j`), а это значит, что путь `u-v` останется путём из `u` в `v`, если из него убрать вершины `{x_i, ..., x_j-1}`, но уже меньшей длины, однако по условию минимальности длины это невозможно, из чего и следует простота исходно взятого пути. 

Максимальный связный подграф - *пояснения излишни*, Связные подграфы называются компонентами связности.

Если в одном графе есть путь длины `n`, а в другом точно нет пути такой же длины => графы точно не изоморфны.

# 4. Матрица смежности и свойства графа
Матрица смежности (adjacency matrix) - таблица `n*n`, где (`n` - кол-во вершин в графе). `matrix[i][j] = 1 <=> (i, j) in edges`. Для мультиграфов вместо единички записывается количество рёбер.

Матрицы смежности могут использовать для подсчёта количества путей в графе.

Условные обозначения:
- `I` - единичная матрица (главная диагональ из единиц, остальное - нули)
- `J` - матрица целиком состоящая из единиц
- `A` - матрица смежности (ячейка $a_{ij}$ будет обозначаться как `A(i,j)`)

Для неорграфа `A^T = A`.

Связь степеней вершин и значений `A`:
- в неорграфе: $deg(v_i) = \sum_{j=1}^n a_{ij} = \sum_{j=1}^n a_{ji}$
- в орграфе: $deg_+(v_i) = \sum_{j=1}^n a_{ij}$ и $deg_-(v_i) = \sum_{j=1}^n a_{ji}$

**Т. о количестве путей произвольной длины через матрицу смежности**. Для любого графа G ячейка `(i, j)` матрицы смежности в степени `k` - кол-во путей из `v_i` в `v_j` длины `k`. *Доказательство:* для матрицы `A^1` утверждение очевидно - `A(i,j) = 1 =>` вершины смежны. Это база индукции. Далее будем считать, что утверждение теоремы верно для `A^k` и докажем его справедливость для `A^(k+1)`. Любой путь длины `k+1` из `v_i` в `v_j` будет содержать путь длины `k` из `v_i` в соседей `v_j` (`N(v_j)`). Будем обозначать принадлежащие этому множеству вершины как `v_p`, тогда по условию кол-во путей из `v_i` в `v_p` длины `k` будет `A^k(v,p)`. Значит для вычисления путей из `i` в `j` длины `k+1` нам надо сложить все `A^k(v,p)`, то есть получаем формулу:
$$
\sum_{v_p \in N(v_j)} A^k(i,p) = \sum_{l=1}^n A^k(i,l)A(l,j) = A^{k+1}(i,j)
$$

След матрицы (`trace`) - сумма главной диагонали матрицы смежности в степени `k`. Некоторые особенности следа:
- `tr(A) = 0` - для простого графа без петель
- Для неориентированного графа: `tr(A^2) = 2|E|`. Доказывается через банальный факт того, что мы из каждой вершины идём во всех её соседей, а затем обратно, то есть `A^2(i,i) = deg(v_i)`
- Связь с количеством треугольников `t` в графе: `6t = tr(A^3)`. Для каждой вершины мы можем пройти циклический путь двумя способами (условно выражаясь, по часовой стрелке и против), также учитывая, что в треугольнике 3 вершины, каждая из которых может быть стартовой, получаем, что ячейка `A(i, i)` показывает нам кол-во треугольников, в которые входит `v_i`, умноженное на 6 
- `q` - циклы длины 4. Тогда $tr(a^4) = 8q - 2|E| + 2 \sum_{i=1}^{|V|} \deg^2(v_i)$. Получается данная формула простыми арифметическими преобразованиями при суммировании 3 случаев циклов длины 4 для каждой вершины:
  1. Обычный квадрат. Их будет `8q` по тем же резонам, что `6t` в пункте выше (в итоговом выражении для следа, для отдельной вершины - `2q`)
  2. `v_i - x - v_i - y`, где `x, y in N(v_i)` - таких циклов будет $\deg^2(v_i)$
  3. `v_i - x - y - x`, где `x in N(v_i)` и `y != v_i & y in N(x)` - таких циклов будет $\sum_{x \in N(v_i)} (\deg(x) - 1)$
  - <img src="./8q.png" width="50%">

Графы с `n = |V| >= 2` связные `<=>` все ячейки вне главной диагонали е матрицы `B = A + A^2 + ... + A^(n-1)` > 0. Фактически, минимальная степень, в которой `A(i,j) > 0` - это минимальная длина пути `i-j`. *Доказательство:*
- Если граф связный, то между любыми вершинами `i`, `j` можно будет построить путь длины `k <= n-1` => `A^k(i,j) > 0` => `B(i,j) > 0`
- *В обратную сторону:* если для любой `B(i,j) > 0` (`i != j`) => найдётся такое минимальное `k <= n-1`, что `A^k(i,j) > 0`, значит есть простой путь из `i` в `j`. Отсюда следует, что все вершины связаны со всеми, а значит граф связный

Матрица смежности дополнения графа (`A(G')`, далее будет `A'`) - матрица, где все ячейки изначально равные нулям (не считая диагональных), равны единицам - и наоборот. Матрица смежности и матрица смежности дополнения связаны равенством `A + A' + I = J`, которое напрямую следует из определения дополнения графа как графа, при объединении с которым исходный граф даст полный граф.

Если матрица симметрична, то все собственные значения будут вещественными, а собственные вектора будут взаимноортоганальны. Напомним, что с.з. будут находиться через уравнение $\det(\lambda I - M) = 0$

**О.** Характеристический полином матрицы смежности - `p(t) = det(tI - A)`. Или, выражая полученные с.з., получаем $p(t) = (t - \lambda_1)(t - \lambda_2)...(t - \lambda_n)$

**О.** Спектр графа - набор скаляров собственных значений графа, расположенный по неубыванию. ($spec(G) = {\lambda_1, \lambda_2, ..., \lambda_n} : \lambda_1 \le \lambda_2 \le ... \le \lambda_n$)

Любое собственное значение графа не превосходит его максимальную степень. Более того, будет справедливо неравенство $\frac{2|E|}{2} \le \lambda_n \le \Delta(G)$

Регулярный граф - граф, в котором все степени вершин одинаковы. Граф `k`-регулярный `<=>` единичный вектор - его собственный вектор с собственными значениями `= k`. *Доказывается* в обе стороны через тот факт, что для `k`-регулярного графа `Ae = ke = {deg(v_1), deg(v_2), ..., deg(v_n)} = {k, k, ..., k}`

Спектры изоморфных графов идентичны. **Обратное не верно**

# 5. Понятие дерева. Теорема о единственности пути в дереве
**О.** Деревья - это связные ненаправленные ациклические простые графы

**О.** Лес - несколько несвязных деревьев

**Т.** Неорграф - дерево `<=>` между любыми двумя его вершинами существует единственный путь. *Доказательство:* предположим обратное, то есть что в дереве есть 2 пути из `x` в `y`, тогда объединение этих путей даст нам цикл, что противоречит определению дерева. *В обратную сторону:* если между любыми вершинами существует единственный простой путь, значит во-первых, граф связный, во-вторых, в нём нет циклов, отсюда следует, что граф - дерево.

# 6. Понятие корневого дерева. Свойства корневого дерева
**О.** Корень - произвольная выбранная в дереве вершина, от которой мы направляем рёбра ко всем другим вершинам (то есть получаем из дерева ориентированный граф) и получаем **корневое дерево**. Корень в дереве может быть только один (поэтому стрелки у рёбер часто не указываются). Любая из вершин дерева может быть выбрана как корень, относительно которого мы сориентируем всё дерево.

Если в дереве для вершины `v`, не являющейся корнем, существует ребро `u-v`, то `u` - **отец** вершины `v`. **Отец уникален**. `v` будет **сыном** `u`. **Сыновей может быть много**

Несколько сыновей одного и того же отца будут называться **братьями (siblings)**.

Все вершины на пути от корня до `v` (не включая `v`) - **предки `v`**. Все вершины, для которых `v` является предком - **потомки `v`**

**Лист** - вершина, не имеющая детей. В ином случае вершина называется **внутренней**

**Поддерево `v`** - часть исходного дерева, включая вершину `v` и её потомков

**О.** Корневое дерево называется `m`-арным дерево, если каждый из его внутренних элементов имеет `<= m` потомков

**О.** Если у каждой внутренней вершины ровно `m` потомков, то это дерево называется полным (`full`) `m`-арным деревом

**О.** Уровень вершины в дереве - это длина пути от вершины до корня. (*Соответственно, уровень корня ` = 0`*)

**О.** Высота дерева - максимальный уровень вершин в дереве

**О.** `m`-арное корневое дерево будет **сбалансированным**, если всего его листья находятся на высоте `h` или `h - 1`

**О.** Заполненное (`complete`) `m`-арное дерево - подмножество полных деревьев, где до максимальной глубины существуют все вершины.

**Т.** В каждом дереве с `n` вершинами ровно `n-1` рёбер. *Доказательство:* по индукции - для дерева с `n = 1` утверждение верно. Для дерева из `k+1` и `k` вершин мы откидываем один лист, при этом теряется и одно ребро, то есть для `k` вершин мы получаем `k-1` рёбер.

# 7. Соотношения между количеством вершин, листьев и внутренних вершин в m-арном дереве
**Т.** `Full` `m`-арное дерево с `i` количеством внутренних вершин. Для него можно вычислить кол-во вершин как `n = mi + 1`. *Доказательство:* по определению, у любой внутренней вершины в `full` `m`-арном дереве будет `m` детей. Кроме того, у дерева будет корень, который надо прибавить отдельно. 

**Т.** Если нам известен один из параметров `full` `m`-арного дерева, мы можем вычислить остальные (`i` - кол-во внутренних вершин, `n` - кол-во вершин в целом, `l` - кол-во листьев):
1. Известно количество вершин `n`:
   1. Внутренние вершины $i = \frac{n - 1}{m}$
   2. Листья $l = \frac{(m - 1)n + 1}{m}$
2. Известны внутренние вершины `i`:
   1. `n = mi + 1`
   2. `l = (m - 1)i + 1`
3. Листья `l`:
   1. $n = \frac{ml - 1}{m - 1}$
   2. $i = \frac{l - 1}{m - 1}$

*Все утверждения доказываются через выведенное в прошлое теореме равенство `n = mi + 1` и очевидное `n = l + i`*

# 8. Соотношения между количеством листьев и высотой m-арного дерева
**О.** Уровень вершины в дереве - это длина пути от вершины до корня. (*Соответственно, уровень корня ` = 0`*)

**О.** Высота дерева - максимальный уровень вершин в дереве

**О.** `m`-арное корневое дерево будет **сбалансированным**, если всего его листья находятся на высоте `h` или `h - 1`

**Т.** В `m`-арное дереве высоты `h` количество листьев `l <= m^h`. *Доказательство:* индукция - в `m`-арном дереве с высотой 1 по определению будет `l = m = m^1` листьев. Будем считать, что утверждение верно для `m`-арного дерева высоты `h`. Удаляем корень дерева и получаем `<= m` поддеревьев, каждое из которых будет содержать `l <= m^(h-1)` листьев, операцию можно повторять, пока не получим `h-1 = 1`. В сумме для исходного дерева будет `l <= m * m^(h-1) = m^h`

**С.** Для `m`-арного дерева с количеством листьев `l`: $h \ge ceil(\log_m l)$. Для полного сбалансированного дерева: $h = ceil(\log_m l)$. *Доказывается напрямую из прошлой теоремы +* для сбалансированного дерева простой факт, что `m^(h-1) < l <= m^h`

# 9. Понятие остовного дерева. Теорема о существовании остовного дерева у связного графа
**О.** Остовное дерево - граф, содержащий все вершины исходного графа и являющийся при этом деревом. **Остовное дерево может быть только у связного графа.** Остовных деревьев у заданного графа может быть много.

**Т.** Простой граф будет связным тогда и только тогда, когда у него есть остовное дерево. *Доказательство:* если у графа есть остовное дерево, значит в дереве можно построить путь между любыми вершинами исходного графа, значит исходный граф связный. *В обратную сторону:* если граф связный, значит существует путь между любыми вершинами, а значит можно построить остовное дерево путём удаления рёбер из циклических путей

*Надо отметить, что алгоритм удаления рёбер хоть и позволяет найти остовное дерево для связного графа, но является неэффективным*

Эффективным алгоритмами будут breadth-first search (поиск в ширину) и depth-first search (поиск в глубину), а также алгоритм Прима и алгоритм Краскала для взвешенных неориентированных графов

# 10. Построение остовного дерева поиском в ширину. Леммы о свойствах поиска в ширину
Поиск в ширину заключается в том, что мы выбираем вершину входа (будущий корень остовного дерева), затем подсоединяем к ней все доступные вершины, маркируем их и добавляем в очередь FIFO. Пока очередь не пуста, извлекаем из неё вершину, подсоединяем к дереву её детей и добавляем их в очередь, если они ещё не были промаркированы. Повторяем алгоритм, пока не обойдём все вершины.

**Расширенная версия алгоритма:** добавляем всем вершинам такие параметры, как цвет, расстояние до корня и адрес родителя. Изначально все элементы окрашены в белый, не имеют родителя и расстояние до корня равно бесконечности. Также используем очередь по принципу `FIFO`
- Окрашиваем корневую вершину в серый и присваиваем ей дистанцию `0`. Предка нет.
- Добавляем корень в очередь
- `while queue.notEmpty`:
  - Берём из очереди вершину
  - Обходим все доступные из данной вершины
  - Если вершина белая, помечаем её серым, сохраняя родителем текущую вершину и расстояние до него ` + 1`
  - Добавляем окрашенные серым вершины в очередь
  - Когда с текущей вершиной мы полностью закончили, окрашиваем её в чёрный и берём новую вершину из очереди

Скорость алгоритма - `O(V + E)`

**О.** Кратчайшая длина пути из $s$ в $v$ обозначается как $\delta(s, v)$

**Л.** Если в графе существует путь `(u,v)`, то $\delta(s,v) \le \delta(s,u) + 1$ (*Если `u` достижима из `s`, то мы либо дойдём из `s` до `v` через `u`, либо дойдём до `v` раньше, чем до `u`*)

**Л.** [BFS](#breadth-first-search) позволяет найти все кратчайшие расстояния (**для графов без веса рёбер**) *Доказывается не столь строгое утверждение, что `v.d >= delta(s,v)`. Доказывается индукцией благодаря очереди типа `FIFO` в алгоритме и прошлой лемме.* В частности, для BFS от вершины `s` для найденной вершины `v` при обходе белых соседей вершины `u` имеем `v.d = u.d + 1 >= delta(s, u) + 1 >= delta(s, v)`, причём после фиксации `v.d` на этом шаге оно уже никогда не будет изменено

**Т.** Для заданного графа `BFS2` от данной вершины обойдёт все доступные вершины и при том вычислит для них кратчайшее расстояние. *Следует из доказанных выше лемм*

**Л.** `BFS2` за счёт записи родителей вершин даёт нам **breadth-first tree**. *Доказательство:* `v.p = u <=> u-v in E and delta(s, v) < inf` => значит `v` достижимо из вершины запуска алгоритма `s`, учитывая, что каждой вершине задаётся единственный родитель, мы получаем возможность построить уникальные пути из `s`, ко всем вершинам, то есть индуктивно заключаем, что за счёт записи родителей в `BFS2` мы получаем дерево

# 11. Построение остовного дерева поиском в глубину. Теорема о скобках. Классификация ребер ориентированного и неориентированного графа относительно дерева поиска в глубину
Добавляем корень дерева (*точку входа*) и далее запускаем рекурсивный алгоритм:
1. `while <можем от последней добавленной вершине перейти к ещё не добавленной>`
  1. Добавляем инцидентное последней добавленной вершине ребро с другой вершиной, ещё не добавленной в дерево (*если таковых несколько, берём первую по порядку в нашем представлении графа*)
2. `while <нельзя добавить новых вершин>`
   1. Движемся по добавленным вершинам от конца к началу
3. `if <не дошли до корня>`
   1. Повторяем с пункта `1`
4. `else` - **PROFIT**

Версия на псевдокоде:
```
G - connected graph with vertices v1, ..., vn
T - result tree

visit(v):
  for w that {w adjacent v and w not_in T}:
    add w and edge (v, w) to T
    visit(w)

visit(v1)
```

**Расширенная версия**: предки сохраняются у вершин также, как в BFS2, а окрашивание идёт по следующему принципу: изначально вершины белые, когда мы спускаемся по ним вниз, окрашиваем в серый, когда выходим обратно и покидаем (то есть мы не можем из этой вершины больше перейти ни в какую) - в чёрный. Кроме того, мы храним не только глубину `d`, но и момент обратного выхода `f`, причём хранят оба поля не глубину как таковую, а что-то вроде таймстэмпа. `v.d < v.f`

Псевдокод:
```
for v in G.V:
  v.color = WHITE
  v.pi = NIL

time = 0

for v in G.V:
  if v.color == WHITE:
    visit(G, v)

visit(G, v):
  time++
  v.d = time
  v.color = GRAY
  for u in G.adj[v]:
    if u.color == WHITE
      u.pi = v
      visit(G, u)
  v.color = BLACK
  time++
  v.f = time
```

**За счёт сохранения предков мы также получаем дерево, называемое *depth-first tree***. Вершины, из которых мы не смогли дальше уйти в рекурсию, будут листьями, остальные - внутренними. *На самом деле мы получаем лес, так как DFS пройдётся отдельно по всем компонентам связности*

**Т. о скобках** отрезки `[v.d, v.f]` и `[u.d, u.f]` могут находиться в следующих отношения, которые позволяют нам говорить и связи вершин в DFT:
1. Отрезки не пересекаются => вершины находятся в разных деревьях или поддеревьях (ни одна не будет потомком другой)
2. Отрезок `[u.d, u.f]` полностью включён в `[v.d, v.f]` => `u` - потомок `v`
3. Отрезок `[v.d, v.f]` полностью включён в `[u.d, u.f]` => `v` - потомок `u`

*Доказывается напрямую из описанного выше алгоритма и рассмотрение случаев, когда `v.d < u.f` и `u.f < v.d`*

DFS создаёт 4 типа рёбер:
- Древесные (tree) - простое ребро, по которому мы идём в глубину
- Прямые (forward) - ребро, ведущее из родителя в уже посещённого потомка по другому пути 
- Обратные (back) - ребро, ведущее из потомка в родителя
- Поперечные (cross) - ребро, ведущее из одного (под)дерева в другое уже посещённое

Из определения следует, что в ориентированном графе есть все виды рёбер, а в неориентированном - только tree и back, причём орграф будет ациклическим, если в нём нет back-рёбер.

# 12. Способы подсчета количества остовных деревьев
### Алгоритм стягивания ребра
Обозначим `T(G)` как кол-во деревьев графа `G`.

`G*e` граф со стянутым ребром `e`, то есть для `e = (u,v)` мы получаем новую вершину, инцидентную со всеми рёбрами, с которыми были инцедентны `u` и `v`. `V(G*e) = V(G)-1`, `E(G*e) = E(G) - 1`. **Стянутое дерево продолжает быть деревом**

**Т.** Для ребра `e = u-v`, где `u != v`: `T(G) = T(G*e) + T(G-e)`. *Доказательство:* `T(G-e)` будет содержать все деревья, в которых нет `e`, `T(G*e)` будет содержать все деревья, в которые включено ребро `e` (добавляя стянутую вершину в дерево, мы тут же добавляем в дерево стянутое ребро и обе его вершины). Отсюда мы получаем 2 непересекающихся множества деревьев, объединение которых целиком покрывает исходное `T(G)`

Из этой теоремы легко вытекает алгоритм для поиска кол-ва остовных деревьев:
- Делим граф на граф со стянутым ребром и вырезанным. 
- Количество остовных деревьев исходного графа - сумма кол-ва остовных деревьев со стянутыми вершинами и деревьев, где стянутого ребра нет.
- Рекурсивно продолжаем операцию до тех пор, пока граф не будет разложен на простые компоненты, для которых кол-во остовных деревьев считается "на глаз"

Дополнение к этому методу: если у нас в графе возникает cut-vertex, то мы можем разорвать граф по этой вершине, продублировав её в двух новых графах. Тогда кол-во остовных деревьев в исходном графе будет равно произведению кол-ва остовных в новых двух графах

### Теорема для полного графа и код Прюфера
**Формула Келли**: Кол-во остовных деревьев для `n`-дерева = `n^(n-2)`. *Доказывается через тот факт, что описно остовное дерево может быть кодом Прюфера длины `n-2`, а таких различных кодов для полного графа может быть `n` штук*

**Использование на практике:** Выбираем лист с наименьшим номером. Записываем в код Прюфера вершину, смежную с данной, затем удаляем этот лист. Повторяем до тех пор, пока не останется одно ребро (т.е. дерево не будет состоять из двух листьев).

Обладая кодом Прюфера, можно восстановить остовное дерево: в код Прюфера не входят листья, при этом выбирали мы листья с наименьшим номером, поэтому идёт прямо по коду, добавляя к вершинам из кода листья с соответствующими номерами (*номера возрастают с пропуском входящих в код вершин (когда мы добавили лист к коду, мы вычёркиваем эту запись из кода, а значит вершина, которой больше нет в коде, также добавляется в очередь на присоединение)*)

### Метод Лапласиана
Матрица Лапласа:
- `i == j => a_ij = deg v_i`
- `(i, j) in E => a_ij = -1`
- `otherwise => a_ij = 0`

То есть `L = D - A`, где `D` - матрица степеней, `A` - матрица смежности

**Т. Киргоффа о связи матриц и деревьев:** кол-во остовных деревьев в графе можно посчитать как определитель матрицы Лапласа, из которой мы удалили `i`-ю строку и столбец.

# 13. Лемма о том, в каких случаях вершина является точкой сочленения в дереве поиска в глубину