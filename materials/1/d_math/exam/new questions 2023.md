<style>
  body {
    font-size: 14pt;
  }
</style>

# 4. Матрица смежности и свойства графа
Матрица смежности (adjacency matrix) - таблица `n*n`, где (`n` - кол-во вершин в графе). `matrix[i][j] = 1 <=> (i, j) in edges`. Для мультиграфов вместо единички записывается количество рёбер.

Матрицы смежности могут использовать для подсчёта количества путей в графе.

Условные обозначения:
- `I` - единичная матрица (главная диагональ из единиц, остальное - нули)
- `J` - матрица целиком состоящая из единиц
- `A` - матрица смежности (ячейка $a_{ij}$ будет обозначаться как `A(i,j)`)

Для неорграфа `A^T = A`.

Связь степеней вершин и значений `A`:
- в неорграфе: $deg(v_i) = \sum_{j=1}^n a_{ij} = \sum_{j=1}^n a_{ji}$
- в орграфе: $deg_+(v_i) = \sum_{j=1}^n a_{ij}$ и $deg_-(v_i) = \sum_{j=1}^n a_{ji}$

**Т. о количестве путей произвольной длины через матрицу смежности**. Для любого графа G ячейка `(i, j)` матрицы смежности в степени `k` - кол-во путей из `v_i` в `v_j` длины `k`. *Доказательство:* для матрицы `A^1` утверждение очевидно - `A(i,j) = 1 =>` вершины смежны. Это база индукции. Далее будем считать, что утверждение теоремы верно для `A^k` и докажем его справедливость для `A^(k+1)`. Любой путь длины `k+1` из `v_i` в `v_j` будет содержать путь длины `k` из `v_i` в соседей `v_j` (`N(v_j)`). Будем обозначать принадлежащие этому множеству вершины как `v_p`, тогда по условию кол-во путей из `v_i` в `v_p` длины `k` будет `A^k(v,p)`. Значит для вычисления путей из `i` в `j` длины `k+1` нам надо сложить все `A^k(v,p)`, то есть получаем формулу:
$$
\sum_{v_p \in N(v_j)} A^k(i,p) = \sum_{l=1}^n A^k(i,l)A(l,j) = A^{k+1}(i,j)
$$

След матрицы (`trace`) - сумма главной диагонали матрицы смежности в степени `k`. Некоторые особенности следа:
- `tr(A) = 0` - для простого графа без петель
- Для неориентированного графа: `tr(A^2) = 2|E|`. Доказывается через банальный факт того, что мы из каждой вершины идём во всех её соседей, а затем обратно, то есть `A^2(i,i) = deg(v_i)`
- Связь с количеством треугольников `t` в графе: `6t = tr(A^3)`. Для каждой вершины мы можем пройти циклический путь двумя способами (условно выражаясь, по часовой стрелке и против), также учитывая, что в треугольнике 3 вершины, каждая из которых может быть стартовой, получаем, что ячейка `A(i, i)` показывает нам кол-во треугольников, в которые входит `v_i`, умноженное на 6 
- `q` - циклы длины 4. Тогда $tr(a^4) = 8q - 2|E| + 2 \sum_{i=1}^{|V|} \deg^2(v_i)$. Получается данная формула простыми арифметическими преобразованиями при суммировании 3 случаев циклов длины 4 для каждой вершины:
  1. Обычный квадрат. Их будет `8q` по тем же резонам, что `6t` в пункте выше (в итоговом выражении для следа, для отдельной вершины - `2q`)
  2. `v_i - x - v_i - y`, где `x, y in N(v_i)` - таких циклов будет $\deg^2(v_i)$
  3. `v_i - x - y - x`, где `x in N(v_i)` и `y != v_i & y in N(x)` - таких циклов будет $\sum_{x \in N(v_i)} (\deg(x) - 1)$
  - <img src="./8q.png" width="50%">

Графы с `n = |V| >= 2` связные `<=>` все ячейки вне главной диагонали е матрицы `B = A + A^2 + ... + A^(n-1)` > 0. Фактически, минимальная степень, в которой `A(i,j) > 0` - это минимальная длина пути `i-j`. *Доказательство:*
- Если граф связный, то между любыми вершинами `i`, `j` можно будет построить путь длины `k <= n-1` => `A^k(i,j) > 0` => `B(i,j) > 0`
- *В обратную сторону:* если для любой `B(i,j) > 0` (`i != j`) => найдётся такое минимальное `k <= n-1`, что `A^k(i,j) > 0`, значит есть простой путь из `i` в `j`. Отсюда следует, что все вершины связаны со всеми, а значит граф связный

Матрица смежности дополнения графа (`A(G')`, далее будет `A'`) - матрица, где все ячейки изначально равные нулям (не считая диагональных), равны единицам - и наоборот. Матрица смежности и матрица смежности дополнения связаны равенством `A + A' + I = J`, которое напрямую следует из определения дополнения графа как графа, при объединении с которым исходный граф даст полный граф.

Если матрица симметрична, то все собственные значения будут вещественными, а собственные вектора будут взаимноортоганальны. Напомним, что с.з. будут находиться через уравнение $\det(\lambda I - M) = 0$

**О.** Характеристический полином матрицы смежности - `p(t) = det(tI - A)`. Или, выражая полученные с.з., получаем $p(t) = (t - \lambda_1)(t - \lambda_2)...(t - \lambda_n)$

**О.** Спектр графа - набор скаляров собственных значений графа, расположенный по неубыванию. ($spec(G) = {\lambda_1, \lambda_2, ..., \lambda_n} : \lambda_1 \le \lambda_2 \le ... \le \lambda_n$)

Любое собственное значение графа не превосходит его максимальную степень. Более того, будет справедливо неравенство $\frac{2|E|}{|V|} \le \lambda_n \le \Delta(G)$

Регулярный граф - граф, в котором все степени вершин одинаковы. Граф `k`-регулярный `<=>` единичный вектор - его собственный вектор с собственными значениями `= k`. *Доказывается* в обе стороны через тот факт, что для `k`-регулярного графа `Ae = ke = {deg(v_1), deg(v_2), ..., deg(v_n)} = {k, k, ..., k}`

Спектры изоморфных графов идентичны. **Обратное не верно**

# 12. Способы подсчета количества остовных деревьев
### Алгоритм стягивания ребра
Обозначим `T(G)` как кол-во деревьев графа `G`.

`G*e` граф со стянутым ребром `e`, то есть для `e = (u,v)` мы получаем новую вершину, инцидентную со всеми рёбрами, с которыми были инцедентны `u` и `v`. `V(G*e) = V(G)-1`, `E(G*e) = E(G) - 1`. **Стянутое дерево продолжает быть деревом**

**Т.** Для ребра `e = u-v`, где `u != v`: `T(G) = T(G*e) + T(G-e)`. *Доказательство:* `T(G-e)` будет содержать все деревья, в которых нет `e`, `T(G*e)` будет содержать все деревья, в которые включено ребро `e` (добавляя стянутую вершину в дерево, мы тут же добавляем в дерево стянутое ребро и обе его вершины). Отсюда мы получаем 2 непересекающихся множества деревьев, объединение которых целиком покрывает исходное `T(G)`

Из этой теоремы легко вытекает алгоритм для поиска кол-ва остовных деревьев:
- Делим граф на граф со стянутым ребром и вырезанным. 
- Количество остовных деревьев исходного графа - сумма кол-ва остовных деревьев со стянутыми вершинами и деревьев, где стянутого ребра нет.
- Рекурсивно продолжаем операцию до тех пор, пока граф не будет разложен на простые компоненты, для которых кол-во остовных деревьев считается "на глаз"

Дополнение к этому методу: если у нас в графе возникает cut-vertex, то мы можем разорвать граф по этой вершине, продублировав её в двух новых графах. Тогда кол-во остовных деревьев в исходном графе будет равно произведению кол-ва остовных в новых двух графах

### Теорема для полного графа и код Прюфера
**Формула Келли**: Кол-во остовных деревьев для `n`-дерева = `n^(n-2)`. *Доказывается через тот факт, что описно остовное дерево может быть кодом Прюфера длины `n-2`, а таких различных кодов для полного графа может быть `n` штук*

**Использование на практике:** Выбираем лист с наименьшим номером. Записываем в код Прюфера вершину, смежную с данной, затем удаляем этот лист. Повторяем до тех пор, пока не останется одно ребро (т.е. дерево не будет состоять из двух листьев).

Обладая кодом Прюфера, можно восстановить остовное дерево: в код Прюфера не входят листья, при этом выбирали мы листья с наименьшим номером, поэтому идёт прямо по коду, добавляя к вершинам из кода листья с соответствующими номерами (*номера возрастают с пропуском входящих в код вершин (когда мы добавили лист к коду, мы вычёркиваем эту запись из кода, а значит вершина, которой больше нет в коде, также добавляется в очередь на присоединение)*)

### Метод Лапласиана
Матрица Лапласа:
- `i == j => a_ij = deg v_i`
- `(i, j) in E => a_ij = -1`
- `otherwise => a_ij = 0`

То есть `L = D - A`, где `D` - матрица степеней, `A` - матрица смежности

**Т. Киргоффа о связи матриц и деревьев:** кол-во остовных деревьев в графе можно посчитать как определитель матрицы Лапласа, из которой мы удалили `i`-ю строку и столбец.