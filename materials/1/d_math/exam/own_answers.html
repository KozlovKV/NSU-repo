<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>1&period; &Pcy;&ocy;&ncy;&yacy;&tcy;&icy;&iecy; &scy;&tcy;&iecy;&pcy;&iecy;&ncy;&icy; &vcy;&iecy;&rcy;&shcy;&icy;&ncy;&ycy; &vcy; &ocy;&rcy;&icy;&iecy;&ncy;&tcy;&icy;&rcy;&ocy;&vcy;&acy;&ncy;&ncy;&ocy;&mcy; &icy; &ncy;&iecy;&ocy;&rcy;&icy;&iecy;&ncy;&tcy;&icy;&rcy;&ocy;&vcy;&acy;&ncy;&ncy;&ocy;&mcy; &gcy;&rcy;&acy;&fcy;&iecy;&period; &Tcy;&iecy;&ocy;&rcy;&iecy;&mcy;&ycy; &ocy; &scy;&tcy;&iecy;&pcy;&iecy;&ncy;&yacy;&khcy; &vcy;&iecy;&rcy;&shcy;&icy;&ncy; &vcy; &ncy;&iecy;&ocy;&rcy;&icy;&iecy;&ncy;&tcy;&icy;&rcy;&ocy;&vcy;&acy;&ncy;&ncy;&ocy;&mcy; &icy; &ocy;&rcy;&icy;&iecy;&ncy;&tcy;&icy;&rcy;&ocy;&vcy;&acy;&ncy;&ncy;&ocy;&mcy; &gcy;&rcy;&acy;&fcy;&iecy;</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <style>
  body {
    font-size: 14pt;
  }
</style>
<title>Козлов Кирилл ( https://github.com/KozlovKV/NSU-repo/blob/master/materials/1/d_math/exam/own_answers.md )</title>
<h3 id="1-понятие-степени-вершины-в-ориентированном-и-неориентированном-графе-теоремы-о-степенях-вершин-в-неориентированном-и-ориентированном-графе">1. Понятие степени вершины в ориентированном и неориентированном графе. Теоремы о степенях вершин в неориентированном и ориентированном графе</h3>
<p>Степень вершины графа в неориентированном графе — количество ребер графа, инцидентных вершине. При подсчете степени ребро-петля учитывается дважды. Степень обозначается deg(v). Вершина степени 0 – изолированная. Отсюда следует, что изолированная вершина не смежна с какой-либо вершиной. Вершина степени 1 –  висячая. Следовательно, висячая вершина смежна ровно с одной другой вершиной.</p>
<p><strong>Теорема о рукопожатиях</strong>. Пусть G = (V, E) - неориентированный граф с m ребрами.
Тогда <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>m</mi><mo>=</mo><mo>∑</mo><mi>deg</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">2m=\sum \deg(v), v∈V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></p>
<p><strong>Теорема о вершинах с нечётной степенью в неориентированном графе</strong>:
Неориентированный граф имеет четное число вершин нечетной степени.
Доказательство:
Пусть V1 - множество вершин четной степени, а V2 - множество вершин нечетной
степени в неориентированном графе G = (V, E) с m ребрами.</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><mi>m</mi><mo>=</mo><munder><mo>∑</mo><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow></munder><mi>deg</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>v</mi><mo>∈</mo><mi>V</mi><mn>1</mn></mrow></munder><mi>deg</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><munder><mo>∑</mo><mrow><mi>v</mi><mo>∈</mo><mi>V</mi><mn>2</mn></mrow></munder><mi>deg</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2m = \sum_{v \in V} \deg(v) = \sum_{v \in V1} \deg(v) + \sum_{v \in V2} \deg(v)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3717em;vertical-align:-1.3217em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3717em;vertical-align:-1.3217em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.3717em;vertical-align:-1.3217em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span></p>
<p>Тогда:
Поскольку deg(v) четно для v ∈ V1, первое слагаемое в правой части последнего
равенства четное.
Кроме того, сумма двух слагаемых в правой части последнего равенства четна, потому
что эта сумма равна 2m.
Следовательно, второе слагаемое в сумме также является четным.
Поскольку все слагаемые в этой сумме нечетны, таких слагаемых должно быть четное
число.
Таким образом, существует четное количество вершин нечетной степени.</p>
<p>В ориентированном графе полустепень захода v, обозначаемая <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>deg</mi><mo>⁡</mo></mrow><mo>−</mo></msub><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\deg_-(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0525em;vertical-align:-0.3025em;"></span><span class="mop"><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1642em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3025em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>, представляет собой число ребер с v в качестве их конечной вершины. Полустепень исхода v, обозначаемая <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>deg</mi><mo>⁡</mo></mrow><mo>+</mo></msub><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\deg_+(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0525em;vertical-align:-0.3025em;"></span><span class="mop"><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1642em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3025em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>, представляет собой число ребер с v в качестве начальной вершины. (Обратите внимание, что ребро-петля в вершине вносит 1 как в полустепень захода, так и в полустепень исхода этой вершины).</p>
<p><strong>Теорема о степенях входа и выхода</strong>. В ориентированном графе с m рёбрами:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo>=</mo><munder><mo>∑</mo><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow></munder><msub><mrow><mi>deg</mi><mo>⁡</mo></mrow><mo>−</mo></msub><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow></munder><msub><mrow><mi>deg</mi><mo>⁡</mo></mrow><mo>+</mo></msub><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m = \sum_{v \in V} \deg_-(v) = \sum_{v \in V} \deg_+(v)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3717em;vertical-align:-1.3217em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1642em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3025em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3717em;vertical-align:-1.3217em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1642em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3025em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span></p>
<p>Доказывается из определения степеней вершин для орграфа. В частности, того факта, что каждое ребро будет для одной вершины давать +1 к <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>deg</mi><mo>⁡</mo></mrow><mo>−</mo></msub></mrow><annotation encoding="application/x-tex">\deg_-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9969em;vertical-align:-0.3025em;"></span><span class="mop"><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1642em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3025em;"><span></span></span></span></span></span></span></span></span></span>, а для другой - +1 к <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>deg</mi><mo>⁡</mo></mrow><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">\deg_+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9969em;vertical-align:-0.3025em;"></span><span class="mop"><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1642em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3025em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>Основание - неориентированный граф, полученный при игнорировании направления рёбер в орграфе. Имеет такое же количество рёбер и используется потому, что для многих свойств графа направление рёбер не играет роли.</p>
<h3 id="2-понятие-изоморфизма-способы-установления-наличия-или-отсутствия-изоморфизма">2. Понятие изоморфизма. Способы установления наличия или отсутствия изоморфизма</h3>
<p>2 простых графа <code>G1 = (V1, E1)</code> и <code>G2 = (V2, E2)</code> - изоморфны, если существует биекция <code>f</code>, сохраняющая отношение смежности для вершин и рёбер графов: для любых <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi>V</mi><mn>1</mn><mo>:</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi><mn>1</mn><mo>⇔</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\forall a, b \in V1 : (a,b) \in E1 \hArr (f(a),f(b)) \in E2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">2</span></span></span></span>. Отношение изоморфизма для простых графов будет отношением эквивалентности</p>
<p>Из определения мы получаем следующие обязательные условия для изоморфизма (их также называют инвариантами графов):</p>
<ol>
<li>Одинаковое кол-во вершин</li>
<li>Одинаковое кол-во рёбер</li>
<li>Количество вершин с определёнными степенями одинаково</li>
</ol>
<p>Выше приведены <strong>необходимые, но недостаточные</strong> условия изоморфизма.</p>
<p>Если для двух графов можно построить идентичные (после перестановок столбцов и/или строк) матрицы смежности, значит между ними существует изоморфизм. Другие алгоритмы для точного установления изоморфизма являются NP-полными.</p>
<h3 id="3-понятие-пути-цикла-простого-пути-и-простого-цикла-теорема-о-существовании-простого-пути-между-парой-различных-вершин-связного-неориентированного-графа">3. Понятие пути, цикла, простого пути и простого цикла. Теорема о существовании простого пути между парой различных вершин связного неориентированного графа</h3>
<p><strong>О.</strong> Путь - последовательность рёбер, первое из которых содержит начальную вершину, а последнее - конечную вершину. Для орграфа, что очевидно, мы должны указывать рёбра строго в порядке следования от начала пути к концу.</p>
<p>Также можно расширить путь до маршрута - перед и после ребра указывать в последовательности вершины. Если граф простой, путь можно указывать просто как последовательность вершин.</p>
<p><strong>О.</strong> Цикл (circuit) - путь ненулевой длины, начинающийся и заканчивающийся в одной и той же вершине</p>
<p><strong>О.</strong> Простой путь/цикл не содержит одних и тех же рёбер более одного раза.</p>
<p><strong>О.</strong> Граф называется связным (connected), если существует путь между двумя любыми его вершинами.</p>
<p><strong>Т. о существовании простого пути между парой различных вершин связного неориентированного графа</strong>. Для связного неориентированного графа между двумя любыми вершинами существует простой путь. <em>Доказательство:</em> Из связности графа следует существование пути. Возьмём путь из <code>u</code> в <code>v</code> минимальной длины. Такой путь будет простым. Предположим обратное: тогда среди вершин <code>{x_1, ..., x_n}</code> найдутся такие <code>x_i</code>, <code>x_j</code>, что <code>x_i = x_j</code> (<code>0 &lt;= i &lt; j</code>), а это значит, что путь <code>u-v</code> останется путём из <code>u</code> в <code>v</code>, если из него убрать вершины <code>{x_i, ..., x_j-1}</code>, но уже меньшей длины, однако по условию минимальности длины это невозможно, из чего и следует простота исходно взятого пути.</p>
<p>Максимальный связный подграф - <em>пояснения излишни</em>, Связные подграфы называются компонентами связности.</p>
<p>Если в одном графе есть путь длины <code>n</code>, а в другом точно нет пути такой же длины =&gt; графы точно не изоморфны.</p>
<h3 id="4-матрица-смежности-и-свойства-графа">4. Матрица смежности и свойства графа</h3>
<p>Матрица смежности (adjacency matrix) - таблица <code>n*n</code>, где (<code>n</code> - кол-во вершин в графе). <code>matrix[i][j] = 1 &lt;=&gt; (i, j) in edges</code>. Для мультиграфов вместо единички записывается количество рёбер.</p>
<p>Матрицы смежности могут использовать для подсчёта количества путей в графе.</p>
<p>Условные обозначения:</p>
<ul>
<li><code>I</code> - единичная матрица (главная диагональ из единиц, остальное - нули)</li>
<li><code>J</code> - матрица целиком состоящая из единиц</li>
<li><code>A</code> - матрица смежности (ячейка <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> будет обозначаться как <code>A(i,j)</code>)</li>
</ul>
<p>Для неорграфа <code>A^T = A</code>.</p>
<p>Связь степеней вершин и значений <code>A</code>:</p>
<ul>
<li>в неорграфе: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>g</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">deg(v_i) = \sum_{j=1}^n a_{ij} = \sum_{j=1}^n a_{ji}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2401em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2401em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ji</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>в орграфе: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><msub><mi>g</mi><mo>+</mo></msub><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">deg_+(v_i) = \sum_{j=1}^n a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2401em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> и <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><msub><mi>g</mi><mo>−</mo></msub><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">deg_-(v_i) = \sum_{j=1}^n a_{ji}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2401em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ji</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p><strong>Т. о количестве путей произвольной длины через матрицу смежности</strong>. Для любого графа G ячейка <code>(i, j)</code> матрицы смежности в степени <code>k</code> - кол-во путей из <code>v_i</code> в <code>v_j</code> длины <code>k</code>. <em>Доказательство:</em> для матрицы <code>A^1</code> утверждение очевидно - <code>A(i,j) = 1 =&gt;</code> вершины смежны. Это база индукции. Далее будем считать, что утверждение теоремы верно для <code>A^k</code> и докажем его справедливость для <code>A^(k+1)</code>. Любой путь длины <code>k+1</code> из <code>v_i</code> в <code>v_j</code> будет содержать путь длины <code>k</code> из <code>v_i</code> в соседей <code>v_j</code> (<code>N(v_j)</code>). Будем обозначать принадлежащие этому множеству вершины как <code>v_p</code>, тогда по условию кол-во путей из <code>v_i</code> в <code>v_p</code> длины <code>k</code> будет <code>A^k(v,p)</code>. Значит для вычисления путей из <code>i</code> в <code>j</code> длины <code>k+1</code> нам надо сложить все <code>A^k(v,p)</code>, то есть получаем формулу:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo>∑</mo><mrow><msub><mi>v</mi><mi>p</mi></msub><mo>∈</mo><mi>N</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></munder><msup><mi>A</mi><mi>k</mi></msup><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mi>A</mi><mi>k</mi></msup><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>l</mi><mo stretchy="false">)</mo><mi>A</mi><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>A</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{v_p \in N(v_j)} A^k(i,p) = \sum_{l=1}^n A^k(i,l)A(l,j) = A^{k+1}(i,j)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5883em;vertical-align:-1.5383em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.809em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5383em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9535em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1491em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></span></p>
<p>След матрицы (<code>trace</code>) - сумма главной диагонали матрицы смежности в степени <code>k</code>. Некоторые особенности следа:</p>
<ul>
<li><code>tr(A) = 0</code> - для простого графа без петель</li>
<li>Для неориентированного графа: <code>tr(A^2) = 2|E|</code>. Доказывается через банальный факт того, что мы из каждой вершины идём во всех её соседей, а затем обратно, то есть <code>A^2(i,i) = deg(v_i)</code></li>
<li>Связь с количеством треугольников <code>t</code> в графе: <code>6t = tr(A^3)</code>. Для каждой вершины мы можем пройти циклический путь двумя способами (условно выражаясь, по часовой стрелке и против), также учитывая, что в треугольнике 3 вершины, каждая из которых может быть стартовой, получаем, что ячейка <code>A(i, i)</code> показывает нам кол-во треугольников, в которые входит <code>v_i</code>, умноженное на 6</li>
<li><code>q</code> - циклы длины 4. Тогда <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mo stretchy="false">(</mo><msup><mi>a</mi><mn>4</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mn>8</mn><mi>q</mi><mo>−</mo><mn>2</mn><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mn>2</mn><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msup><mrow><mi>deg</mi><mo>⁡</mo></mrow><mn>2</mn></msup><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">tr(a^4) = 8q - 2|E| + 2 \sum_{i=1}^{|V|} \deg^2(v_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">8</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.3276em;vertical-align:-0.2997em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0279em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984em;"><span style="top:-3.1473em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. Получается данная формула простыми арифметическими преобразованиями при суммировании 3 случаев циклов длины 4 для каждой вершины:
<ol>
<li>Обычный квадрат. Их будет <code>8q</code> по тем же резонам, что <code>6t</code> в пункте выше (в итоговом выражении для следа, для отдельной вершины - <code>2q</code>)</li>
<li><code>v_i - x - v_i - y</code>, где <code>x, y in N(v_i)</code> - таких циклов будет <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>deg</mi><mo>⁡</mo></mrow><mn>2</mn></msup><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\deg^2(v_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1484em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984em;"><span style="top:-3.1473em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li><code>v_i - x - y - x</code>, где <code>x in N(v_i)</code> и <code>y != v_i &amp; y in N(x)</code> - таких циклов будет <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi>N</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>deg</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{x \in N(v_i)} (\deg(x) - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2247em;vertical-align:-0.4747em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2253em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4747em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ol>
<ul>
<li>
<img src="file:///c:\Users\bakug\YandexDisk\NSU\NSU-repo\materials\1\d_math\exam\8q.png" width="50%">
</li>
</ul>
</li>
</ul>
<p>Графы с <code>n = |V| &gt;= 2</code> связные <code>&lt;=&gt;</code> все ячейки вне главной диагонали е матрицы <code>B = A + A^2 + ... + A^(n-1)</code> &gt; 0. Фактически, минимальная степень, в которой <code>A(i,j) &gt; 0</code> - это минимальная длина пути <code>i-j</code>. <em>Доказательство:</em></p>
<ul>
<li>Если граф связный, то между любыми вершинами <code>i</code>, <code>j</code> можно будет построить путь длины <code>k &lt;= n-1</code> =&gt; <code>A^k(i,j) &gt; 0</code> =&gt; <code>B(i,j) &gt; 0</code></li>
<li><em>В обратную сторону:</em> если для любой <code>B(i,j) &gt; 0</code> (<code>i != j</code>) =&gt; найдётся такое минимальное <code>k &lt;= n-1</code>, что <code>A^k(i,j) &gt; 0</code>, значит есть простой путь из <code>i</code> в <code>j</code>. Отсюда следует, что все вершины связаны со всеми, а значит граф связный</li>
</ul>
<p>Матрица смежности дополнения графа (<code>A(G')</code>, далее будет <code>A'</code>) - матрица, где все ячейки изначально равные нулям (не считая диагональных), равны единицам - и наоборот. Матрица смежности и матрица смежности дополнения связаны равенством <code>A + A' + I = J</code>, которое напрямую следует из определения дополнения графа как графа, при объединении с которым исходный граф даст полный граф.</p>
<p>Если матрица симметрична, то все собственные значения будут вещественными, а собственные вектора будут взаимноортоганальны. Напомним, что с.з. будут находиться через уравнение <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>det</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>I</mi><mo>−</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\det(\lambda I - M) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">det</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p>
<p><strong>О.</strong> Характеристический полином матрицы смежности - <code>p(t) = det(tI - A)</code>. Или, выражая полученные с.з., получаем <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><msub><mi>λ</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><msub><mi>λ</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><msub><mi>λ</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(t) = (t - \lambda_1)(t - \lambda_2)...(t - \lambda_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">...</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p><strong>О.</strong> Спектр графа - набор скаляров собственных значений графа, расположенный по неубыванию. (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><msub><mi>λ</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>λ</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>λ</mi><mi>n</mi></msub></mrow><mo>:</mo><msub><mi>λ</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>λ</mi><mn>2</mn></msub><mo>≤</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>≤</mo><msub><mi>λ</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">spec(G) = {\lambda_1, \lambda_2, ..., \lambda_n} : \lambda_1 \le \lambda_2 \le ... \le \lambda_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ec</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</p>
<p>Любое собственное значение графа не превосходит его максимальную степень. Более того, будет справедливо неравенство <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>2</mn><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo>≤</mo><msub><mi>λ</mi><mi>n</mi></msub><mo>≤</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{2|E|}{|V|} \le \lambda_n \le \Delta(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2∣</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Δ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span></p>
<p>Регулярный граф - граф, в котором все степени вершин одинаковы. Граф <code>k</code>-регулярный <code>&lt;=&gt;</code> единичный вектор - его собственный вектор с собственными значениями <code>= k</code>. <em>Доказывается</em> в обе стороны через тот факт, что для <code>k</code>-регулярного графа <code>Ae = ke = {deg(v_1), deg(v_2), ..., deg(v_n)} = {k, k, ..., k}</code></p>
<p>Спектры изоморфных графов идентичны. <strong>Обратное не верно</strong></p>
<h3 id="5-понятие-дерева-теорема-о-единственности-пути-в-дереве">5. Понятие дерева. Теорема о единственности пути в дереве</h3>
<p><strong>О.</strong> Деревья - это связные ненаправленные ациклические простые графы</p>
<p><strong>О.</strong> Лес - несколько несвязных деревьев</p>
<p><strong>Т.</strong> Неорграф - дерево <code>&lt;=&gt;</code> между любыми двумя его вершинами существует единственный путь. <em>Доказательство:</em> предположим обратное, то есть что в дереве есть 2 пути из <code>x</code> в <code>y</code>, тогда объединение этих путей даст нам цикл, что противоречит определению дерева. <em>В обратную сторону:</em> если между любыми вершинами существует единственный простой путь, значит во-первых, граф связный, во-вторых, в нём нет циклов, отсюда следует, что граф - дерево.</p>
<h3 id="6-понятие-корневого-дерева-свойства-корневого-дерева">6. Понятие корневого дерева. Свойства корневого дерева</h3>
<p><strong>О.</strong> Корень - произвольная выбранная в дереве вершина, от которой мы направляем рёбра ко всем другим вершинам (то есть получаем из дерева ориентированный граф) и получаем <strong>корневое дерево</strong>. Корень в дереве может быть только один (поэтому стрелки у рёбер часто не указываются). Любая из вершин дерева может быть выбрана как корень, относительно которого мы сориентируем всё дерево.</p>
<p>Если в дереве для вершины <code>v</code>, не являющейся корнем, существует ребро <code>u-v</code>, то <code>u</code> - <strong>отец</strong> вершины <code>v</code>. <strong>Отец уникален</strong>. <code>v</code> будет <strong>сыном</strong> <code>u</code>. <strong>Сыновей может быть много</strong></p>
<p>Несколько сыновей одного и того же отца будут называться <strong>братьями (siblings)</strong>.</p>
<p>Все вершины на пути от корня до <code>v</code> (не включая <code>v</code>) - <strong>предки <code>v</code></strong>. Все вершины, для которых <code>v</code> является предком - <strong>потомки <code>v</code></strong></p>
<p><strong>Лист</strong> - вершина, не имеющая детей. В ином случае вершина называется <strong>внутренней</strong></p>
<p><strong>Поддерево <code>v</code></strong> - часть исходного дерева, включая вершину <code>v</code> и её потомков</p>
<p><strong>О.</strong> Корневое дерево называется <code>m</code>-арным дерево, если каждый из его внутренних элементов имеет <code>&lt;= m</code> потомков</p>
<p><strong>О.</strong> Если у каждой внутренней вершины ровно <code>m</code> потомков, то это дерево называется полным (<code>full</code>) <code>m</code>-арным деревом</p>
<p><strong>О.</strong> Уровень вершины в дереве - это длина пути от вершины до корня. (<em>Соответственно, уровень корня <code> = 0</code></em>)</p>
<p><strong>О.</strong> Высота дерева - максимальный уровень вершин в дереве</p>
<p><strong>О.</strong> <code>m</code>-арное корневое дерево будет <strong>сбалансированным</strong>, если всего его листья находятся на высоте <code>h</code> или <code>h - 1</code></p>
<p><strong>О.</strong> Заполненное (<code>complete</code>) <code>m</code>-арное дерево - подмножество полных деревьев, где до максимальной глубины существуют все вершины.</p>
<p><strong>Т.</strong> В каждом дереве с <code>n</code> вершинами ровно <code>n-1</code> рёбер. <em>Доказательство:</em> по индукции - для дерева с <code>n = 1</code> утверждение верно. Для дерева из <code>k+1</code> и <code>k</code> вершин мы откидываем один лист, при этом теряется и одно ребро, то есть для <code>k</code> вершин мы получаем <code>k-1</code> рёбер.</p>
<h3 id="7-соотношения-между-количеством-вершин-листьев-и-внутренних-вершин-в-m-арном-дереве">7. Соотношения между количеством вершин, листьев и внутренних вершин в m-арном дереве</h3>
<p><strong>Т.</strong> <code>Full</code> <code>m</code>-арное дерево с <code>i</code> количеством внутренних вершин. Для него можно вычислить кол-во вершин как <code>n = mi + 1</code>. <em>Доказательство:</em> по определению, у любой внутренней вершины в <code>full</code> <code>m</code>-арном дереве будет <code>m</code> детей. Кроме того, у дерева будет корень, который надо прибавить отдельно.</p>
<p><strong>Т.</strong> Если нам известен один из параметров <code>full</code> <code>m</code>-арного дерева, мы можем вычислить остальные (<code>i</code> - кол-во внутренних вершин, <code>n</code> - кол-во вершин в целом, <code>l</code> - кол-во листьев):</p>
<ol>
<li>Известно количество вершин <code>n</code>:
<ol>
<li>Внутренние вершины <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mi>m</mi></mfrac></mrow><annotation encoding="application/x-tex">i = \frac{n - 1}{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>Листья <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>m</mi></mfrac></mrow><annotation encoding="application/x-tex">l = \frac{(m - 1)n + 1}{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ol>
</li>
<li>Известны внутренние вершины <code>i</code>:
<ol>
<li><code>n = mi + 1</code></li>
<li><code>l = (m - 1)i + 1</code></li>
</ol>
</li>
<li>Листья <code>l</code>:
<ol>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mfrac><mrow><mi>m</mi><mi>l</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">n = \frac{ml - 1}{m - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2834em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">i = \frac{l - 1}{m - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2834em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ol>
</li>
</ol>
<p><em>Все утверждения доказываются через выведенное в прошлое теореме равенство <code>n = mi + 1</code> и очевидное <code>n = l + i</code></em></p>
<h3 id="8-соотношения-между-количеством-листьев-и-высотой-m-арного-дерева">8. Соотношения между количеством листьев и высотой m-арного дерева</h3>
<p><strong>О.</strong> Уровень вершины в дереве - это длина пути от вершины до корня. (<em>Соответственно, уровень корня <code> = 0</code></em>)</p>
<p><strong>О.</strong> Высота дерева - максимальный уровень вершин в дереве</p>
<p><strong>О.</strong> <code>m</code>-арное корневое дерево будет <strong>сбалансированным</strong>, если всего его листья находятся на высоте <code>h</code> или <code>h - 1</code></p>
<p><strong>Т.</strong> В <code>m</code>-арное дереве высоты <code>h</code> количество листьев <code>l &lt;= m^h</code>. <em>Доказательство:</em> индукция - в <code>m</code>-арном дереве с высотой 1 по определению будет <code>l = m = m^1</code> листьев. Будем считать, что утверждение верно для <code>m</code>-арного дерева высоты <code>h</code>. Удаляем корень дерева и получаем <code>&lt;= m</code> поддеревьев, каждое из которых будет содержать <code>l &lt;= m^(h-1)</code> листьев, операцию можно повторять, пока не получим <code>h-1 = 1</code>. В сумме для исходного дерева будет <code>l &lt;= m * m^(h-1) = m^h</code></p>
<p><strong>С.</strong> Для <code>m</code>-арного дерева с количеством листьев <code>l</code>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>≥</mo><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>m</mi></msub><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h \ge ceil(\log_m l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ce</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0573em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span>. Для полного сбалансированного дерева: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>m</mi></msub><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h = ceil(\log_m l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ce</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0573em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span>. <em>Доказывается напрямую из прошлой теоремы +</em> для сбалансированного дерева простой факт, что <code>m^(h-1) &lt; l &lt;= m^h</code></p>
<h3 id="9-понятие-остовного-дерева-теорема-о-существовании-остовного-дерева-у-связного-графа">9. Понятие остовного дерева. Теорема о существовании остовного дерева у связного графа</h3>
<p><strong>О.</strong> Остовное дерево - граф, содержащий все вершины исходного графа и являющийся при этом деревом. <strong>Остовное дерево может быть только у связного графа.</strong> Остовных деревьев у заданного графа может быть много.</p>
<p><strong>Т.</strong> Простой граф будет связным тогда и только тогда, когда у него есть остовное дерево. <em>Доказательство:</em> если у графа есть остовное дерево, значит в дереве можно построить путь между любыми вершинами исходного графа, значит исходный граф связный. <em>В обратную сторону:</em> если граф связный, значит существует путь между любыми вершинами, а значит можно построить остовное дерево путём удаления рёбер из циклических путей</p>
<p><em>Надо отметить, что алгоритм удаления рёбер хоть и позволяет найти остовное дерево для связного графа, но является неэффективным</em></p>
<p>Эффективным алгоритмами будут breadth-first search (поиск в ширину) и depth-first search (поиск в глубину), а также алгоритм Прима и алгоритм Краскала для взвешенных неориентированных графов</p>
<h3 id="10-построение-остовного-дерева-поиском-в-ширину-леммы-о-свойствах-поиска-в-ширину">10. Построение остовного дерева поиском в ширину. Леммы о свойствах поиска в ширину</h3>
<p>Поиск в ширину заключается в том, что мы выбираем вершину входа (будущий корень остовного дерева), затем подсоединяем к ней все доступные вершины, маркируем их и добавляем в очередь FIFO. Пока очередь не пуста, извлекаем из неё вершину, подсоединяем к дереву её детей и добавляем их в очередь, если они ещё не были промаркированы. Повторяем алгоритм, пока не обойдём все вершины.</p>
<p><strong>Расширенная версия алгоритма:</strong> добавляем всем вершинам такие параметры, как цвет, расстояние до корня и адрес родителя. Изначально все элементы окрашены в белый, не имеют родителя и расстояние до корня равно бесконечности. Также используем очередь по принципу <code>FIFO</code></p>
<ul>
<li>Окрашиваем корневую вершину в серый и присваиваем ей дистанцию <code>0</code>. Предка нет.</li>
<li>Добавляем корень в очередь</li>
<li><code>while queue.notEmpty</code>:
<ul>
<li>Берём из очереди вершину</li>
<li>Обходим все доступные из данной вершины</li>
<li>Если вершина белая, помечаем её серым, сохраняя родителем текущую вершину и расстояние до него <code> + 1</code></li>
<li>Добавляем окрашенные серым вершины в очередь</li>
<li>Когда с текущей вершиной мы полностью закончили, окрашиваем её в чёрный и берём новую вершину из очереди</li>
</ul>
</li>
</ul>
<p>Скорость алгоритма - <code>O(V + E)</code></p>
<p><strong>О.</strong> Кратчайшая длина пути из <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> в <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> обозначается как <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta(s, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></p>
<p><strong>Л.</strong> Если в графе существует путь <code>(u,v)</code>, то <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\delta(s,v) \le \delta(s,u) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> (<em>Если <code>u</code> достижима из <code>s</code>, то мы либо дойдём из <code>s</code> до <code>v</code> через <code>u</code>, либо дойдём до <code>v</code> раньше, чем до <code>u</code></em>)</p>
<p><strong>Л.</strong> <a href="#breadth-first-search">BFS</a> позволяет найти все кратчайшие расстояния (<strong>для графов без веса рёбер</strong>) <em>Доказывается не столь строгое утверждение, что <code>v.d &gt;= delta(s,v)</code>. Доказывается индукцией благодаря очереди типа <code>FIFO</code> в алгоритме и прошлой лемме.</em> В частности, для BFS от вершины <code>s</code> для найденной вершины <code>v</code> при обходе белых соседей вершины <code>u</code> имеем <code>v.d = u.d + 1 &gt;= delta(s, u) + 1 &gt;= delta(s, v)</code>, причём после фиксации <code>v.d</code> на этом шаге оно уже никогда не будет изменено</p>
<p><strong>Т.</strong> Для заданного графа <code>BFS2</code> от данной вершины обойдёт все доступные вершины и при том вычислит для них кратчайшее расстояние. <em>Следует из доказанных выше лемм</em></p>
<p><strong>Л.</strong> <code>BFS2</code> за счёт записи родителей вершин даёт нам <strong>breadth-first tree</strong>. <em>Доказательство:</em> <code>v.p = u &lt;=&gt; u-v in E and delta(s, v) &lt; inf</code> =&gt; значит <code>v</code> достижимо из вершины запуска алгоритма <code>s</code>, учитывая, что каждой вершине задаётся единственный родитель, мы получаем возможность построить уникальные пути из <code>s</code>, ко всем вершинам, то есть индуктивно заключаем, что за счёт записи родителей в <code>BFS2</code> мы получаем дерево</p>
<h3 id="11-построение-остовного-дерева-поиском-в-глубину-теорема-о-скобках-классификация-ребер-ориентированного-и-неориентированного-графа-относительно-дерева-поиска-в-глубину">11. Построение остовного дерева поиском в глубину. Теорема о скобках. Классификация ребер ориентированного и неориентированного графа относительно дерева поиска в глубину</h3>
<p>Добавляем корень дерева (<em>точку входа</em>) и далее запускаем рекурсивный алгоритм:</p>
<ol>
<li><code>while &lt;можем от последней добавленной вершине перейти к ещё не добавленной&gt;</code></li>
<li>Добавляем инцидентное последней добавленной вершине ребро с другой вершиной, ещё не добавленной в дерево (<em>если таковых несколько, берём первую по порядку в нашем представлении графа</em>)</li>
<li><code>while &lt;нельзя добавить новых вершин&gt;</code>
<ol>
<li>Движемся по добавленным вершинам от конца к началу</li>
</ol>
</li>
<li><code>if &lt;не дошли до корня&gt;</code>
<ol>
<li>Повторяем с пункта <code>1</code></li>
</ol>
</li>
<li><code>else</code> - <strong>PROFIT</strong></li>
</ol>
<p>Версия на псевдокоде:</p>
<pre><code>G - connected graph with vertices v1, ..., vn
T - result tree

visit(v):
  for w that {w adjacent v and w not_in T}:
    add w and edge (v, w) to T
    visit(w)

visit(v1)
</code></pre>
<p><strong>Расширенная версия</strong>: предки сохраняются у вершин также, как в BFS2, а окрашивание идёт по следующему принципу: изначально вершины белые, когда мы спускаемся по ним вниз, окрашиваем в серый, когда выходим обратно и покидаем (то есть мы не можем из этой вершины больше перейти ни в какую) - в чёрный. Кроме того, мы храним не только глубину <code>d</code>, но и момент обратного выхода <code>f</code>, причём хранят оба поля не глубину как таковую, а что-то вроде таймстэмпа. <code>v.d &lt; v.f</code></p>
<p>Псевдокод:</p>
<pre><code>for v in G.V:
  v.color = WHITE
  v.pi = NIL

time = 0

for v in G.V:
  if v.color == WHITE:
    visit(G, v)

visit(G, v):
  time++
  v.d = time
  v.color = GRAY
  for u in G.adj[v]:
    if u.color == WHITE
      u.pi = v
      visit(G, u)
  v.color = BLACK
  time++
  v.f = time
</code></pre>
<p><strong>За счёт сохранения предков мы также получаем дерево, называемое <em>depth-first tree</em></strong>. Вершины, из которых мы не смогли дальше уйти в рекурсию, будут листьями, остальные - внутренними. <em>На самом деле мы получаем лес, так как DFS пройдётся отдельно по всем компонентам связности</em></p>
<p><strong>Т. о скобках</strong> отрезки <code>[v.d, v.f]</code> и <code>[u.d, u.f]</code> могут находиться в следующих отношения, которые позволяют нам говорить и связи вершин в DFT:</p>
<ol>
<li>Отрезки не пересекаются =&gt; вершины находятся в разных деревьях или поддеревьях (ни одна не будет потомком другой)</li>
<li>Отрезок <code>[u.d, u.f]</code> полностью включён в <code>[v.d, v.f]</code> =&gt; <code>u</code> - потомок <code>v</code></li>
<li>Отрезок <code>[v.d, v.f]</code> полностью включён в <code>[u.d, u.f]</code> =&gt; <code>v</code> - потомок <code>u</code></li>
</ol>
<p><em>Доказывается напрямую из описанного выше алгоритма и рассмотрение случаев, когда <code>v.d &lt; u.f</code> и <code>u.f &lt; v.d</code></em></p>
<p>DFS создаёт 4 типа рёбер:</p>
<ul>
<li>Древесные (tree) - простое ребро, по которому мы идём в глубину</li>
<li>Прямые (forward) - ребро, ведущее из родителя в уже посещённого потомка по другому пути</li>
<li>Обратные (back) - ребро, ведущее из потомка в родителя</li>
<li>Поперечные (cross) - ребро, ведущее из одного (под)дерева в другое уже посещённое</li>
</ul>
<p>Из определения следует, что в ориентированном графе есть все виды рёбер, а в неориентированном - только tree и back, причём орграф будет ациклическим, если в нём нет back-рёбер.</p>
<h3 id="12-способы-подсчета-количества-остовных-деревьев">12. Способы подсчета количества остовных деревьев</h3>
<h5 id="алгоритм-стягивания-ребра">Алгоритм стягивания ребра</h5>
<p>Обозначим <code>T(G)</code> как кол-во деревьев графа <code>G</code>.</p>
<p><code>G*e</code> граф со стянутым ребром <code>e</code>, то есть для <code>e = (u,v)</code> мы получаем новую вершину, инцидентную со всеми рёбрами, с которыми были инцедентны <code>u</code> и <code>v</code>. <code>V(G*e) = V(G)-1</code>, <code>E(G*e) = E(G) - 1</code>. <strong>Стянутое дерево продолжает быть деревом</strong></p>
<p><strong>Т.</strong> Для ребра <code>e = u-v</code>, где <code>u != v</code>: <code>T(G) = T(G*e) + T(G-e)</code>. <em>Доказательство:</em> <code>T(G-e)</code> будет содержать все деревья, в которых нет <code>e</code>, <code>T(G*e)</code> будет содержать все деревья, в которые включено ребро <code>e</code> (добавляя стянутую вершину в дерево, мы тут же добавляем в дерево стянутое ребро и обе его вершины). Отсюда мы получаем 2 непересекающихся множества деревьев, объединение которых целиком покрывает исходное <code>T(G)</code></p>
<p>Из этой теоремы легко вытекает алгоритм для поиска кол-ва остовных деревьев:</p>
<ul>
<li>Делим граф на граф со стянутым ребром и вырезанным.</li>
<li>Количество остовных деревьев исходного графа - сумма кол-ва остовных деревьев со стянутыми вершинами и деревьев, где стянутого ребра нет.</li>
<li>Рекурсивно продолжаем операцию до тех пор, пока граф не будет разложен на простые компоненты, для которых кол-во остовных деревьев считается &quot;на глаз&quot;</li>
</ul>
<p>Дополнение к этому методу: если у нас в графе возникает cut-vertex, то мы можем разорвать граф по этой вершине, продублировав её в двух новых графах. Тогда кол-во остовных деревьев в исходном графе будет равно произведению кол-ва остовных в новых двух графах</p>
<h5 id="теорема-для-полного-графа-и-код-прюфера">Теорема для полного графа и код Прюфера</h5>
<p><strong>Формула Келли</strong>: Кол-во остовных деревьев для <code>n</code>-дерева = <code>n^(n-2)</code>. <em>Доказывается через тот факт, что описно остовное дерево может быть кодом Прюфера длины <code>n-2</code>, а таких различных кодов для полного графа может быть <code>n</code> штук</em></p>
<p><strong>Использование на практике:</strong> Выбираем лист с наименьшим номером. Записываем в код Прюфера вершину, смежную с данной, затем удаляем этот лист. Повторяем до тех пор, пока не останется одно ребро (т.е. дерево не будет состоять из двух листьев).</p>
<p>Обладая кодом Прюфера, можно восстановить остовное дерево: в код Прюфера не входят листья, при этом выбирали мы листья с наименьшим номером, поэтому идёт прямо по коду, добавляя к вершинам из кода листья с соответствующими номерами (<em>номера возрастают с пропуском входящих в код вершин (когда мы добавили лист к коду, мы вычёркиваем эту запись из кода, а значит вершина, которой больше нет в коде, также добавляется в очередь на присоединение)</em>)</p>
<h5 id="метод-лапласиана">Метод Лапласиана</h5>
<p>Матрица Лапласа:</p>
<ul>
<li><code>i == j =&gt; a_ij = deg v_i</code></li>
<li><code>(i, j) in E =&gt; a_ij = -1</code></li>
<li><code>otherwise =&gt; a_ij = 0</code></li>
</ul>
<p>То есть <code>L = D - A</code>, где <code>D</code> - матрица степеней, <code>A</code> - матрица смежности</p>
<p><strong>Т. Киргоффа о связи матриц и деревьев:</strong> кол-во остовных деревьев в графе можно посчитать как определитель матрицы Лапласа, из которой мы удалили <code>i</code>-ю строку и столбец.</p>
<h3 id="13-лемма-о-том-в-каких-случаях-вершина-является-точкой-сочленения-в-дереве-поиска-в-глубину">13. Лемма о том, в каких случаях вершина является точкой сочленения в дереве поиска в глубину</h3>
<p>Точка сочленения (articulation point, cut-vertex) - такая вершина <code>v</code>, что для некоторых <code>a</code>, <code>b</code> любой путь <code>a-b</code> будет проходить через <code>v</code>. При удалении cut-vertex возрастёт количество компонент связности</p>
<p><strong>Л.</strong> Для неориентированного графа в его depth-first-tree. Вершина <code>a</code> из этого дерева - <code>cut-vertex</code>, если:</p>
<ul>
<li><code>a</code> - корень =&gt; у неё есть несколько потомков</li>
<li><code>a</code> - не корень и у неё найдётся такое поддерево <code>S</code>, что ни одна из его вершин не будет иметь <code>back</code>-рёбер, ведущих в предков <code>a</code>.</li>
</ul>
<p><em>Доказательство:</em> первое утверждение следует из того факт, что в неориентированном графе не бывает cross-рёбер, а значит несколько поддеревьев корня связаны только через сам этот корень. Второе утверждение:</p>
<ul>
<li>предположим, что условие выполнено, тогда мы можем заключить, что путь из любого предка <code>a</code> в любого потомка будет проходить исключительно через <code>a</code>, а значит <code>a</code> - cut-vertex по определению</li>
<li><em>В обратную сторону:</em> <code>a</code> - cut-vertex, <code>x</code>, <code>y</code> - такие точки, что любой путь между ними содержит <code>a</code>. Либо <code>x</code>, либо <code>y</code> будет потомком <code>a</code>, иначе условие cut-vertex не будет выполнено, другая вершина может лежать либо выше <code>a</code>, либо в отдельном поддереве потомков <code>a</code>, связанным с поддеревом, где лежит первая вершина, только через <code>a</code>. Для обоих этих случаев получаем, что при добавлении back-рёбер, ведущих в предков <code>a</code>, условие для cut-vertex не будет выполнено, что приводит к противоречию</li>
</ul>
<h3 id="14-st-нумерация-алгоритм-построения-st-нумерации">14. st-нумерация. Алгоритм построения st-нумерации</h3>
<p>Если граф двусвязный, то можно взять ребро <code>s-t</code>. Дать <code>s</code> номер 1, а <code>t</code> - номер <code>n = |V|</code>, а затем дать всем остальным связанным с <code>s</code> и <code>t</code> промежуточные номера из интервала <code>(1, n)</code>. Таким образом мы зададим <strong>st-нумерацию</strong></p>
<p>ST-ориентация строится при помощи ST-нумерации - такая нумерация, что выполняется условие <code>i-j in E &lt;=&gt; i &lt; j</code> (говоря проще, st-ориентация - это нумерация вершин в топологическом порядке)</p>
<p>Таким образом, мы берём неориентированный граф, располагаем вершины в ряд, проводя между ними рёбра, а затем нумеруем и ориентируем рёбра в соответствии с правилом выше.</p>
<h5 id="алгоритм-тарьяна">Алгоритм Тарьяна</h5>
<ul>
<li>Нумеруем вершину <code>s</code> как 1, <code>t</code> как 2</li>
<li>Запускаем <code>DFS(s)</code>, считая <code>.d</code>, <code>.parent</code> и <code>.low</code> и раздавая номера вершинам</li>
<li>Задаём список <code>L = [s, t]</code>, <code>sing(s) = '-'</code></li>
<li>Для всех вершин <code>v not in L</code>:</li>
</ul>
<pre><code>if sign(low(v)) == '+' then
  Insert v after p(v) in L
  sign(p(v)) = '-';
end if
if sign(low(v)) == '-' then
  Insert v before p(v) in L
  sign(p(v)) = '+';
end if
</code></pre>
<ul>
<li>В итоге вершины в <code>L</code> будут расположены в том порядке, в котором должны быть в st-нумерации. Располагаем их на прямой и проводим рёбра из исходного графа</li>
</ul>
<h3 id="15-алгоритмы-поиска-минимального-остовного-дерева-корректность-алгоритма-прима">15. Алгоритмы поиска минимального остовного дерева. Корректность алгоритма Прима</h3>
<h4 id="алгоритм-краскала">Алгоритм Краскала</h4>
<p>Позволяет построить минимально весящее остовное дерево. Получаем список всех рёбер, затем добавляем минимальное по весу ребро, если оно не вызывает появление цикла. Повторяем до тех пор, пока в списке не останутся лишь рёбра, добавление которых приведёт к возникновению цикла. <strong>PROFIT</strong></p>
<h4 id="алгоритм-прима">Алгоритм Прима</h4>
<p>Позволяет построить минимально весящее остовное дерево. Из исходного графа берём произвольную вершину, затем смотрим её рёбра и добавляем ребро с наименьшим весом (<em>и вершину на его конце - ваш кэп</em>), затем в полученном дереве также проверяем все рёбра, соединяющие вершины дерева с вершинами вне дерева и выбираем минимальное из этих рёбер. Повторяем, пока все вершины не попадут в дерево.</p>
<p><strong>Т.</strong> Алгоритм Прима создаёт минимальное остовное дерево связного взвешенного графа. <em>Доказывается через взятие эталонного минимального остовного дерева T с n-1 рёбрам и дерева S с k рёбрами, полученного Примом, а затем обоснование равенства этих деревьев, но до конца метод не ясен - уточнить у Морозова или Апанович</em></p>
<p><em>Доказательство:</em> будем идти от противного. Алгоритм всегда завершится потому что рёбер конечное количество. Рассмотрим оптимальное дерево S и полученное Примом дерево T (возможно не оптимальное по нашему предположению). Идём по индукции до момента, когда Прим включил ребро, которого нет в эталоне и через условие включения минимального ребра по алгоритму показываем, что ребро в эталоне можно заменить на выбранное Примом, не потеряв свойства минимальности остова</p>
<h3 id="16-понятие-вершинной-связности-реберной-связности-связь-между-вершинной-связностью-реберной-связностью-и-минимальной-степенью-вершины-в-графе">16. Понятие вершинной связности, реберной связности, связь между вершинной связностью, реберной связностью и минимальной степенью вершины в графе</h3>
<p>Граф называется связным <code>&lt;=&gt;</code> из любой его вершины можно попасть в любую. Имеет одну компоненту связности.</p>
<p><strong>Cut-vertices (разделяющие вершины)</strong> - вершины, при удалении которых (по одиночке) граф перестаёт быть связным. Существуют также <strong>cut-edge (мосты)</strong>.</p>
<p>Не у всех графов есть cut-vertices и cut-edge. Графы без них называются <strong>nonseparable (ЕДИНЫМИ И НЕДЕЛИМЫМИ!)</strong>.</p>
<p>Число вершинной связности (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\kappa(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">κ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>) - минимальное число вершин, которое нужно удалить для дробления графа на отдельные компоненты связности. Граф называется <code>k</code>-вершинно связным, если <code>k</code> - число вершинной связности.</p>
<p>Аналогичным образом вводится понятие рёберной связности (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>). Зачастую рёберная связность больше вершинной. Множество рёбер, удаление которых приводит к увеличению кол-ва компонент связности, называется <strong>разрезом</strong></p>
<p>Для любого графа рёберная связность <code>&lt;= min deg v</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">= \delta(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>. Для неполного графа с минимум тремя вершинами также справедливо <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>min</mi><mo>⁡</mo><mi>deg</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\kappa(G) \le \min \deg(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">κ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></p>
<p>Отсюда следует: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\kappa(G) \le \lambda(G) \le \delta(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">κ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>. <em>Первая половина неравенства доказывается рассмотрением нескольких случаев:</em></p>
<ol>
<li>Для несвязного или тривиального графа <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\kappa(G) = \lambda(G) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">κ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></li>
<li>В графе есть мост =&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lambda(G) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> =&gt; для разделения графа также можно удалить любую из двух вершин, инцидентных мосту =&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\kappa(G) = \lambda(G) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">κ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\lambda(G) &gt; 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> =&gt; удаление <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lambda - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> рёбер создаст граф с мостом. вместо удаления рёбер удалим <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lambda - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> раз инцидентные им вершины. Если граф уже распался на несколько компонент, то <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mi>λ</mi><mo>−</mo><mn>1</mn><mo>&lt;</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\kappa(G) = \lambda - 1 &lt; \lambda(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">κ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>, иначе удаляем одну из вершин при оставшемся мосте, тогда получаем <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">\kappa = \lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span></li>
</ol>
<h3 id="17-понятие-точки-сочленения-двусвязной-компоненты-двусвязного-графа-лемма-о-свойствах-двусвязных-компонент">17. Понятие точки сочленения, двусвязной компоненты, двусвязного графа. Лемма о свойствах двусвязных компонент.</h3>
<p>Точка сочленения (articulation point, cut-vertex) - такая вершина <code>v</code>, что для некоторых <code>a</code>, <code>b</code> любой путь <code>a-b</code> будет проходить через <code>v</code>. При удалении cut-vertex возрастёт количество компонент связности</p>
<p>Число вершинной связности (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\kappa(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">κ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>) - минимальное число вершин, которое нужно удалить для дробления графа на отдельные компоненты связности. Граф называется <code>k</code>-вершинно связным, если <code>k</code> - число вершинной связности.</p>
<p>Двусвязные графы - графы с <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\kappa(G) = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">κ</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> , то есть у него нет <em>cut-vertices</em>.</p>
<p><strong>Граф из двух вершин также будет считаться двусвязным, если исходить из определения разделяющих вершин через тройки вершин</strong></p>
<p>Определим натуральное отношение на множестве рёбер графа, говоря, что <code>e1</code> и <code>e2</code> связаны, если <code>e1 = e2</code> или <code>e1</code> и <code>e2</code> находятся в одном цикле. Это отношение разбивает граф <code>G</code> на классы эквивалентности <code>G_i = (V_i, E_i)</code>, где <code>E_i</code> - множество рёбер, находящихся в одном цикле, а <code>V_i</code> - множество вершин этих рёбер. Каждый граф <code>G_i</code> называется <strong>двусвязной компонентной</strong> <code>G</code></p>
<p><strong>Л.</strong> Пусть у нас есть компоненты двусвязности <code>G_i = (V_i, E_i)</code> некоторого графа <code>G</code>, тогда:</p>
<ol>
<li><code>forall 1 &lt;= i &lt;= k : G_i</code> двусвязен (<em>доказывается через невозможность существования в цикле точки сочленения</em>)</li>
<li><code>forall i != j : </code> пресечение <code>V_i</code> и <code>V_j</code> даёт не более одной вершины.
<ul>
<li><em>Предположим обратное:</em> если в пересечение <code>V_i</code> и <code>V_j</code> даёт нам вершины <code>{v,w}</code>, то у нас будут циклы <code>C1</code> в <code>G_i</code> и <code>C2</code> в <code>G_j</code>, каждый из которых содержит обе вершины, но из этого следует, что у нас будут эквивалентные рёбра между <code>v</code> и <code>w</code>, входящие в <code>C1</code> и в <code>C2</code>, а значит <code>E_i</code> и <code>E_j</code> - это не классы эквивалентности (<em>у классов эквивалентности не может быть пересечений</em>), как предполагалось по условию - <strong>Противоречие</strong></li>
</ul>
</li>
<li>Полученная пересечением из пункта 2 вершина будет cut-vertex
<ol>
<li>=&gt; Предположим, что пересечение <code>V_i</code> и <code>V_j</code> дают нам вершину <code>a</code>, которая будет cut-vertex для исходного графа и его вершин <code>v</code>, <code>w</code>. Возьмём также инцидентные <code>a</code> рёбра <code>x-a</code>, <code>a-y</code>, через которые будет проходить один из путей из <code>v</code> в <code>w</code>. Если <code>x-a</code> и <code>a-y</code> принадлежат одной компоненте (то есть лежат в цикле), то будет путь из <code>v</code> в <code>w</code>, не проходящий через <code>a</code> - <strong>противоречие</strong>. Значит <code>x-a</code> и <code>a-y</code> в разных циклах =&gt; они в разных компонентах двусвязности</li>
<li>&lt;= <code>a</code> - единственная точка пересечения для множеств вершин двух компонент двусвязности, значит ребро <code>x-a in E_i</code> и ребро <code>a-y in E_j</code> не будут в одном цикле, при этом через <code>a</code> будут проходить все пути из <code>x</code> в <code>y</code> =&gt; <code>a</code> - cut-vertex</li>
</ol>
</li>
</ol>
<h3 id="18-алгоритм-дейкстры-поиска-кратчайшего-пути-в-графе-корректность-алгоритма-дейкстры">18. Алгоритм Дейкстры поиска кратчайшего пути в графе. Корректность алгоритма Дейкстры</h3>
<h4 id="кратчайшие-пути">Кратчайшие пути</h4>
<p><strong>Л.</strong> Подпуть кратчайшего пути также будет кратчайшим путём</p>
<p>Вспомогательные функции</p>
<pre><code>init(G, s):
for vertex v in G.V:
  v.d = inf
  v.pi = NUL
s.d = 0

### w - функция веса, возвращающая вес ребра между переданными вершинами (гарантируется, что такое ребро существует)

relax(u, v, w):
  if v.d &gt; u.d + w(u, v):
    v.d = u.d + w(u, v)
    v.pi = u
</code></pre>
<p>Свойства кратчайших путей и релаксации:</p>
<ul>
<li><strong>Неравенство треугольника</strong> - для любого ребра <code>u-v</code>: <code>delta(s, v) &lt;= d.u + w(u, v)</code></li>
<li><strong>Верхняя граница</strong> - для любой вершины <code>v</code>: <code>v.d &gt;= delta(s, v)</code>. Когда <code>v.d</code> достигает <code>delta(s, v)</code>, она больше не может быть изменена</li>
<li><strong>Отсутствие пути</strong> - если нет пути из <code>s</code> в <code>v</code>, то <code>v.d = delta(s, v) = inf</code></li>
<li><strong>Сходимость</strong> - если есть кратчайший путь <code>s - ... - u - v</code> и <code>u.d = delta(s, u)</code>, то после релаксации <code>(u, v)</code> мы получим <code>v.d = delta(s, v)</code></li>
<li><strong>Релаксация пути</strong> - если в кратчайшем пути <code>v1 - ... - vk</code> последовательно релаксировать все рёбра, то в результате мы получим <code>vk.d = delta(v1, vk)</code></li>
<li><strong>Подграф предшественников</strong> - если для любой вершины <code>v</code> <code>v.d = delta(s, v)</code>, то подграф предшественником будет деревом кратчайших путей</li>
</ul>
<h4 id="алгоритм-дийкстры">Алгоритм Дийкстры</h4>
<p>Работает гораздо быстрее Беллмана-Форда, но только на графах <strong>без отрицательных</strong> рёбер. Вспомогательным будет множество <code>S</code>, содержащее те вершины графа, для которых уже определён кратчайший путь, и очередь приоритетов <code>Q</code> (либо бинарная куча по минимуму)</p>
<pre><code>init(G, s)

S = []
Q = G.V

while Q.notEmpty:
  u = extractMin(Q)  ### Извлекаем вершину с минимальным .d
  S += [u]
  for vertex v in G.adj[u]
    relax(u, v, w) 
</code></pre>
<p>Эффективность алгоритма - <code>O(|V|^2)</code>, если использовать примитивный поиск минимальной вершины, и <code>O(|V| log |V|)</code>, если использовать быстрый поиск минимума</p>
<p><strong>Т. О корректности алгоритма Дейкстры</strong> Алгоритм Дейкстры, запущенный на графе без отрицательных рёбер, даст нам кратчайшие пути из исходной вершины и построит дерево кратчайших путей. <em>Доказательство:</em> пусть <code>l(v)</code> - длина кратчайшего пути до <code>v</code>, <code>d(v)</code> - длина пути, рассчитанного алгоритмом Дейкстры на данный момент. Докажем по индукции, что в момент посещения любой вершины <code>l(v) = d(v)</code>. Для начально вершины <code>s</code> равенство выполнено: <code>l(s) = d(s) = 0</code>. Отметим, что <code>d(v) &gt;= l(v)</code> (алгоритм не может найти путь короче кратчайшего). Теперь будем считать, что алгоритм выбрал для посещения вершину <code>v != s</code>. <code>P</code> - кратчайший путь из <code>s</code> в <code>v</code>. (значит на данный момент из непосещённых <code>d(v)</code> минимально). Будем считать, что первая непосещённая вершина в пути <code>P</code> - это <code>y</code>, а <code>x</code> предшествует <code>y</code> (следовательно <code>x</code> уже посещена и есть ребро <code>x-y</code>). Так как путь <code>P</code> кратчайший, его подпуть тоже будет кратчайшим =&gt; <code>l(y) = l(x) + w(x, y)</code>. По предположению индукции <code>l(x) = d(x)</code> =&gt; <code>d(y) = d(x) + w(x, y) = l(x) + w(x, y) = l(y)</code>, то есть <code>d(y) = l(y)</code>. Если <code>y = v</code>, то индуктивный переход доказан, если же <code>y != v</code> при том, что <code>v</code> была выбрана как минимальная по <code>d()</code>, мы получаем, что <code>d(v) &lt;= d(y) = l(y) &lt;= l(v)</code> - если у нас нет рёбер нулевого веса, то из этого следует противоречие, которое и позволяет заключить, что <code>y = v</code>, если <code>v</code> было выбрано алгоритмом, из чего следует, что на минимальном пути алгоритм всегда будет выбирать следующую в пути вершину. Шаг индукции доказан, из него заключаем, что после исполнения Дейкстры для всех вершин у всех будет <code>d = l</code></p>
<h3 id="19-алгоритм-беллмана-форда-поиска-кратчайшего-пути-в-графе-корректность-алгоритма-беллмана-форда">19. Алгоритм Беллмана-Форда поиска кратчайшего пути в графе. Корректность Алгоритма Беллмана-Форда</h3>
<p><em>вводную часть смотри в прошлом вопросе</em></p>
<p>Позволяет находить кратчайший путь из одной вершины в другую в графе с отрицательными весами и без отрицательных циклов, в случае отрицательных циклов скажет о невозможности решения задачи.</p>
<pre><code>init(G, s)

for i = 1 to |G.V| - 1:
  for edge (u,v) in G.E:
    relax(u, v, w)

### Проверка на достижимые циклы отрицательного веса
for edge (u,v) in G.E:
  if v.d &gt; u.d + w(u,v):
    return FALSE
return TRUE
</code></pre>
<p><strong>Т. О корректности алгоритма Беллмана-Форда</strong>
После запуска алгоритма Беллмана-Форда из вершины <code>s</code> графа <code>G</code> возможны 2 случая:</p>
<ol>
<li>Если в графе нет циклов отрицательного веса, достижимых из <code>s</code>, алгоритм установит в качестве <code>v.d</code> кратчайший путь из <code>s</code> в <code>v</code>, а параметр предка позволит построить дерево кратчайших путей. <em>Доказывается</em> через <strong>свойства релаксации пути</strong> и <strong>верхней границы</strong> после релаксации до кратчайшего пути. Также отметим, что любой кратчайший путь в графе из <code>|V|</code> вершин будет содержать не больше <code>|V| - 1</code> рёбер, из чего следует, что релаксируя все рёбра <code>|V| - 1</code> раз мы гарантированно посчитаем <code>delta(s, v_i)</code> для всех <code>i &lt;= k</code>. Если вершина не достижима из <code>s</code>, то для неё кратчайший путь останется бесконечностью по <strong>свойству отсутствия пути</strong>.</li>
<li>Если в графе есть циклы отрицательного веса, достижимые из <code>s</code>, алгоритм вернёт <code>FALSE</code>. <em>Доказательство:</em> при наличии негативных циклов алгоритм будет бесконечно релаксировать рёбра, так как найдётся путь короче посчитанного ранее. Таким образом, если на <code>|V|</code>-й итерации может быть отрелаксировано хотя бы какое-то ребро, мы заключаем, что у нас есть негативный цикл, а значит алгоритм вернёт <code>FALSE</code></li>
</ol>
<h3 id="20-алгоритмы-поиска-кратчайшего-пути-между-всеми-вершинами-графа-на-основе-матричного-умножения">20. Алгоритмы поиска кратчайшего пути между всеми вершинами графа на основе матричного умножения</h3>
<p><code>W</code> - матрица весов (<code>w_ij</code> - путь из <code>i</code> в <code>j</code>)</p>
<p><code>L^m</code> - матрица длины пути из <code>m</code> вершин, где <code>l_ij</code> - длина кратчайшего пути. Таким образом, ответ будет в матрице <code>L^(n-1)</code></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>l</mi><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">{</mo><msubsup><mi>l</mi><mrow><mi>i</mi><mi>k</mi></mrow><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><msub><mi>w</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">l^{(m)}_{ij} = \min\{l^{(m-1)}_{ik} + w_{kj}\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4578em;vertical-align:-0.413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.413em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3461em;vertical-align:-0.3013em;"></span><span class="mop">min</span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.3987em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">kj</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p>
<p>Описывая более <em>человечно</em>: мы берём матрицу весов и &quot;умножаем&quot; на саму себя, так переопределив операцию умножения: <code>ij</code> ячейка будет содержать в себе минимум из сумм ячеек <code>ik</code> и <code>kj</code> для всех <code>1 &lt;= k &lt;= n</code> (то есть мы выбираем минимальный возможный путь из <code>i</code> в <code>j</code>, проходящий через <code>k</code>. <em>причём <code>k</code> может и не существовать на самом деле как отдельная вершина, когда <code>k = i</code> или <code>k = j</code></em>). Умножив матрицу путей на матрицу весов, мы удлиняем возможную длину кратчайшего пути на 1.</p>
<p>Время работы для подсчёта всех кратчайших путей - <code>O(n^4)</code>, если пользоваться &quot;быстрым возведением в степень&quot; (<code>W^4 = W^2^2</code>, <code>W^9 = W * W^2^2^2</code> и т.п.), то можно улучшить время до <code>O(n^3 log n)</code></p>
<h3 id="21-алгоритм-флойда-уршолла">21. Алгоритм Флойда-Уршолла</h3>
<p>Матрица с путями длины <code>n</code> - <code>D^n</code>.</p>
<p>Рассматриваем матрицу путей <code>D</code> (<code>D^0 = W</code>), далее будем последовательно рассматривать все промежуточные вершины <code>k</code>, которые могут входить в путь из <code>i</code> в <code>j</code>. Если путь <code>i - ... - k - ... - j</code> (<code>D^(k-1)[i][k] + D^(k-1)[k][j]</code>) меньше текущего пути <code>i - ... - j</code> (<code>D^(k-1)[i][j]</code>), то обновляем длину пути в новой матрице: (<code>D^k[i][j] = D^(k-1)[i][k] + D^(k-1)[k][j]</code>), считая вершину включённой в путь. Таким образом, за <code>n</code> итераций мы рассмотрим все возможные пути, в которые могли быть включены все промежуточные вершины (а могла не включаться ни одна - тоже возможно)</p>
<p>Если действовать руками: для итерации <code>k</code> берём <code>k</code>-ю строку и <code>k</code>-й столбец. Для расчёта <code>i</code>-строки берём <code>k</code>-ю строку и прибавляем к ней <code>i</code>-й элемент <code>k</code>-го столбца. В новой матрице путей обновляем в <code>i</code>-й строки те ячейки, значения в которых получились меньше, чем на прошлом этапе.</p>
<p>Эффективность <code>O(|V|^3)</code></p>
<p>Если мы заменили <code>d_ij</code> на <code>d_ik + d_kj</code>, то ячейка матрицы предшествования <code>p_ij = p_kj</code></p>
<p>Для восстановления пути из <code>i</code> в <code>j</code> мы берём предшественника <code>v</code>, равного <code>p_ij</code>, добавляем <code>v</code> в конце пути и берём <code>v = p_iv</code> до тех пор, пока <code>v != i</code></p>
<h3 id="22-алгоритм-джонсона">22. Алгоритм Джонсона</h3>
<p>Самый быстрый - <code>O(V^2 lg V + VE)</code></p>
<p>Если в графе нет отрицательных рёбер, мы просто запускаем алгоритм Дийкстры для всех вершин.</p>
<p>Если есть отрицательные рёбра (<em>но не отрицательные циклы, ясное дело</em>), то мы пересчитываем все веса по двум следующим правилам:</p>
<ul>
<li>Пути, бывшие кратчайшими, должны таковыми и остаться</li>
<li>Новые веса должны быть позитивными (<em>весёёёлыми!!11!!!1!!!!1!!</em>)</li>
</ul>
<p>Для начала отметим, что преобразование <code>w'(u,v) = w(u, v) + h(u) - h(v)</code>, то есть все кратчайшие пути останутся кратчайшими. (<em>Суммируем все веса рёбер на пути с дэльтами для начала и конца каждого ребра, в результате у нас останется сумма исходны рёбер плюс <code>h(s)</code> начальной вершины минус <code>h(t)</code> конца пути</em>)</p>
<p>Далее добавим к графу вершину <code>s</code> с рёбрами нулевого веса и запустим от неё алгоритм Беллмана-Форда.</p>
<p>Определим <code>h(v) = path[v]</code>, рассчитанный Беллманом. Теперь мы можем перевзвесить рёбра так, что они все будут <code>&gt;= 0</code> (пользуясь формулой <code>w'(u, v) = w(u, v) + h(u) - h(v)</code>), далее снова запускаем Дийкстру для всех вершин как истоков и записываем в матрицу результаты.</p>
<h3 id="23-понятие-потоковой-сети-и-остаточного-графа-операция-увеличения-потока-ее-свойства">23. Понятие потоковой сети и остаточного графа. Операция увеличения потока, ее свойства</h3>
<p><strong>Потоковая сеть</strong> - ориентированный граф с истоком <code>s</code>, стоком <code>t</code>, внутренними вершинами и заданной для его рёбер пропускной способностью <code>c_e</code> (<em>на самом деле можно рассматривать и неориентированный граф, но на практике это нужно не так часто</em>)</p>
<p>Поток <code>f(e)</code> из истока <code>s</code> в сток <code>t</code> - это отображение каждого ребра в вещетсвенное число.</p>
<p><strong>Условие пропускной способности (capacity condition):</strong> <code>0 &lt;= f(e) &lt;= c_e</code></p>
<p><strong>Условие сохранения (conservation condition):</strong> Для всех вершин кроме <code>s</code> и <code>t</code> сумма потоков входа = сумме потоков выхода (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mi>i</mi><mi>n</mi></mrow></msup><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>e</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>o</mi><mi>v</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>f</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>f</mi><mi>v</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^{in}(v) = \sum_{e into v}f(e) = f^{out}(v) = \sum_{e out of v}f(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0747em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">in</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">in</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0436em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">eo</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>)</p>
<p>Значение потока - сумма всех потоков, исходящих из <code>s</code>.</p>
<p>Для решения задачи вычисления максимального значения потока используется <strong>остаточный граф (остаточная сеть) <code>G_f</code></strong> (будем обозначать через <code>c(e)</code> остаточную пропускную способность ребра, то есть изначально <code>c(e) = c_e</code>):</p>
<ul>
<li>Множество вершин как в исходном графе</li>
<li>Для ребра <code>e = (u,v)</code>:
<ul>
<li>если <code>f(e) &lt; c_e</code>, то <code>c(e) = c_e - f(e)</code> - остаточная пропускная способность прямого ребра (<em>очевидно, если <code>f(e) = c_e</code>, то прямого ребра не будет</em>)</li>
<li>если <code>f(e) &gt; 0</code>, то добавляется обратное ребро <code>e' = (v, u)</code> (<strong>ориентация важна</strong>), для которого <code>c(e') = f(e)</code></li>
</ul>
</li>
</ul>
<p><em>В наших лекциях используется такая нотация:</em> окло рёбер исходного графа записывается <code>f(e)/c_e</code>, то есть проходящий по прямому ребру остаточного графа поток и общая пропускная способность прямого ребра</p>
<h2 id="операция-увеличения-потока">Операция увеличения потока</h2>
<p>Пусть <code>P</code> - некоторый простой путь из <code>s</code> в <code>t</code> в потоковой сети. Определим 2 функции:</p>
<ul>
<li><code>bottleneck(P, f)</code> - возвращает минимальное значение остаточной пропускной способности на пути <code>P</code> (то есть на сколько мы можем увеличить поток во всех рёбрах по этому пути)</li>
<li><code>augment(f, P)</code> - обновляет поток для всех входящих в него рёбер:
<ul>
<li>будем считать, что <code>b = bottleneck(P, f)</code>, тогда</li>
<li>для всех прямых рёбер в <code>P</code> увеличиваем поток на <code>b</code></li>
<li>для всех обратных рёбер в <code>P</code> уменьшаем поток в прямых рёбрах, соответствующих этим обратным, на <code>b</code></li>
</ul>
</li>
</ul>
<p>В рузльтате мы получаем новый поток <code>f' &gt; f</code></p>
<p><strong>Л.</strong> Новый поток <code>f'</code> также будет потоком для <code>G</code>. <em>Доказательство:</em></p>
<ol>
<li>Сохранение условия пропускной способности: <code>b = bottleneck(P, f)</code> не может превышать минимальной пропускной способности на пути <code>P</code>. Напомним, что для прямого ребра остаточная пропускная способность <code>c(e) = c_e - f(e)</code>, а для обратного - <code>c(e') = f()</code>. Из этого следует, что
<ul>
<li>для любого прямого ребра на пути будет <code>f'(e) = f(e) + b &gt;= 0</code> и <code>f'(e) = f(e) + b &lt;= f(e) + (c_e - f(e)) = c_e</code></li>
<li>для любого обратного ребра, которому соответствует прямое ребро <code>e</code> будет <code>f'(e) = f(e) - b &lt;= f(e) &lt;= c_e</code> и <code>f'(e) = f(e) - b &gt;= f(e) - f(e) = 0</code></li>
</ul>
</li>
<li>Сохранение conservations condition для всех внутренних вершин графа. Сводится к доказательству того, что для каждой вершины вход и выход либо были увеличены на <code>b</code>, либо уменьшены. Рассматриваем 4 случая, когда перед и после вершины forward-forward рёбра, forward-back, back-forward и back-back. Доказательство для них достаточно тривиальное.</li>
</ol>
<h3 id="24-лемма-о-целочисленности-величины-потока-fe-и-остаточных-пропускных-способностей-на-каждой-промежуточной-стадии-алгоритма-форда-фалкерсона">24. Лемма о целочисленности величины потока f(e) и остаточных пропускных способностей на каждой промежуточной стадии алгоритма Форда-Фалкерсона</h3>
<p><strong>Сам алгоритм работает так:</strong> задаём начальный остаточный граф <code>G_f</code> с нулевым потоком. Пока в <code>G_f</code> можно найти какой-либо путь <code>P</code> из <code>s</code> в <code>t</code>, проводим увеличение потока и обновление остаточного графа <code>G_f</code></p>
<p><strong>Л. 2</strong> На каждой итерации Форда-Фалкерсона значения потока и остаточной пропускной способности целые. <em>Доказательство:</em> до начала алгоритма все остаточные пропускные способности целые - <strong>база рекурсии</strong>. Если на <code>j</code>-й итерации все значения также будут целыми, то новое найденное значение <code>b</code> также будет целым (минимальное из целых остаточных пропускных способностей), а значит изменяться целые значения потока и, следовательно, пропускные способности будут на целое число =&gt; <code>f</code> и <code>c_e</code> будут целыми на <code>j + 1</code> итерации</p>
<p><strong>Л. 3</strong> На каждом этапе алгоритма Форда-Фолкерсона поток строго увеличивается (а остаточная пропускная способность уменьшается). <em>Доказательство:</em> в любой простой <code>P</code> точно будет входить прямое ребро из <code>s</code>, причём только одно, а значит при нахождении любого <code>P</code> поток точно будет увеличен на <code>bottleneck(P, f)</code>, то есть пока алгоритм работает, он будет давать приращение потока.</p>
<h3 id="25-леммы-о-завершении-и-времени-выполнения-алгоритма-форда-фалкерсона">25. Леммы о завершении и времени выполнения алгоритма Форда-Фалкерсона</h3>
<p><code>C = sum c_e</code> - сумма пропускных способностей всех рёбер, исходящих из истока <code>s</code></p>
<p><strong>Л. 4</strong> Предполагая, что все пропускные способности и потоки целые, мы можем утверждать, что алгоритм Форда-Фолкерсона будет исполнен за не больше, чем <code>C</code> итераций. <em>Доказательство:</em> по условию пропускной способности значение всего потока не может превысить <code>C</code>, но по прошлым двум леммам (<em>смотри прошлый вопрос</em>) его значение должно увеличиваться на каждой итерации и при том увеличиваться на целое число, из чего и следует утверждение этой леммы.</p>
<p><strong>Л. 5</strong> Для графа с целочисленными пропускными способностями алгоритм Форда-Фалкерсона будет исполнен за <code>O(Cm)</code>, где <code>m</code> - кол-во рёбер. <em>Доказательство:</em> как было доказано выше, в алгоритме будет <code>&lt;= C</code> итераций, теперь остаётся выяснить асимптотическое время внутри каждой итерации. Путь <code>P</code> можно искать BFS за <code>O(m + n) = O(m)</code> (предполагая <code>m &gt;= n/2</code>), <code>bottleneck</code> можно считать вместе с поиском пути. <code>augment</code> будет проходить за <code>O(n - 1)</code> итераций, построение новой остаточной сети займёт <code>O(m)</code> (<em>а на самом деле можно предпостроить обратные рёбра, а потом обновлять для них значения в <code>augment</code> (если не прогали этот алгоритм и не понимаете о чём речь,лучше это не говорить)</em>). Получаем для цикла <code>O(2m + n - 1) = O(m)</code> =&gt; время алгоритма в целом = <code>O(Cm)</code></p>
<h3 id="26-лемма-о-связи-между-значением-потока-и-величиной-потока-передаваемой-через-разрез">26. Лемма о связи между значением потока и величиной потока, передаваемой через разрез</h3>
<p><strong>О.</strong> <code>s-t</code> разрез <code>(A, B)</code> - такой разрез множества <code>V</code>, что <code>s in A</code> и <code>t in B</code></p>
<p><strong>Л. 6</strong> Для любого <code>s-t</code> потока и любого (<code>A</code>, <code>B</code>) разреза: <code>v(f) = f_out(A) - f_in(A)</code>. <em>Доказательство:</em> для <code>A = {s}</code> имеет <code>f_out(s) = v(f)</code>, <code>f_in(s) = 0</code> =&gt; <code>v(f) = f_out(s) - f_in(s)</code>. Учитывая условие сохранения, заключаем, что остальные слагаемые (внутренние точки) должны удовлетворять условию <code>f_in = f_out</code>, значит в сумме всех <code>f_out - f_in</code> только разность для <code>v = s</code> будет ненулевой. Далее рассмотрим сумму потоков исхода и входа для вершин в разрезе. Если обе вершины ребра будут входить в разрез, то <code>f(e)</code> будет полявляться и с <code>+</code>, и с <code>-</code>. Если в разрез будет входить только хвост (начальная вершина) ребра, то будет только <code>+f(e)</code>, если только голова (конечная вершина) - только <code>-f(e)</code>. Рёбра, лежащие обеими вершинами вне разреза не будут учитываться. Из этих утверждений получаем <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>f</mi><mi>A</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mo>∑</mo><mrow><mi>e</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>o</mi><mi>A</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>f</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>−</mo><msup><mi>f</mi><mrow><mi>i</mi><mi>n</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{e out of A}f(e) - \sum_{e into A}f(e) = f^{out}(A) - f^{in}(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">eo</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">in</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0436em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0747em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">in</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span></p>
<p><strong>Л. 7</strong> Для любого <code>s-t</code> потока любого (<code>A</code>, <code>B</code>) разреза: <code>v(f) = f_in(B) - f_out(B)</code>. <em>Доказывается очень похоже на прошлую теорему.</em> Отличие в том, что здесь мы опираемся на утверждение, что для <code>B = {t}</code> <code>v(f) = f_in(t) = f_in(B)</code>, <code>f_out(t) = f_out(B) = 0</code> =&gt; <code>v(f) = f_in(B) - f_out(B)</code>. Все последующие утверждения будут также инвертироваться относительно хваоста/головы.</p>
<h3 id="27-лемма-о-связи-между-величиной-потока-и-пропускной-способностью-разреза">27. Лемма о связи между величиной потока и пропускной способностью разреза</h3>
<p><strong>О.</strong> <code>s-t</code> разрез <code>(A, B)</code> - такой разрез множества <code>V</code>, что <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">s \in A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> и <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">t \in B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi><mo>=</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">A + B = V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>&amp;</mo><mi>B</mi><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">A \And B = \empty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">&amp;</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">∅</span></span></span></span></p>
<p><strong>Л. 6</strong> Для любого <code>s-t</code> потока и любого (<code>A</code>, <code>B</code>) разреза: <code>v(f) = f_out(A) - f_in(A)</code>. <em>Доказательство:</em> для <code>A = {s}</code> имеет <code>f_out(s) = v(f)</code>, <code>f_in(s) = 0</code> =&gt; <code>v(f) = f_out(s) - f_in(s)</code>. Учитывая условие сохранения, заключаем, что остальные слагаемые (внутренние точки) должны удовлетворять условию <code>f_in = f_out</code>, значит в сумме всех <code>f_out - f_in</code> только разность для <code>v = s</code> будет ненулевой. Далее рассмотрим сумму потоков исхода и входа для вершин в разрезе. Если обе вершины ребра будут входить в разрез, то <code>f(e)</code> будет полявляться и с <code>+</code>, и с <code>-</code>. Если в разрез будет входить только хвост (начальная вершина) ребра, то будет только <code>+f(e)</code>, если только голова (конечная вершина) - только <code>-f(e)</code>. Рёбра, лежащие обеими вершинами вне разреза не будут учитываться. Из этих утверждений получаем <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>f</mi><mi>A</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mo>∑</mo><mrow><mi>e</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>o</mi><mi>A</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>f</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>−</mo><msup><mi>f</mi><mrow><mi>i</mi><mi>n</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{e out of A}f(e) - \sum_{e into A}f(e) = f^{out}(A) - f^{in}(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">eo</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">in</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0436em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0747em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">in</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span></p>
<p><strong>Л. 7</strong> Для любого <code>s-t</code> потока любого (<code>A</code>, <code>B</code>) разреза: <code>v(f) = f_in(B) - f_out(B)</code>. <em>Доказывается очень похоже на прошлую теорему.</em> Отличие в том, что здесь мы опираемся на утверждение, что для <code>B = {t}</code> <code>v(f) = f_in(t) = f_in(B)</code>, <code>f_out(t) = f_out(B) = 0</code> =&gt; <code>v(f) = f_in(B) - f_out(B)</code>. Все последующие утверждения будут также инвертироваться относительно хваоста/головы.</p>
<p><strong>Л. 8</strong> Для любого потока его значение не будет больше пропускной способности любого разреза. <em>Доказательство:</em> через условие пропускной способности лемму о значении потока для разреза достаточно просто выводится необходимое неравенство:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>f</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>−</mo><msup><mi>f</mi><mrow><mi>i</mi><mi>n</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>≤</mo><msup><mi>f</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>f</mi><mi>A</mi></mrow></munder><mi>f</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>≤</mo><munder><mo>∑</mo><mrow><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>f</mi><mi>A</mi></mrow></munder><msub><mi>c</mi><mi>e</mi></msub><mo>=</mo><mi>c</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">v(f) = f^{out}(A) - f^{in}(A) \le f^{out}(A) = \sum_{e out of A} f(e) \le \sum_{e out of A} c_e = c(A, B)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0936em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8436em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1247em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">in</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0936em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8436em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4882em;vertical-align:-1.4382em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">eo</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">A</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4382em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4882em;vertical-align:-1.4382em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">eo</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">A</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4382em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></span></p>
<p><strong>Л. 9</strong> Если мы нашли такой поток <code>f</code>, что больше нет путей <code>s-t</code> в остаточном графе (алгоритм Форда-Фолкерсона завершился), тогда найдётся такой разрез <code>(A*, B*)</code>, что <code>v(f) = c(A*, B*)</code> (<em>То есть пропускная спосбность разреза будет минимально возможной, а поток - максимальным</em>). <em>Доказывается взятием такого разреза, что в <code>A*</code> есть пути между внутренними вершинами, но нет доступного пути в остаточной сети <code>B*</code>, то есть <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo>∗</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>f</mi><mi>A</mi><mo>∗</mo></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>f</mi><mi>A</mi><mo>∗</mo></mrow></msub><msub><mi>c</mi><mi>e</mi></msub><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∗</mo><mo separator="true">,</mo><mi>B</mi><mo>∗</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^{out}(A*) = \sum_{e out of A*} f(e) = \sum_{e out of A*} c_e = C(A*, B*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0436em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∗</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">eo</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">A</span><span class="mord mtight">∗</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">eo</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">A</span><span class="mord mtight">∗</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∗</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∗</span><span class="mclose">)</span></span></span></span>, при этом все входящие в <code>A*</code> рёбра будут иметь нулевой поток, иначе найдётся обратное им ребро в остаточной сети, по которому из <code>A*</code> можно пройти в <code>B*</code>, отсюда заключаем, что <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mi>i</mi><mi>n</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo>∗</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>e</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>o</mi><mi>A</mi><mo>∗</mo></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f^{in}(A*) = \sum_{e into A*} f(e) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0747em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">in</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∗</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">in</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">A</span><span class="mord mtight">∗</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> =&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>f</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo>∗</mo><mo stretchy="false">)</mo><mo>−</mo><msup><mi>f</mi><mrow><mi>i</mi><mi>n</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo>∗</mo><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∗</mo><mo separator="true">,</mo><mi>B</mi><mo>∗</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">v(f) = f^{out}(A*) - f^{in}(A*) = C(A*, B*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0436em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∗</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0747em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">in</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∗</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∗</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∗</span><span class="mclose">)</span></span></span></span></em></p>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>