- [Контакты преподов](#контакты-преподов)
- [Книги](#книги)
- [Статьи](#статьи)
- [22.09.02 - Лекция](#220902---лекция)
- [22.09.05 - Семинар](#220905---семинар)
- [22.09.09 - лекция](#220909---лекция)
  - [Типы данныех](#типы-данныех)
  - [Функции](#функции)
    - [Немного о рекурсии и ко-рекурсии](#немного-о-рекурсии-и-ко-рекурсии)
    - [Лямбда-функции](#лямбда-функции)
- [22.09.12 - семинар](#220912---семинар)
  - [Локальные переменные](#локальные-переменные)
  - [Оператор понижения приоритета](#оператор-понижения-приоритета)
  - [Оператор композиции](#оператор-композиции)
  - [Операторы возвездения в степень](#операторы-возвездения-в-степень)
- [22.09.16 - лекция](#220916---лекция)
  - [Слово-оператор](#слово-оператор)
  - [Кортежи](#кортежи)
  - [Списки](#списки)
- [22.09.19 - семинар](#220919---семинар)
  - [Хвостовая рекурсия](#хвостовая-рекурсия)
  - [Мемоизация функций](#мемоизация-функций)
- [22.09.23 - лекция](#220923---лекция)
  - [Генераторы списков](#генераторы-списков)
  - [Хваостовая рекурсия](#хваостовая-рекурсия)
  - [Работа с множествами](#работа-с-множествами)
  - [Свёртки](#свёртки)
    - [Левая свёртка](#левая-свёртка)
    - [Правая свёртка](#правая-свёртка)
    - [Реализзация](#реализзация)
  - [scan](#scan)
- [22.09.30 - лекция](#220930---лекция)
  - [Система типов](#система-типов)
    - [Перечисление (суммирование)](#перечисление-суммирование)
    - [С использованием конструктора (Умножение)](#с-использованием-конструктора-умножение)
    - [Создание именованных полей](#создание-именованных-полей)
    - [Другие методы объявления типов](#другие-методы-объявления-типов)
- [22.10.03 - семинар](#221003---семинар)
  - [Ещё несколько методов генерации списков](#ещё-несколько-методов-генерации-списков)
- [22.10.07 - лекция](#221007---лекция)
  - [Классы](#классы)
- [22.10.14 - лекция](#221014---лекция)
  - [Структуры данных в Haskell](#структуры-данных-в-haskell)
    - [Maybe](#maybe)
- [22.10.17 - семинар](#221017---семинар)
  - [Алгебраические типы данных](#алгебраические-типы-данных)
- [22.10.21 - лекция](#221021---лекция)
  - [Map](#map)
  - [HashMap](#hashmap)
  - [Sequence](#sequence)
  - [Векторы](#векторы)
- [22.10.24 - семинар](#221024---семинар)
  - [Полиморфизм](#полиморфизм)
    - [Параметрический полиморфизм](#параметрический-полиморфизм)
    - [ad-hoc полиморфизм](#ad-hoc-полиморфизм)
- [22.10.28 - лекция](#221028---лекция)
  - [Обработка текстов](#обработка-текстов)
  - [Регулярные выражения](#регулярные-выражения)
    - [Квантификация](#квантификация)
- [22.10.31 - семинар](#221031---семинар)
  - [Ещё немного баззовых типов](#ещё-немного-баззовых-типов)
  - [Полугруппы](#полугруппы)
  - [Моноид](#моноид)
  - [Ещё раз о Maybe](#ещё-раз-о-maybe)
  - [Функтор](#функтор)
  - [Аппликативный функтор](#аппликативный-функтор)
  - [Недетерминированные вычисления](#недетерминированные-вычисления)
- [22.11.07 - семинар](#221107---семинар)
  - [Монады](#монады)
- [22.11.11 - лекция](#221111---лекция)
- [22.11.18 - лекция](#221118---лекция)
- [22.11.21 - семинар](#221121---семинар)
  - [Глубокий смысл монадического связывания](#глубокий-смысл-монадического-связывания)
  - [Чистые функции](#чистые-функции)
  - [Монада Maybe](#монада-maybe)
  - [Монада `[]`](#монада-)
  - [Функция guard](#функция-guard)
- [22.11.25 - лекция](#221125---лекция)
  - [Функторы (теория)](#функторы-теория)
- [22.11.28 - семинар](#221128---семинар)
    - [Монада `Reader`](#монада-reader)
    - [Монада `Writer`](#монада-writer)
- [22.12.02 - Лекция](#221202---лекция)
  - [И снова функторы](#и-снова-функторы)
  - [Аппликативные функторы (ссылка)](#аппликативные-функторы-ссылка)
- [22.12.05 - семинар](#221205---семинар)
  - [Ввод-вывод](#ввод-вывод)
    - [Базовые функции](#базовые-функции)
  - [Случайные числа](#случайные-числа)
  - [Полезные функции для работы с монадами](#полезные-функции-для-работы-с-монадами)
  - [Функция main](#функция-main)
  - [ИЗМЕНЯЕМЫЕ ПЕРЕМЕННЫЕ](#изменяемые-переменные)
- [22.12.09 - лекция](#221209---лекция)
- [22.12.12 - семинар](#221212---семинар)
  - [Исключения](#исключения)
  - [Тестирование](#тестирование)
- [22.12.16 - лекция](#221216---лекция)
- [22.12.19 - семинар](#221219---семинар)
- [23.02.02 - лекция](#230202---лекция)
  - [MonadPlus](#monadplus)


# Контакты преподов
Лектор - Власов Владимир Николаевич

Семинарист - Завьялов Антон Алексеевич / https://t.me/arx_dukalis / + 7 (960) 956 61 14

# Книги
[Изучай Хаскель во имя добра](./%D0%9C%D0%B8%D1%80%D0%B0%D0%BD%20%D0%9B%D0%B8%D0%BF%D0%BE%D0%B2%D0%B0%D1%87%D0%B0-%D0%98%D0%B7%D1%83%D1%87%D0%B0%D0%B9%20Haskell%20%D0%B2%D0%BE%20%D0%B8%D0%BC%D1%8F%20%D0%B4%D0%BE%D0%B1%D1%80%D0%B0-2012.pdf)

# Статьи
- [Описание языка Haskell 98](http://www.haskell.ru/)
- [Мягкое введение в Haskell 1](http://rsdn.org/article/haskell/haskell_part1.xml)
- [Мягкое введение в Haskell 2](http://rsdn.org/article/haskell/haskell_part2.xml)
- [Programming with lambda calculus](https://hbr.github.io/Lambda-Calculus/lambda2/lambda.html)
- [Ещё одно руководство по Монадам (ч. 1 основы)](https://habr.com/ru/post/127556/)

---
# 22.09.02 - Лекция
Императивные языки заточены под архитектуру Фон Неймана.

Суть императивной парадигмы - подробно описывать программе, КАК выполнить задачу.

Декларативная парадигма - ЧТО сделать программе.

Функции всегда чистые (не имеют побочных действий) и детерминированные (результат зависит только от подаваемых значений)

---
# 22.09.05 - Семинар
Haskell - ленивый язык. Любое выражение вычисляется только по необходимости

Типизация в Haskell статическая сильная неявная

`GHCup` - утилита для работы с Haskell

Основные команды:
- `ghc <filename>` - скомпилировать файл
- `runghc/runhaskell <haskell code>` - исполняет выражение на Haskell
- `ghci` - запускает интерпретатор прямо в командной строке

[Hackage](https://hackage.haskell.org) - хранилище пакетов

[Hoogle](https://hoogle.haskell.org) - поисковый движок кода

---
# 22.09.09 - лекция
Файлы `.hs` - простые файлы с кодом на Haskell

Файлы `.lhs` - файлы с разметкой простого текста для написания статей и т.п. (стиль разметки - `reStructuredText`) Чтобы обозначить фрагменты кода используется `>` в начале строки либо особые скобки:
```haskell
\begin{code}

\end{code}
```

## Типы данныех
- `Bool` - операции `&&`, `||`, `not` (`/=`)
- `Char` / `String`
- `Int`
- `Integer` - неограниченный целочисленный тип
- `Float` / `Double`

Если вместо переменной указать `_`, то будет принята переменная любого типа.

Бэктик `\`` можно использовать в именах переменных

## Функции
Пример функции факториала
```haskell
{fact :: Integer -> Integer; fact 0 = 1; fact n = n * fact (n-1)}
```

---
### Немного о рекурсии и ко-рекурсии
Рекурсия и ко-рекурсия
Классическая рекурсия обычно движется вверх (`n+1`), тогда как ко-рекурсия движется вниз (`n+1`). В таком случае необходимо тщательно следить за условиями выхода

---

Можно записать условие в несколько строк:
```haskell
fact` x | n <= 1 = 1
        | otherwise = x * fact` (x-1) 
```

Ветвление похоже на тернарный оператор и является частю функции, а не отдельной сущностью
```haskell
abs x = if x >= 0 then x else -1*x
```

---
Аргументы функции передаются **ЧЕРЕЗ ПРОБЕЛ И БЕЗ СКОБОК!**

При этом сигнатура задаётся не как `f :: Int Int -> Int`, а как `f :: Int -> int -> Int`, так что при реализации получим следующее
```haskell
f x y = x + y -- f (x) + y 
-- Отсюда следует, что можно вызвать функцию, не передавая все аргументы
f` = f 2 -- такая функция приняла 2 как x. Таким образом, функция f` пинимает один аргумент - y из f
```
Такой приём называется *заморозкой аргументнов*. При этом "свбодными" остаются только аргументы с конца.

### Лямбда-функции
```haskell
f = \x -> x-2
mult = \x y z -> x*y*z
mult` = \n -> mult 2 n 3 -- Благодаря лямбда-функциям можно морозить произвольные аргументы
```

---
# 22.09.12 - семинар
Массив записывается в `[]` и должен содержать элементы одного типа.

Корттеж записывается в `()` и может содержать элементы разных типов.

Функция `curry <func>` принимает в себя функцию, принимающую кортеж, и возвращает функцию, принимающую просто список аргументов. `ucurry <func>` делает обратное.

## Локальные переменные
```haskell
f x =
  let a = x*x
      b = x*x*x -- Можно написать a*x
  in a / b

-- Альтернативный вариант

f x = a / b
  where a = x*x
        b = a*x
```
На самом деле `a` и `b` - не переменные, а константы или, ещё точнее, лейблы, действия под которыми вставляются на место основной функции.

## Оператор понижения приоритета
`<func> $ <expr>` - оператор `$` позволяет сначала вычислить выражение справа, а затем передать его налево
```haskell
f $ 1 + 2*5

sin -2 -- Выдаст ошибку, т.к. в функцию sin будет передан аргумент -
sin $ -2 -- Сработает нормально
```

## Оператор композиции
```haskell
f1 x = sin (cos x)
f1 = sin . cos
```

## Операторы возвездения в степень
- `^` - возводит в целую положительную
- `^^` - возводит в целую
- `**` - возводит в любую

---
# 22.09.16 - лекция
## Слово-оператор
Оператор - частный вид функции в инфиксной форме, то есть аргументы записываются с обеих сторон. Если заключить имя функции в ` `` `. Также можно использовать инфиксный оператор как префиксный, заключив его в скобки
```haskell
> 1 + 5 -- 6
> (+) 1 5 -- 6
```

## Кортежи
Кортеж - неизменяемый набор значений произвольного типа, записывается в круглых скобках, полезен для возврата из функции нескольких значений. Чаще всего в кортеже 2 элемента, но может быть до 15-ти.

В работе с кортежами может помочь модуль `Data.Tuple`

## Списки
Опреатор `:` является конструктором списка. Фактически, все списки создаются из пустого
```haskell
list = [1, 2, 3]
list` = 1:[2,3] = 1:(2:[3]) = 1:(2:(3:[])) -- Оператор : - правоассоциативный, а значит скобки писать не обязательно, это было сделано для наглядности
[1, 2, 3] == 1:2:3:[] -- True
```
Данный механизм позволяет реализовывать удобный петтерн-матчинг в функциях, работающих со списками.
```haskell
head (x:_) = x

length [] = 0
length (_:xTail) = 1 + length xTail
```

- Обращение по индексу производится через оператор `!!` (**ОПЕРАЦИЯ ОЧЕНЬ НЕЭФФЕКТИВНА**)
- `xs ++ [x]` - добавление элемента в конец списка
- `xs ++ ys` - конкатенация двух списков
- `concat [a, b, c, ...]` - конкатенация списка списков
- `drop n xs` - удалить первые `n` элементов и вернуть список
- `take n xs` - вернёт список из первых `n` элементов
- `splitAt n xs` - вернёт пару списков: `[head, n)` и `[n, tail]`
- `zip xs ys -> [(xn, yn)]` - упаковывает в пары соответствующие элементы двух списков

*Больше функций в модулей `Data.List`*

---
# 22.09.19 - семинар
## Хвостовая рекурсия
Суть в том, что вычисления производятся не на выходе из рекурсии, а при погружении внутрь. За счёт этого не приходится хранить значения на каждом слое при стремлении вглубь, а значит стэк будет заполняться гораздо медленнее.

```haskell
f $! a b -- оператор `$!` заставляет все вычисления справа проводить в строгом режиме (локлаьно "отключая" ленивость)

-- Если строгость нужна не для всех аргументов, можно сделать такую запись
a `seq` f a b -- в таком случае строго будет вычислен только аргумент a
```
Третий вариант
```haskell
{-# LANGUAGE BangPatterns #-}

f !a b = ... -- Также будет строгим только аргумент a
```

## Мемоизация функций


---
# 22.09.23 - лекция
## Генераторы списков
В Haskell можно задать ленивый бесконечный список
```haskell
getSquares1 = [x*x | x <- [1..]] -- Квадраты всех натуральны чисел. При запуске в таком виде будет бесконечна
getSquares2 n = [x*x | x <- [1,2..n]] -- Получает список квадратов n натуральных чисел
getSquares3 n = [x*x | x <- [1,2..n], x `mod` 2 == 0] -- Получает список квадратов чётных n натуральных чисел
```

## Хваостовая рекурсия
В классической рекурсии мы опускаемся вглубь и затем, на обратном пути, производим вычисления

Пример с посиком n-го числа Фибоначчи
```haskell
fib 0 = 1
fib 1 = 1
fib n | n < 0 = error "n must be greater than or equal to 0"
fib n = fib (n - 1) + fib (n - 2)
```

При использовании хвостовой рекурсии вычисления осуществляются на пути вглубь, а на обртном идёт быстрое "всплывание" ответа до самого верха дерева, за счёт чего время исполнения невероятно сокращается. Чаще всего для этого требуется добавить дополнительный аргумент - аккумулятор итогового значения.

Эффектвиная функция вычисления нужного числа Фибоначчи. Рекурсия в данном случае сразу получает в себя 2 предыдущих числа и номер "глубины". Если номер совпадает с искомым, возвращает сумму двух предыдущих чисел.
```haskell
accFib n | n < 2 = 1
         | otherwise = recursion 1 1 2
    where
        recursion prev2 prev1 counter | counter == n = currentValue
                                      | otherwise = recursion prev1 currentValue (counter+1)
            where
                currentValue = prev1 + prev2
```

## Работа с множествами
```haskell
import Data.List

nub::[a]->[a] -- Воозвращает из списка множество (только уникальные элементы)

```
- `union xs ys` - объединение двух множеств 
- `intersect xs ys` - пересечение двух множеств
- `xs \\ ys` - вычитание из первого множества второго
- `tails xs` - возвращает список хвостов 

**Все описанные выше функции возвращаеют в итоге списки, т.е. элементы могут повторяться, поэтому результат необходимо прогонять через `nub`**

Для ещё более продвинутой работы с множествами (декартово произведение, xor и т.п.) используется модуль [`Data.Set`](https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Set.html)

## Свёртки
Свёртка ([fold](https://wiki.haskell.org/Fold)) - функция, принимающая функцию-обработчик, аккумулятор и список, по которому будет двигаться от начала к концу (левая свёртка) или от конца к началу (правая свёртка).

### Левая свёртка
Левая свёртка берёт первый элемент, обрабатывает его, сохраняет значение в аккумулятор и рекурсивно передаёт в себя хвост списка, из которого опять берёт первый элемент и т.д.
```haskell
-- Функция sum реализуется через левую свёртку
sum = foldl (+) 0
```

### Правая свёртка
Правая свёртка сначала "режет" список на элементы, а потом, возвращаясь из дерева рекурсии, обрабатывает значения и изменяет аккумулятор.
```haskell
-- Функция concat реализуется через правую свёртку
concat = foldr (++) []
```

*Фактически, левая свёртка использует принцип хвостовой рекурсии, а правая - классической.*

### Реализзация
Левая свертка
```haskell
foldl f acc [] = acc
foldl f acc (x:xs) = foldl f (f acc x) xs
```
Правая свёртка
```haskell
foldr f acc [] = acc
foldr f acc (x:xs) = f x (foldr f acc xs)
```

## scan
`scanl` и `scanr` похожи на свёртки, но возвращают не конечное значение-аккумлутор, а все промежуточные результаты его вычисления. То есть первым в списке будет идти начальное значение, а последним - результат, аналогичный свёрткам

# 22.09.30 - лекция
## Система типов
Типизацияё в Haskell сильная, статическая, неявная
- strong (сильная / строгая). Все числа - функции с общим прототипом, благодаря чему осуществляется неявное преобразование типов. Если типы переменных задать явно, то Haskell выдаст ошибку
- статическая
  - Преимущества статической типизацц
    - Все проверки типов проходят во время компиляции, а не выполнения
    - Код работает быстрее
    - Отсеивание ошибок с помощью IDE (работает и с динамической, но хуже)
  - Преимущества динамической типизации
    - Лёгкость в освоении
    - Удобное написание универсальных алгоритмов (сортировка массива символов, целых или вещественных чисел одной и той же функцией) и коллекций с элементами разных типов
- Явная - на самом деле в Haskell реализовано некоторое смещение этих двух методов: если не указывать сигнатуру, типизация будет неявной, а компилятор сам подберёт самую широкую возможную сигнатуру, используя математические методы.
  - Преимущества явной типизации
    - Понимание сути работы функции по одной лишь сигнатуре
    - Нет необходимости запоминать метод работы функций
    - Другим людям проще понимать ваш код
  - Преимущества неявной типизации

Пользовательские типы на самом деле называются алгебраическими

### Перечисление (суммирование)
Наиболее просто способ задать тип - перечисление
```haskell
data Color = Red | Green | Blue | Yellow | Purple | Cyan
  deriving Show

mergeColors Red Green = Yellow
mergeColors Red Blue = Purple
mergeColors Green Blue = Cyan
mergeColors Green Red = Yellow
mergeColors Blue Red = Purple
mergeColors Blue Green = Cyan
```

### С использованием конструктора (Умножение) 
```haskell
data Point = Pt Int Int

getXOfPoint (Pt x _) = x
```
- `Point` - конструктор типа, используется для компиляции в сигнатурах и обеспечивает безопасность
- `Pt` - конструктор данных (значений). Используется в вычислениях.
  - `Pt <num1> <num2>` создаст нам новое значение типа `Point` со значениями `num1` и `num2`

**Names of constructors can be same**

We can define specific types for data-constructor and type-constructor without args (example above).

Or we can define template type in `data`. Then we can define functions with specific signatures
```haskell
data Point a = Pt a a | Pt1 a

sqr :: Point Double -> Double
sqr (Pt x y) = sqrt $ x*x + y*y
sqr (Pt1 x) = sqrt $ x*x + x*x
```

Own data type of list:
```haskell
data List_ a = Nil_ | Init_ a (List_ a)
  deriving Show

-- Construction process
l = Init_ 1 (Init_ 2 (Init_ 3 (Init_ 4 (Init_ 5 Nil_))))
```

### Создание именованных полей
Можно дать полям в конструкторе данных имена, тогда автоматически будет сгенерирован селектор `<fieldName> <dataTypeInstance> = <fieldValue>`
```haskell
data Point = Pt {pX, pY :: Int}

-- Объявить переменную можно двумя видами
p1 = Pt 4 5
p2 = Pt {pY = 9, pX = 8}

sumXY :: Point -> Int
sumXY p = pX p + pY p
-- или
sumXY Pt {pX = x, pY = y} = x + y
-- впрочем, можно использовать и pattern-matching
sumXY (Pt x y) = x + y
```

**Методы сложения и умножения для алгебраических типов данных можно совмещать**

### Другие методы объявления типов
`newType` имеет только один строгий конструктор, имеет только одно поле и используется для конструирования более простых типов данных, но позволяет реализовать дополнительные проверки (валидности email и т.п.).

Также поддерживает объявление полимпорфных типов или конкретных. Можно задать именованное поле

Если брать пример с точкой, то мы можем задать её через `newType` так:
```haskell
newtype Point a = Pt (a, a)

-- Объявить переменную можно двумя видами
p1 = Pt (4, 5)
p2 = Pt (9, 8)

sumXY :: Point Int -> Int
sumXY (Pt (x, y)) = x + y
```

`type <name> = <realType>` - просто создаёт синоним типу `realType` с именем `name`

# 22.10.03 - семинар
## Ещё несколько методов генерации списков
- `iterate f i0` - задаёт бесконечный список, с первым элементом $i_0$ и $i_n = f(i_0)\space n-раз$ 
- `repeat n` - бесконечно повторяет значение `n`
- `cycle arr` - бесконечно повторяет список `arr`

# 22.10.07 - лекция
## Классы
Объявление класса проходит следующим образом
```haskell
module Sosedy (Sosedy, (~~)) where

class Sosedy a where
  (~~) :: a -> a -> Bool
```
Реализация дополнительных методов класса
```haskell
module SimSosedy where

import Sosedy
(~~~) :: (Sosedy a) => a -> a -> Bool
a ~~~ b = (a ~~ b) && (b ~~ a)
```
Реализации класса с конкретными типами
```haskell
module SosedyInst((~~),(~~~)) where
  
```

# 22.10.14 - лекция
Для автоматического добавления отдельных методов работы с новыми классами типами можно использовать `deriving (methods)`
```haskell
data Color = Red | Green | Blue 
  deriving (Eq, Ord, Show) 
```

## Структуры данных в Haskell
### Maybe
Указывает на то, что элемента этого типа может не существовать.
```haskell
data Maybe a = Nothing | Juss a
```

# 22.10.17 - семинар
## Алгебраические типы данных
Типы в Haskell разделяются на примитивные и алгебраические.

- [Определение типа через сумму](#перечисление-суммирование)
- [Определение через конструктор (умножение)](#с-использованием-конструктора-умножение)

# 22.10.21 - лекция
## Map
В `Haskell` ассоциативный список из [`Data.Map`](https://hackage.haskell.org/package/containers-0.4.0.0/docs/Data-Map.html) **ОБЯЗАТЕЛЬНО** должен быть упорядочен по ключам
- `Data.Map.fromList [(k, v)]`- Создание ассоциативного списка самым простым способом
- `insert key value map` - добавление пары `(key, value)` в `map`. **Помни об иммутабельности!**
- `delete key map` - удаление элемента с ключом `key` из `map`
- `member key map` - проверка, есть ли ключ в списке
- `lookup key map` / `map !? key` / `map ! key` - возвращает значение из `map` по ключу `key` либо `Nothing`. Первый вариант конфликтует с `lookup` для списка пар из `Prelude`. Третья версия при вводе несуществующего ключа выдаст исключение (не работает с `Maybe` и `Just`) 
- `union map1 map2` - слияние двух ассоциативных списков
- `keys map` / `elems map` - возвращает список ключей и элементов соответственно

## HashMap
[`Data.HashMap`](https://hackage.haskell.org/package/hashmap-1.3.3/docs/Data-HashMap.html) позволяет работат с ассоциативными списками без упорядочевания списка по ключам. По функциям очень похож на `Data.Map`

## Sequence
Пальчиковы деревья позволяют пользоваться преимуществами списков, деля более эффективными операции, которые в этих списках работают долго (добавление в конец, склеивание списков, индексация). Реализуются в модуле [`Data.Sequence`](https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Sequence.html)

Функции похожи на `Data.List`, но иногда реализуются очень странно, так что лучше всего посмотреть документацию

## Векторы
[Векторы](https://hackage.haskell.org/package/vector) - пход на классический массив из `Data.Array`, но работает эффективнее. Включает в себя в том числе [мутабельные векторы](https://hackage.haskell.org/package/vector-0.13.0.0/docs/Data-Vector-Mutable.html)

- [`Data.Vector`](https://hackage.haskell.org/package/vector-0.13.0.0/docs/Data-Vector.html) - классические векторы
- [`Data.Vector.Storable`](https://hackage.haskell.org/package/vector-0.13.0.0/docs/Data-Vector-Storable.html) - создаёт векторы, защищённые от сборщика мусора. Лучше всего использовать для интеграции с C-библиотеками и примтивными типами данных

[`vector-algorithms`](https://hackage.haskell.org/package/vector-algorithms) - пакет с эффективной реализацией алгоритмов над векторами (в основном сортировок)

# 22.10.24 - семинар
## Полиморфизм
### Параметрический полиморфизм
Используется в Хаскеле почти повсеместно - при задании функции указывается абстрактное имя типа, под которыми могут быть переменные разных типов
```haskell
sum :: a -> b -> b
sum x y = x + y
```

### ad-hoc полиморфизм
Реазлизуется в хаскеле через классы типов - наборы функций, которые работают с экзмеплярами этого класса
```haskell
-- "Сигнатура"
class ClassName classVar where
  method1 :: classVar -> classVar -> OtherType -- Возможны любые комбинации типов
  method2 :: Int -> ClassVar -> Int

-- Рельный пример
class Eq a where
  (==) :: a -> a -> Bool
  (/=) = not . (==)
```
Перегрузка классов типа производится следующим образом:
```haskell
instance (Enum a, Enum b) => Enum (a, b) where -- Здесь перед => накладываются ограничения на абстрактные метки класса типа
  toEnum n = (toEnum n, toEnum n)
  fromEnum (a, b) = fromEnum a

-- Теперь мы можем написать следующее
ziped = [(1,1)..(5,5)] -- [(1,1), (2,2), (3,3), (4,4), (5,5)] 
```

Некоторые встроенные классы типов:
- `Show` - можно вывести в консоль или получить строку методом `show`
- `Eq` - можно сравнить
- `Ord` - можно узнать отношение порядка
- `Enum` - значения можно перечислять

[Статья](https://wiki.haskell.org/Typeclassopedia) про классы типов на Вики

# 22.10.28 - лекция
## Обработка текстов
Для обработки строк можно использовать почти все функции из `Data.List`.

Отдельным полезным модулем выступает [`Data.Text`](https://hackage.haskell.org/package/text-1.2.5.0/docs/Data-Text.html), который работает с особыми текстовыми литералами с классом типа `Text`
- `pack :: String -> Text`
- `unpack :: Text -> String`
- `replace :: Text search -> Text onWhat -> Text where -> Text result` - производит замену в строке `where` всех `search` на `onWhat`

## Регулярные выражения
### Квантификация
Кроме `*` (звёздочки Клини, дающей произвольное количество повторений строки, идущей перед ней)
- `+` - один и более раз
- `?` - ноль или один раз
- `{n}` - ровно `n` раз
- `{m,n}` - от `m` до `n` раз
- `{m,n}` - от `m` до `n` раз
- `{m,}` - более `m` раз
- `{,n}` - `n` или меньше раз

`(<expr>)\1` - говорит, что после нахождения вхождения по выражению `<expr>`, необходимо найти ещё одно точно такое же (`\1` - указывает на результат из первых скобок). Если указать `(<expr>)(\1)*`, то будет произвольное повторение от 1 до бесконечности раз в точности найденного ранее вхождения по выражению `<expr>`

`^<expr>` - отрицание выражения, то есть вхождение будет всё, что ему **НЕ** удовлетворяет

В `[]` указываются диапазоны или наборы символов:
- `[0-9]` (`\d`) - цифры
  - `[^ 0-9]` (`\D`) - не цифры
- `[\f\n\r\t\v]` (`\s`) - пробельные символы
  - `[^ \f\n\r\t\v]` (`\S`) - не пробельные символы
- `[A-Za-z0-9_]` (`\w`) - буквы, цифры, подчёркивание
  - (`\W`) ... Ну вы поняли

`^` - начало строки
`$` - конец строки

# 22.10.31 - семинар
## Ещё немного баззовых типов
- `Bounded` - множество со значениями минимума и максимума
- `Maybe` - "защитный тип" - может иметь какое-то значение под `Just`, а может принимать значение `Nothing`

## Полугруппы
Полугруппа - множество с заданной на нём ассоциативной операцией (то есть не зависящей от порядка операций).
```haskell
class Semigroup a where
  (<>) :: a -> a -> a -- Минимальная реализация
  sconcat :: NonEmpty a -> a -- Фактически, свёртка непустого списка
  stimes :: Integral b => b -> a -> a -- повторяет ассоциативную операцию заданное количество раз
```

Например, списки и операция `++`; упорядоченное множество из двух элементов с операциями минимума или максимума

## Моноид
Моноид - полугруппа с нейтральным элементом (единицей)
```haskell
class Semigroup a => Monoid a where
    mempty :: a -- Минимальная реализация, если мы задаём моноид через instance
    mappend :: a -> a -> a
    mappend = (<>) -- Ассоциативная операция
    mconcat :: [a] -> a -- foldr mappend mempty
```
Свойства моноида:
```haskell
x `mappend` mempty == x
mempty `mappend` x == x
```

## Ещё раз о [Maybe](#maybe)

## Функтор
```haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b

fmap succ (Just 41) -- вернёт Just 42
```
`fmap` выполняет операцию `a -> b` внутри типа `f`, то есть переводит значение типа `f a` в `f b`

Для `fmap` должны выполняться следующие правила
- `fmap id == id` - закон тождественности (identity)
- `fmap (f . g) == fmap f . fmap g` - закон композиции (composition)

`fmap` infix form - `<$>`

```haskell
(+1) <$> Just 5 -- Just 6
(+) <$> Just 4 <$> Just 5 -- error
```

## Аппликативный функтор
```haskell
class (Functor f) => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
```

Аппликативный функтор позволяет использовать функторы с функциями от двух переменных
```haskell
-- Тогда ошибочное выражение выше будет записано
(+) <$> Just 4 <*> Just 5 -- Just 9
```

## Недетерминированные вычисления
Благодаря списку с аппликативным функтором можно моделировать недетерминированные вычисления

# 22.11.07 - семинар
## Монады
```haskell
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b -- Оператор монадического связывания (bind). Минимальное необходимаая функция
  (>>) :: m a -> m b -> m b
  return :: a -> m a -- Стрелка Клейсли
```

Оператор `>>=` получает обёрнутый в монаду (контейнер) тип и засовывает значение из контейнера в функцию, возвращающую новое значение под монадой (внутри контейнера)

оператор `>>` 

`return` представляет собой стрелку Клейсли почти в чистом виде, оборачивая значение в монаду

```haskell
((return 10) :: Maybe Int) >>= return . succ -- вернёт Just 11
```

Оператор `>=>` - это композиция стрелок клейсли, причём стрелка `return` тут выступает нейтральным элементом

# 22.11.11 - лекция

# 22.11.18 - лекция
Группа:
- Ассоциативность
- Нейтральный элемент
- Обратный элемент

Моноид ([Реализация в Haskell](#моноид)):
- Ассоцитивность
- Нейтральный элемент

Полугруппа ([Реализация в Haskell](#полугруппы)):
- Ассоциативность

# 22.11.21 - семинар
## Глубокий смысл монадического связывания
Монады позволяют реализовывать такие штуки
```haskell
expr :: Maybe Int
expr =
  return 10 >>= (\a ->
    return 20 >>= (\b ->
      return 30 >>= (\c ->
        return $ (a + b) * c
      )  
    )  
  )
```
Добавим синтаксического сахара
```haskell
expr :: Maybe Int
expr x = do
  a <- return 10
  b <- return $ 20 / x --считаем, что деление безопасно
  let c = 30

  return (a + b) * c
```

## Чистые функции
- Полная определённость (тотальность) - даёт ответ для любого аргумента
- Детерминированность
- Отсутствие побочных эффектов - не ссылаются на внешние данные и не изменяют их

Вычислительный эффект - это любое действие, нарушающее свойства чистых функций.

Примеры вычислительных эффектов:
- Частичность - функция определена не для всех значений аргумента (то есть не завершается: выкидывает исключение и т.п.). Избавиться от частичности помогает [монада `Maybe`](#монада-maybe)
- Недетерменированность
  - Нестабильность - функция не всегда возвращает одинаковые значения для одного значения аргумента. Спаситель - [монада `Reader`](#монада-reader)
  - Множественность - функция возвращает сразу несколько ответов. Избавиться от моножественности помогает [монада `[]`](#монада)
- Побочный эффект - функция кроме возврата значения делает что-то ещё. Спаситель - [монада `Writer`](#монада-writer)

## Монада Maybe
Реализация крайне просто
```haskell
instance Monad Maybe where
  return = Just
```
В таком случае, например, если в функции возникает деление на 0, мы можем избавиться от частичности, вернув `Nothing`

## Монада `[]`
Реализация чуть сложнее, но всё ещё весьма проста
```haskell
instance Monad [] where
  return x = [x]
  xs >>= f = concat (map f xs) 
```
Благодаря этой монаде мы можем избавиться от эффекта множественности. Например, при решении квадратного уровнения.

## Функция guard
Функция `guard` позволяет нам вернуть нейтральный элемент, если условие даёт `false`, иначе - продолжить вычисления
```haskell
import Control.Monad (guard)

fsafe :: Double -> Maybe Double
fsafe x = do
  cos2 <- return $ 2 * cos x
  squarePolinom <- return $ x**2 + 2*x - 10 
  guard (x > 0)
  ln <- return $ (log x)**(exp 1)
  cosLn <- return $ cos ln
  oLitte <- return 0.000000001
  guard (abs cos2 > oLitte && abs squarePolinom > oLitte && abs cosLn > oLitte)
  sum <- return $ (tan ln) + 1 / cos2
  return $ sum / squarePolinom
```

# 22.11.25 - лекция
Так как Haskell часто работает с бесконечными математическими объектами, компилятор может проверить далеко не всё, поэтому часть ответственности за корректность написанных классов и сущностей ложится на пользователя

Эндоморфная функция - функция, возвращающая тот же тип, что был получен на вход.

## Функторы (теория)
Функтор отображает одну категорию в другую.

*Категорию можно представить как графк со значениями и стрелками. При отображении переносятся все элементы и все стрелки*

Функтор обрабатывает значение внутри функции и добавляет результату новый контекст.

Функтор удовлетворяет всем свойствам моноида:
- Ассоциативная операция (`<>`) - композиция
- Нейтральный элемент - `id`

Эндофунктор - оторбажает категорию саму в себя (**ОЧЕНЬ ВАЖНО**). Фактически, в Haskell чаще всего реализуется именно он. (*Технически, можно и реализовать отображение из Maybe в [], но нужда такого отображения вызывает сомнения*)

[Реализация на Haskell](#функтор)

# 22.11.28 - семинар
Вместо [функции guard](#функция-guard) можно использовать pattern-matching. Будет работать аналогично

```haskell
fsafe :: Double -> Maybe Double
fsafe x = do
  cos2 <- return $ 2 * cos x
  squarePolinom <- return $ x**2 + 2*x - 10 
  True <- (x > 0)
  ln <- return $ (log x)**(exp 1)
  cosLn <- return $ cos ln
  oLitte <- return 0.000000001
  True <- (abs cos2 > oLitte && abs squarePolinom > oLitte && abs cosLn > oLitte)
  div <- safeDiv 1 cos2
  sum <- return $ (tan ln) + div
  return $ sum / squarePolinom
```

**Разумеется, кроме `True` можно задавать и более сложные шаблоны. Например, сравнивать значения в строке**

**Здесь используется функция монады `fail`**

Списковые включения можно заменить на монады
```haskell
evens = [x | x <- [1..], x `mod` 2 == 0]

evensWithMonad = do
  x <- [1..]
  True <- return $ x `mod` 2 == 0
  return x
```

### Монада `Reader`
Используется для хранения функции, работающей с окружением, то есть нестабильных функций

*Не особо понял суть, так что при необходимости надо будет почитать, а пока что ограничусь этим описанием*

### Монада `Writer`
Позволяет нам фиксировать побочные эффекты
```haskell
newtype Writer w a = Writer { runWriter :: (a, w) }

instance Monoid w => Monad (Writer w) where
  return v = Writer (v, mempty)
  Writer (x, v) >>= let (Wirter (y, v_)) = f x
                    in Writer (y, v `mappend` v')
```

# 22.12.02 - Лекция
## И снова функторы
Здесь в очередной раз рассматривается [класс `Functior` и его функция `fmap` (`<$>`)](#функтор)

## Аппликативные функторы (ссылка)
Дополнение к записям с семинара будет [там же](#аппликативный-функтор)

# 22.12.05 - семинар
## Ввод-вывод
Ввод-вывод осуществляется при помощи типа `IO`
```haskell
newtype IO a = IO (RealWorld -> (RealWord, a))
```
`RealWorld` - полумагическая штука, которая существует только на уровне системы типов

Но на самом деле это, конечно, монада
```haskell
instance Monad IO where
  return x = IO $ \v -> (v, x)
  m >>= k = IO $ \v ->
    case m v of

```

### Базовые функции
- `getChar :: IO Char`
- `getLine :: IO String`
- `getContents :: IO String` - считывает весь файл
- `putChar :: Char -> IO ()`
- `putStr :: String -> IO ()`
- `putStrLn :: String -> IO ()`
- `print :: Show a => a -> IO ()`
- `hFlush <stream>` - сброс буфера потока

## Случайные числа
Модуль `System.Random`. Устанавливается через `cabal install --lib random`
`randomIO :: Type`
`randomRIO :: Type`

## Полезные функции для работы с монадами
```haskell
mapM :: (Traversable t, Monad m) => (a -> m a) -> t a -> m b
forM :: (Traversable t, Monad m) => t a -> (a -> m a) -> m b
sequence :: (Foldable, Monad m) => t (m a) -> (a -> m a) -> m (t a)
```

## Функция main
Работает по принципу `main` в том же Си (**Почти всегда с `do`-нотацией**):
- Если загружать файл с `main` через `ghci`, то надо вызывать её как и любую другую функцию
- Если компилировать через `ghc`, то в `exe`-файле будет вызываться автоматически

## ИЗМЕНЯЕМЫЕ ПЕРЕМЕННЫЕ
**НЕ ИСПОЛЬЗОВАТЬ! ВООБЩЕ НИКОГДА!**

Моудль `Data.IORef`:
- `newIORef <value>` - создаёт ссылку
- `readIORef`
- `writeIORef`

# 22.12.09 - лекция
*До сих пор не выложил файл, так что даже хз, что там было...*

# 22.12.12 - семинар
## Исключения
Модуль `Control.Exception` позволяет обрабатывать исключения
- `catch :: Exception e => IO a -> (e -> IO a) -> IO a` - ловит исключение
- `catches` - *Ловит сразу несколько разных исключений?*
- `try :: Exception e => IO a -> IO (Either e a)` - обозначает, что тут надо ловить исключение
- `evaluate :: a -> IO a` - *считает выражение?*
- `throwIO :: Exception e => e -> IO a` - выбрасывает исключение

Тип `Either` хранит ошибку и значение
```haskell
data Either a b = Left a | Right b
-- Left - ошибка
-- Right - значение
```

## Тестирование
- Ручное
- Автматизированное
  - Юнит-тесты
  - Проверка свойств

Фреймворки для тестов на Хаскеле:
- `HUnit`
- `QuickCheck`

# 22.12.16 - лекция
*Лектор болел и пока что даже не выложил презентацию*

# 22.12.19 - семинар
$$
Ax + By + Cz + D = 0
\newline
Ax + By + Cz = -D
\newline
y=0,z=0 => x = -D/A
\newline
x=0,z=0 => y = -D/B
\newline
x=0,y=0 => z = -D/C
$$

# 23.02.02 - лекция
Ещё раз про базовые монады ([см. тут](#монады))

## MonadPlus

## Writer